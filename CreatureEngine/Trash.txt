         ///Window operator=(const Window& _other)
        ///{
        ///    WindowShader = _other.WindowShader;
        ///    defaultCamera = _other.defaultCamera;
        ///    Parent = _other.Parent;
        ///    GL_Context = _other.GL_Context;
        ///    Handle = _other.Handle;
        ///    DeviceContext = _other.DeviceContext;
        ///    Size = _other.Size;
        ///    Position = _other.Position;
        ///    WindowProperties = _other.WindowProperties;
        ///    PixelFormatDescriptor = _other.PixelFormatDescriptor;
        ///    PixelFormat = _other.PixelFormat;
        ///    Title = _other.Title;
        ///    Active = _other.Active;
        ///    Alive = _other.Alive;
        ///    Visible = _other.Visible;
        ///
        ///    Observer = std::move(_other.Observer);
        ///}


        /* struct EventHandler
        {
            EventHandler() = default;
        public:
            static EventHandler& get();                 // Initializes EventSystem when called first time


            void PollEvents();
            void PostMSG(Event msg);
            bool PeekMSG(Event& msg, unsigned int rangemin, unsigned int rangemax, int handlingflags);
            bool PeekMSG(Event& msg);

            void Dispatch(Event msg);

            void RegisterListener(MsgType msg, Listener& handler);
            void RemoveListener(MsgType msg, Listener& handler);

            EventHandler(EventHandler const&) = delete; // and prevents Copies from being made
            void operator = (EventHandler const&) = delete;

        private:
            std::queue<Event> Messages;
            std::unordered_map<MsgType, std::vector<Listener*>> ListenerMap;
        };*/




      //  AppInstance->mainWindow = std::forward<Application::Window>(_window);
     //   std::string N = _window.g_Title();
    //    Print("Application Name is    : " << AppInstance->mainWindow.g_Title());
   //     Print("Setting Application To : " << N);
        //AppInstance->mainWindow = *(_window);
     //   std::swap(AppInstance->mainWindow, _window);
       // *&AppInstance->mainWindow = &_window;
    //  memcpy(&AppInstance->mainWindow, &_window, sizeof(Application::Window));


/* =============================================================================================================================================*/

 
 
 
 
 
 //Assimp::Importer importer;
  //const aiScene* scene = importer.ReadFile("../Resources/Models/Mech/Drone.fbx",
  //    aiProcess_CalcTangentSpace |
  //    aiProcess_Triangulate |
  //    aiProcess_JoinIdenticalVertices |
  //    aiProcess_SortByPType);
  //



// FFx = (float)(cos(RADIANS(Ang++)) * 200);        FFy = (float)(-sin(RADIANS(Ang)) * 200);


//class Mesh;
//class Application;
//
//Mesh::Mesh();
//Mesh::Mesh(std::string file);
//void Mesh::Bind();
//void Mesh::Render();
//void Mesh::Unbind();
//void Mesh::Update();
//void Mesh::GetPrimativeType(unsigned int input);
//
//Graphics::Bitmap::Bitmap(void * _memory, Vec2 _dimensions) noexcept
//Graphics::Bitmap::Bitmap(std::string _file) noexcept
//void Graphics::Bitmap::FlipYAxis()
//void Graphics::Bitmap::FlipXAxis()
//
// 
//void  Application::Window::Window::InputDevices::_mouse::Hide() { Print("Hide Mouse"); }
//void  Application::Window::Window::InputDevices::_mouse::Show() { Print("Hide Mouse"); }
//void  Application::Window::Window::InputDevices::_mouse::Update(Vec2 _pos, float _wheel);
//
//Application::Window::Window::InputDevices&   Application::Window::getInput();
//
//Application::Window::Window();
//Application::Window::Window(uint32_t _width, uint32_t _height, std::string _name, DWORD _flags) noexcept;
//Application::Window::Window(Window* _parent, uint32_t _width, uint32_t _height, std::string _name, DWORD _flags = 0) noexcept;
//
//        /* Returns Windows Position */
//        Vec2     Application::Window::g_Position() const noexcept;
//        /* Returns X location of Window on Screen */
//        float    Application::Window::g_PositionX() const noexcept;
//        /* Returns Y location of Window on Screen */
//        float    Application::Window::g_PositionY() const noexcept;
//        /* return the Dimensions of a Window */
//        Vec2     Application::Window::g_Size() const noexcept;
//        /* Gets the Name of the Window */
//        std::string   Application::Window::g_Title();
// 
//        /* Return the Parent Window if this is a Child */
//        Window&   Application::Window::g_Parent() const noexcept;
//
//
//        /* Sets the Parent Window if this is a Child */
//        Window&   Application::Window::s_Parent() const noexcept;
//        /* Sets the location of a Window */
//        void     Application::Window::s_Position(Vec2 _pos)  noexcept;
//        /* Sets the X location for a Window */
//        Vec2    Application::Window::s_PositionX(float _x) noexcept;
//        /* Sets the Y location for a Window */
//        Vec2     Application::Window::s_PositionY(float _y) noexcept;
//        /* Sets Window Width */
//        void   Application::Window::s_Width(int _x) const noexcept;
//        /* Sets Window Height*/
//        void   Application::Window::s_Height(int _y) const noexcept;
//        /* Sets Window Title */
//        void   Application::Window::s_Title(std::string _name);
//
//        /* Sets Window Dimensions */
//        void   Application::Window::s_Size(Vec2 _size) noexcept
//
//            /* Sets the Width */
//            Vec2     Application::Window::s_Height() const noexcept;
//
//
//        /* Return the Width dimension of a Window */
//        int   Application::Window::Width()     const noexcept;
//        /* Return the Height Dimension of a Window */
//        int    Application::Window::Height()    const noexcept;
//
//        /* Return if the Window is Alive
//        Note: A Window can be invisible and still be Alive. When the final Window is no longer Alive our Application will terminate*/
//        bool   Application::Window::isAlive()   const noexcept;
//
//        /* Let us know if the Window is currently Visible on Screen
//        Note: Intentions are to hide all child Windows if Parent becomes invisible*/
//        bool   Application::Window::isVisible() const noexcept;
//
//        /* Allow us to see if the Window in Question is the Currently Active window on the screen */
//        bool   Application::Window::isActive()  const noexcept;
//
//        /* Display the contents of the back buffer to the Screen (*note:future at VSync if Specified) */
//        void   Application::Window::Sync();
//
//        /* Clear the Contents of the BackBuffer */
//        void   Application::Window::CLS();      // Clear The Screen And The Depth Buffer
//
//        /* Returns the Native Windows Handle (HWND) of the Window */
//        const HWND   Application::Window::g_Handle() const noexcept;
//
//        /* Changes with Window size and OpenGL Viewport settings */
//        void   Application::Window::ResizeWindow(uint32_t _x, uint32_t _y);
//
//        /* Returns the Windows Device Context */
//        HDC   Application::Window::g_DeviceContext() noexcept;
//
//        /* Return the Most basic and default Shader */
//        uint32_t   Application::Window::defaultShaderHandle() noexcept; 
//
//        /* Gets the default Shader Object */
//        Shader&   Application::Window::defaultShader() noexcept; 
//
//        /* Return the OS Dimensions of the Window */
//        Vec2   Application::Window::get_WindowSize();
//
//        /* returns the default Camera for our Window */
//        Camera2D&   Application::Window::g_Camera() noexcept;
//
//
//            /* Sets the Default Camera for our Window */
//            void   Application::Window::s_Camera(Camera2D* _camera) noexcept;
// 
//        void Application::Window::create_DefaultShader();
// 
//         //  static EventHandler& Messenger() { return EventHandler::get(); } 
//     //   EventHandler& Application::Window::Messenger() noexcept { return Observer; }
// 
//  
//    Application::Application();
//    //Application(int _width, int _height, std::string _name) noexcept;
//
//    Application::~Application() noexcept;
//
//    /* Called when Application is Initialized */
//    void  Application::Init();
//    /* Called when Application is created or comes back from a pause */
//    void  Application::Run();
//    /* Halts Applications execution until run is called again */
//    void  Application::Pause();
//    /* Cleanup Application on Termination */
//    void  Application::End();
//    /* Called Once a Frame to Update Application state */
//    void  Application::Update();
//    /* Called Once a Frame to Render Application */
//    void  Application::Render();
//    /* Kills our Application */
//    void  Application::Terminate();// noexcept { Running = false; }
//
//    /* Returns the Title of the Applications Window */
//    std::string  Application::Name() noexcept;
//    /* Return the Width dimension of the Main Window */
//    int    Application::Width() const noexcept;
//    /* Return the Height Dimension of the Main Window */
//    int    Application::Height() const noexcept;
//    /* Tells us the application is currently running 	NOTE: Perhaps enumerate this to allow more states */
//    bool   Application::isRunning() const noexcept;
//    /* Returns Applications Position */
//    Vec2   Application::g_Position() const noexcept;
//    /* Returns Applications X location on Screen */
//    float  Application::g_PositionX() const noexcept;
//    /* Returns Applications Y location on Screen */
//    float  Application::g_PositionY() const noexcept;
//
//    /* Sets the location of a Window */
//    void   Application::s_Position(Vec2 _pos)  noexcept;
//    /* Sets the X location for a Window */
//    Vec2   Application::s_PositionX(float _x) noexcept;
//    /* Sets the Y location for a Window */
//    Vec2   Application::s_PositionY(float _y) noexcept;
//    /* Sets the Size for the base Window of Application */
//    void   Application::s_Size(Vec2 _size) noexcept;
//    /* Sets the Width for the base Window of Application */
//    void   Application::s_Width(int _x) const noexcept;
//    /* Sets the Height for the base Window of Application */
//    void   Application::s_Height(int _y) const noexcept;
//    /* Sets the Title for the base Window of Application */
//    void   Application::s_Name(std::string _name);
//
//
//    /* Removes an Event from our Listener Queue   */
//    void  Application::RemoveListener(MsgType msg, Listener& handler);
//    /* Registers a Callback for specified Message */
//    void  Application::RegisterListener(MsgType msg, Listener& handler);
//    /* Gather the Events from the OS */
//    void  Application::PollEvents();
//    /* Dispatches Events to their Registered Objects */
//    void  Application::Dispatch(Event  msg);
//    /* Post a Message to Applications */
//    void  Application::PostMSG(Event  msg);
//    /* Non Blocking check of our Message Queues */
//    bool  Application::PeekMSG(Event& msg, unsigned int rangemin, unsigned int rangemax, int handlingflags);
//    /* Basic Nonblocing check of our Message Queue */
//    bool  Application::PeekMSG(Event& msg);
//
//    /* Resize the Application */
//    void  Application::Resize(Vec2 _size);
//protected:
//
//    /* Executed when Application is Initialized */
//    virtual void  Application::OnCreate();
//    /* Executed at Start of Application */
//    virtual void Application::OnStart();
//    /* Executed Application is Started on creation or after a Pause */
//    virtual void  Application::OnRun(); /// Differs from start in that it can resume execution; Possibly change to Resume later or something
//    /* Executed when Application is Paused 	NOTE: Incomplete */
//    virtual void  Application::OnPause();
//    /* Executed when Application goes to sleep from lack of Messages	NOTE: Incomplete */
//    virtual void  Application::OnSleep();
//    /* Called when Application Terminates */
//    virtual void  Application::OnEnd();
//    /* Called once a frame on Application Update */
//    virtual void  Application::OnUpdate();
//    /* Called once a frame when our Application is Rendered */
//    virtual void  Application::OnRender();
//
//    void  Application::CreateApplicationWindow();
//    virtual void  Application::SetWindowProperties();
//
//    static void  Application::set(Application& _app) noexcept;
// 
//
//    static Application&  Application::get() noexcept;
//    static Application::Window&  Application::getWindow() noexcept;
//    static void  Application::setWindow(Application::Window& _window)
//    static Application::Window::InputDevices&  Application::getDevice() noexcept;
//    static Window::InputDevices::_mouse&  Application::getMouse();
//    static Window::InputDevices::_keyboard&  Application::getKeyboard();
//    static void  Application::setCamera(Camera2D& _camera)
//
//    static Camera2D&  Application::getCamera()
// 
//
////Vec2 SplitLParam(int lParam);


// {
          //     RADIANS(GLOBAL_Delta_Mouse.x),
          //     0,
          //     RADIANS(GLOBAL_Delta_Mouse.y)
          // }


bool TEST_PROFILE_WINDOW()
{
    {
        Profiling::DisplayWindow Test({ 0,0 }, { 10, 150 }, { 30, 450 });
        {	// TEST SET PIXEL

            Test.setPixel(1, 1, Pixel(255, 255, 255, 255));
        }
        {	// TEST UPDATE

            Test.Update(1);
            if (Test.getPixel(1, 2) _NOT_EQUAL_TO_ 0xffffffff)return false;
        }
        {	// REPEATEDLY TEST TO ENSURE UPDATE IS MOVING THE VALUES DOWN

            Test.Update(1);
            if (Test.getPixel(1, 3) _NOT_EQUAL_TO_ 0xffffffff)return false;
            Test.Update(1);
            if (Test.getPixel(1, 4) _NOT_EQUAL_TO_ 0xffffffff)return false;
            Test.Update(1);
            if (Test.getPixel(1, 5) _NOT_EQUAL_TO_ 0xffffffff)return false;
            Test.Update(1);
            if (Test.getPixel(1, 6) _NOT_EQUAL_TO_ 0xffffffff)return false;
            Test.Update(1);
            if (Test.getPixel(1, 7) _NOT_EQUAL_TO_ 0xffffffff)return false;
            Test.Update(1);
            if (Test.getPixel(1, 8) _NOT_EQUAL_TO_ 0xffffffff)return false;
        }
        {	// TEST TO MAKE SURE IT IS NOT LEAVING A VALUE BEHIMD AND IS NOT JUST SETTING NEW VALUE

            if (Test.getPixel(1, 7) _EQUALS_ 0xffffffff)return false;
        }
    }

    return true;
}




    /// Attributes can be Aliased with multiple ones occupying the same location
    /// They can be turned on and off as long as one attribute per location is active.
    ///void glEnableVertexAttribArray(GLuint index);
    ///void glDisableVertexAttribArray(GLuint index);

    // glArrayElement, glDrawArrays, glDrawElements, glDrawRangeElements glMultiDrawArrays, or glMultiDrawElements is called.See glNormalPointer.
    //void glVertexAttribPointer(GLuint index,        GLint size,        GLenum type,        GLboolean normalized,        GLsizei stride,        const void * pointer);
    //If a non - zero named buffer object is bound to the GL_ARRAY_BUFFER target(see glBindBuffer) while a generic vertex attribute array is specified, pointer is treated as a byte offset into the buffer object's data store




// WARN_ME("This is likely to corrupt the Stack and almost surely will corrupt the Iterators. While there are standard ways of inserting into a vector they are slow and the Vectors will be completely removed in the future.");
// memcpy(&Colors[0], _pointer, _size);
// OpenGL::set_Attribute(_stride, "VColor");



/// Old Engine stuff to review Attribute Pointers
// oid VertexBuffer::Bind()
// 
//    _GL(glBindBuffer(GL_ARRAY_BUFFER, ID));
//    glVertexPointer(3, GL_FLOAT, 0, (char *)NULL);
//    glEnableClientState(GL_VERTEX_ARRAY);
// 
// oid VertexBuffer::Unbind()
// 
//    glDisableClientState(GL_VERTEX_ARRAY);
//    glBindBuffer(GL_ARRAY_BUFFER, 0);
// 
// oid VertexBuffer::Rebuild()
//     //glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertexPositions), &fNewData[0]);
//    glBindBuffer(GL_ARRAY_BUFFER, ID);
//    glBufferSubData(GL_ARRAY_BUFFER, 0, ElementCount * sizeof(Vec3), Data);
//    glBindBuffer(GL_ARRAY_BUFFER, 0);
// 
// ormalBuffer::~NormalBuffer()
// 
//    glDeleteBuffers(1, &ID);
// 
// ormalBuffer::NormalBuffer(Vec3 *NormalData, GLsizei count)
//    : ElementCount(count),
//    ID(0)
// 
//    Data = new Vec3[count];
//    Data = NormalData;// Wow this was stupid, Allocate all the Memory than Immediately throw it away and assign a different address
//    ID = OpenGL::new_VBO();
//    OpenGL::bind_VBO(ID);
//    OpenGL::set_BufferData(ElementCount * sizeof(Vec3), NormalData);
//    OpenGL::unbind_VBO();
// 
// oid NormalBuffer::Bind()
// 
// 
//    glBindBuffer(GL_ARRAY_BUFFER, ID); // 
//    glNormalPointer(GL_FLOAT, 0, (void *)NULL);
//    glEnableClientState(GL_NORMAL_ARRAY);
// 
// oid NormalBuffer::Unbind()
// 
//    glDisableClientState(GL_NORMAL_ARRAY);
//    glBindBuffer(GL_ARRAY_BUFFER, 0);
// 
 
//void glIndexPointer(GLenum type,
//    GLsizei stride,
//    const void * pointer);
//void glVertexPointer(GLenum type,
//    GLsizei stride,
//    const void * pointer);
//void glNormalPointer(GLenum type,
//    GLsizei stride,
//    const void * pointer);
//void glSecondaryColorPointer(GLint size,
//    GLenum type,
//    GLsizei stride,
//    const void * pointer);
//void glFogCoordPointer(GLenum type,
//    GLsizei stride,
//    void * pointer);
//void glTexCoordPointer(GLint size,
//    GLenum type,
//    GLsizei stride,
//    const void * pointer);
//






    // OpenGL::bind_IBO(GL_Handle);
    // OpenGL::bind_IBO(buffer->GL_Handle);

    //Active_Program->Unbind();
    //==================================================
    //pointer_Index.set_Data(_type, _stride, _pointer);
    //==================================================
    //assert(GL_Handle != NULL);
    //Size = 0;
    //Type = _type;
    //Name = _name;
    //Stride = _stride;
    //Pointer = _ptr;
    //
    //Bind();
    //OpenGL::set_Attribute(_stride, Name);
    //OpenGL::set_BufferData(_size, _ptr);
    //==================================================
///    _static std::string GL::V =
///    "#version 330 core                             \n\
///                    layout(location = 0) in vec3 Position; \n\
///                    layout(location = 1) in vec4 VColor;   \n\
///                    uniform mat4 ModelViewProjectionMatrix;         \n\
///                    out vec4 FColor;                       \n\
///                    void main()                            \n\
///                    {                                      \n\
///                        FColor = VColor;                   \n\
///                        gl_Position = ModelViewProjectionMatrix* vec4( Position.x, Position.y, Position.z, 1.0); \n\
///                    }";
///    
///    _static std::string GL::F =
///    "#version 330 core                      \n\
///                    in vec4 FColor;                 \n\
///                    out vec4 FragColor;             \n\
///                    void main()                     \n\
///                    {                               \n\
///                        FragColor = FColor;  \n\
///                    }";





//
//#version 330 core                             
//layout(location = 0) in vec3 Position;
//layout(location = 1) in vec4 VColor;   
//uniform mat4 ProjectionMatrix;
//uniform mat4 ModelViewMatrix;         
//out vec4 FColor;                       
//void main()                            
//{                                      
//  FColor = VColor;                   
//  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Position.x, Position.y, Position.z, 1.0); 
//}
//
//#version 330 core                     
//in vec4 FColor;        
//out vec4 FragColor;    
//void main()            
//{                      
//  FragColor = FColor;
//}









//  GL_CURRENT_BIT    //	Current RGBA color
//  GL_POINT_BIT          //	//GL_POINT_SMOOTH flag
//  GL_LINE_BIT //	GL_LINE_SMOOTH flag
//  GL_POLYGON_BIT         //	//GL_CULL_FACE enable bit
//
//  GL_POLYGON_STIPPLE_BIT         //	Polygon stipple image
//  GL_PIXEL_MODE_BIT         //	GL_RED_BIAS and GL_RED_SCALE settings
//  GL_LIGHTING_BIT      ///GL_COLOR_MATERIAL enable bit
//  GL_FOG_BIT     //	GL_FOG enable bit
//
//  GL_DEPTH_BUFFER_BIT        
//  GL_ACCUM_BUFFER_BIT
//  GL_STENCIL_BUFFER_BIT 
//  GL_VIEWPORT_BIT    //	Depth range(near and far)
//
//  GL_TRANSFORM_BIT  // Coefficients of the six clipping planes
//  GL_ENABLE_BIT 
//  GL_COLOR_BUFFER_BIT 
//  GL_HINT_BIT    //	GL_PERSPECTIVE_CORRECTION_HINT setting
//
//  GL_EVAL_BIT 
//  GL_LIST_BIT      //	GL_LIST_BASE setting
//  GL_TEXTURE_BIT	  //Enable bits for the four texture coordinates
//  GL_SCISSOR_BIT            //	GL_SCISSOR_TEST flag





    // uint32_t type_Index{ 0 };
// uint32_t stride_Index{ 0 };
// void *pointer_Index{ nullptr };
//
// uint32_t size_Color{ 0 };
// uint32_t type_Color{ 0 };
// uint32_t stride_Color{ 0 };
// void *pointer_Color{ nullptr };
//
// uint32_t size_Vertex{ 0 };
// uint32_t type_Vertex{ 0 };
// uint32_t stride_Vertex{ 0 };
// void *pointer_Vertex{ nullptr };
//
//
// uint32_t type_Normal{ 0 };
// uint32_t stride_Normal{ 0 };
// void *pointer_Normal{ nullptr };
//
// uint32_t size_FogCoord{ 0 };
// uint32_t type_FogCoord{ 0 };
// uint32_t stride_FogCoord{ 0 };
// void *pointer_FogCoord{ nullptr };
//
//
// uint32_t size_TexCood{ 0 };
// uint32_t type_TexCoord{ 0 };
// uint32_t stride_TexCoord{ 0 };
// void *pointer_TexCoord{ nullptr };
//
// uint32_t size_SecondaryColor{ 0 };
// uint32_t stride_SecondaryColor{ 0 };
// uint32_t type_SecondaryColor{ 0 };
// void *pointer_SecondaryColor{ nullptr };




//struct GL_Attribute
//{
    ///glPushAttrib(GL_CURRENT_BIT | GL_LIGHTING_BIT | GL_COLOR_BUFFER_BIT | GL_ENABLE_BIT...etc
//struct Bit_Flags
//{
//    uint32_t unused1 : 1;
//    uint32_t unused2 : 1;
//    uint32_t MULTISAMPLE_State : 1;
//    uint32_t unused4 : 1;
//
//    uint32_t unused5 : 1;
//    uint32_t unused6 : 1;
//    uint32_t unused7 : 1;
//    uint32_t unused8 : 1;
//
//    uint32_t unused9 : 1;
//    uint32_t unused10 : 1;
//    uint32_t unused11 : 1;
//    uint32_t unused12 : 1;
//
//    uint32_t CURRENT_State : 1;         //  GL_CURRENT_BIT      Current RGBA color
//    uint32_t POINT_State : 1;           //  GL_POINT_SMOOTH flag
//    uint32_t LINE_State : 1;	        //  GL_LINE_SMOOTH flag
//    uint32_t POLYGON_State : 1;         //   GL_POLYGON_BIT     	//GL_CULL_FACE enable bit
//
//    uint32_t POLYGON_STIPPLE_State : 1; //	Polygon stipple image
//    uint32_t PIXEL_MODE_State : 1;      //	GL_RED_BIAS and GL_RED_SCALE settings
//    uint32_t LIGHTING_State : 1;        //  GL_COLOR_MATERIAL enable bit
//    uint32_t FOG_State : 1;             //	GL_FOG enable bit
//
//    uint32_t DEPTH_BUFFER_State : 1;
//    uint32_t ACCUM_BUFFER_State : 1;
//    uint32_t STENCIL_BUFFER_State : 1;
//    uint32_t VIEWPORT_State : 1;         //  Depth range(near and far)
//
//    uint32_t TRANSFORM_State : 1;        //  Coefficients of the six clipping planes
//    uint32_t ENABLE_State : 1;
//    uint32_t COLOR_BUFFE_State : 1;
//    uint32_t HINT_State : 1;              //  GL_PERSPECTIVE_CORRECTION_HINT setting
//
//    uint32_t EVAL_State : 1;
//    uint32_t LIST_State : 1;             //  GL_LIST_BASE setting
//    uint32_t TEXTURE_State : 1;	         //  Enable bits for the four texture coordinates
//    uint32_t SCISSOR_State : 1;          //  GL_SCISSOR_TEST flag
//}State_Flags;
    //0, 0, 0, 0,    0, 0, 0, 0,    0, 0, 0, 0,    0, 0, 0, 0,    0, 0, 0, 0,    0, 0, 0, 0,    0, 0, 0, 0,    0, 0, 0, 0,

           ////GL_MULTISAMPLE flag
//        void set_Handle(uint32_t _handle) { GL_Handle = _handle; }

//GL_DEPTH_TEST enable bit
//        GL_ALPHA_TEST enable bit
//        GL_BLEND enable bit
//        GL_DITHER enable bit
//        GL_DRAW_BUFFER setting
//        GL_COLOR_LOGIC_OP enable bit
//        GL_INDEX_LOGIC_OP enable bit
//        GL_CURRENT_RASTER_POSITION_VALID flag
//        GL_EDGE_FLAG flag
//        GL_DEPTH_WRITEMASK enable bit
//        	GL_ALPHA_TEST flag
//        GL_AUTO_NORMAL flag
//        GL_BLEND flag
//        GL_COLOR_MATERIAL
//        GL_CULL_FACE flag
//        GL_DEPTH_TEST flag
//        GL_DITHER flag
//        GL_FOG flag
// ///       GL_LIGHTi where 0 <= i < GL_MAX_LIGHTS
//        GL_LIGHTING flag
//        GL_LINE_SMOOTH flag
//        GL_LINE_STIPPLE flag
//        GL_COLOR_LOGIC_OP flag
//        GL_INDEX_LOGIC_OP flag
//        //GL_MAP1_x// where x is a map type
//        //GL_MAP2_x// where x is a map type
//        GL_MULTISAMPLE flag
//        GL_NORMALIZE flag
//        GL_POINT_SMOOTH flag
//        GL_POLYGON_OFFSET_LINE flag
//        GL_POLYGON_OFFSET_FILL flag
//        GL_POLYGON_OFFSET_POINT flag
//        GL_POLYGON_SMOOTH flag
//        GL_POLYGON_STIPPLE flag
//        GL_SAMPLE_ALPHA_TO_COVERAGE flag
//        GL_SAMPLE_ALPHA_TO_ONE flag
//        GL_SAMPLE_COVERAGE flag
//        GL_SCISSOR_TEST flag
//        GL_STENCIL_TEST flag
//        GL_TEXTURE_1D flag
//        GL_TEXTURE_2D flag
//        GL_TEXTURE_3D flag
//       /// Flags GL_TEXTURE_GEN_x where x is S, T, R, or Q
//       /// 	GL_MAP1_x enable bits, where x is a map type
//       /// GL_MAP2_x enable bits, where x is a map type
//        GL_AUTO_NORMAL enable bit
//
//        GL_FOG_MODE value
//        GL_POINT_SMOOTH_HINT setting
//        GL_LINE_SMOOTH_HINT setting
//        GL_POLYGON_SMOOTH_HINT setting
//        GL_FOG_HINT setting
//        GL_GENERATE_MIPMAP_HINT setting
//        GL_TEXTURE_COMPRESSION_HINT setting
//        GL_COLOR_MATERIAL_FACE value
//
//        GL_LIGHT_MODEL_LOCAL_VIEWER value
//        GL_LIGHT_MODEL_TWO_SIDE setting
//        GL_LIGHTING enable bit
//
//        GL_SHADE_MODEL setting
//        GL_LINE_STIPPLE enable bit
//
//        GL_SAMPLE_ALPHA_TO_COVERAGE flag
//        GL_SAMPLE_ALPHA_TO_ONE flag
//        GL_SAMPLE_COVERAGE flag
//        GL_SAMPLE_COVERAGE_VALUE value
//        GL_SAMPLE_COVERAGE_INVERT value
//        GL_GREEN_BIAS and GL_GREEN_SCALE values
//        GL_BLUE_BIAS and GL_BLUE_SCALE
//        GL_ALPHA_BIAS and GL_ALPHA_SCALE
//        GL_DEPTH_BIAS and GL_DEPTH_SCALE
//        GL_INDEX_OFFSET and GL_INDEX_SHIFT values
//        GL_MAP_COLOR and GL_MAP_STENCIL flags
//        GL_ZOOM_X and GL_ZOOM_Y factors
//        GL_READ_BUFFER setting
//
//        GL_CULL_FACE_MODE value
//        GL_FRONT_FACE indicator
//        GL_POLYGON_MODE setting
//        GL_POLYGON_SMOOTH flag
//        GL_POLYGON_STIPPLE enable bit
//        GL_POLYGON_OFFSET_FILL flag
//        GL_POLYGON_OFFSET_LINE flag
//        GL_POLYGON_OFFSET_POINT flag
//        GL_POLYGON_OFFSET_FACTOR
//        GL_POLYGON_OFFSET_UNITS
//        GL_STENCIL_TEST enable bit
//
//
//        GL_TEXTURE_GEN_MODE setting for S, T, R, and Q
//
//        GL_MATRIX_MODE value
//        GL_NORMALIZE flag
//        GL_RESCALE_NORMAL flag

//};



//glGetVertexAttrib returns in params the value of a generic vertex attribute parameter.The generic vertex attribute to be queried is specified by index, and the parameter to be queried is specified by pname.
//void glGetVertexAttribfv(GLuint index,    GLenum pname,    GLfloat *params);
//void glGetVertexAttribiv(GLuint index,    GLenum pname,    GLint *params);



// 
// The accepted parameter names are as follows :
// 
// GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING //  params returns a single value, the name of the buffer object currently bound to the binding point corresponding to generic vertex attribute array index.If no buffer object is bound, 0 is returned.The initial value is 0.
// GL_VERTEX_ATTRIB_ARRAY_ENABLED        //  params returns a single value that is non - zero(true) if the vertex attribute array for index is enabled and 0 (false) if it is disabled.The initial value is GL_FALSE.
// GL_VERTEX_ATTRIB_ARRAY_SIZE           //  params returns a single value, the size of the vertex attribute array for index.The size is the number of values for each element of the vertex attribute array, and it will be 1, 2, 3, or 4. The initial value is 4.
// GL_VERTEX_ATTRIB_ARRAY_STRIDE         //  params returns a single value, the array stride for (number of bytes between successive elements in) the vertex attribute array for index.A value of 0 indicates that the array elements are stored sequentially in memory.The initial value is 0.
// GL_VERTEX_ATTRIB_ARRAY_TYPE           //  params returns a single value, a symbolic constant indicating the array type for the vertex attribute array for index.Possible values are GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_FIXED, and GL_FLOAT.The initial value is GL_FLOAT.
// GL_VERTEX_ATTRIB_ARRAY_NORMALIZED     //  params returns a single value that is non - zero(true) if fixed - point data types for the vertex attribute array indicated by index are normalized when they are converted to floating point, and 0 (false) otherwise.The initial value is GL_FALSE.
// GL_CURRENT_VERTEX_ATTRIB              //  params returns four values that represent the current value for the generic vertex attribute specified by index.The initial value is(0, 0, 0, 1).

//All of the parameters except GL_CURRENT_VERTEX_ATTRIB represent client - side state.

            //pointer_Vertex.Bind();
            //pointer_Color.Bind();
           //  pointer_Vertex.Bind();
           //  pointer_Vertex.set_Data(3,Vertices.data());
           //  pointer_Color.Bind();
           //  pointer_Color.set_Data(4,Colors.data());





    /* Get the Viewport Dimensions and the Max view dimensions 
    {
        iVec2 r = OpenGL::get_MaximumViewportDimensions();
        Print("Max Viewport Dimensions: " << r.x << " : " << r.y);
        iVec4 vp = OpenGL::get_Viewport();
        Print("Viewport: " << vp.x << " : " << vp.y << " : " << vp.z << " : " << vp.w);
    }
*/




     //    TestRenderer->Main_Camera->RotateX(RADIANS(GLOBAL_Delta_Mouse.x));
     //   TestRenderer->Main_Camera->RotateZ(RADIANS(GLOBAL_Delta_Mouse.y));
     // TestRenderer->Main_Camera->Rotation.x += ((GLOBAL_Delta_Mouse.x));
     //TestRenderer->Main_Camera->Rotation.y += ((GLOBAL_Delta_Mouse.y));
     //  TestRenderer->Main_Camera->Rotate
     //  (
     //      (float)GLOBAL_Delta_Mouse.x, 
     //      (float)GLOBAL_Delta_Mouse.y
     //  );








 /*
 /
 //capture_previous_context(&GS_ContextRecord);
 //GS_ContextRecord.Rip = (ULONGLONG)_ReturnAddress();
 //GS_ContextRecord.Rsp = (ULONGLONG)_AddressOfReturnAddress() + 8;
 //GS_ExceptionRecord.ExceptionAddress = (PVOID)GS_ContextRecord.Rip;
 //GS_ContextRecord.Rcx = stack_cookie;
 //shader_TextureRenderer->Bind();
 //{
 //    OpenGL::bind_VAO(DebugQuadVAO);
 //    shader_TextureRenderer->SetUniform("Position", {1,1,100,100 });
 //    test_Texture->Bind(0);
 //    OpenGL::Renderer::drawArray(DebugQuadVBO, 6);
 //}
 //shader_TextureRenderer->Unbind();

         Organ *Test1[100];

         for (int i = 0; i < 100; ++i)
         {
             Test1[i] = new Organ(i);
         }

         for (int i = 0; i < 50; ++i)
         {
             delete(Test1[i]);
         }
         for (int i = 0; i < 50; ++i)
         {
             Test1[i] = new Organ(i);
         }
         for (int i = 0; i < 25; ++i)
         {
             delete(Test1[i]);
         }
         for (int i = 0; i < 25; ++i)
         {
             Test1[i] = new Organ(i);
         }

         size_t ElementTest{ 0 };
         for (auto& T : Organ::Pool)
         {// Cycle over ever Block in the Pool
             Print("Range ForLoop: " << T.Value);
             ++ElementTest;
         }
         assert(ElementTest   == Organ::Pool.chunkCount());
         assert(sizeof(Organ) == Organ::Pool.chunkSize());

         for (int i{ 0 }; i < Organ::Pool.size(); ++i)
         {// Cycle over every Byte in the Raw Data
             Print("Data[" << i << "] = " << (int)*Organ::Pool.get_Data(i));
         }

         Print("Pool Size" << Organ::Pool.size());

         Organ::Pool.clear();
         for (int i{ 0 }; i < Organ::Pool.size(); ++i)
         {
             Print("Data[" << i << "] = " << (int)*Organ::Pool.get_Data(i));
         }


         Print("Is It Full : " << Organ::Pool.is_Empty());
         assert(Organ::Pool.is_Full() == true);

         delete(Test1[1]);
         Print("Testing Delete to Free up Space... Is it Still Full : " << Organ::Pool.is_Full());
         assert(Organ::Pool.is_Full() == false);


         Print("Is It Empty : " << Organ::Pool.is_Full());
         assert(Organ::Pool.is_Empty() == false);

         Test1[1] = new Organ(1);
         Print("Allocating Again Is it Full Again: " << Organ::Pool.is_Full());
         assert(Organ::Pool.is_Full() == true);
 /

 */
 //int TestRecursion(int _param)
 //{
 //	_param--;
 //	Print("Recursion " << _param);
 //	if(_param > 0)
 //	{
 //       
 //            WARN_ME("This is Currently disabled due to Error cant convert _Ty' to 'int (__cdecl *const )(int &) ------ _Ty=int (__cdecl &)(int) ")
 //		//auto E = ThreadPool::get().Async(TestRecursion, (int)_param );
 //	//	E.get();
 //	}
 //	Print("Exit " << _param);
 //
 //	return 65;
 //}
 //

//static const char* fmt_table_int[3][4] =
//{
//    {   "%3d",   "%3d",   "%3d",   "%3d" }, // Short display
//    { "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA
//    { "H:%3d", "S:%3d", "V:%3d", "A:%3d" }  // Long display for HSVA
//};
//static const char* fmt_table_float[3][4] =
//{
//    {   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display
//    { "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
//    { "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA
//};
//
///* Blits the contents of the FrameBuffer with area of _srcRect onto the _destRect of this Surface */
//void blit_FrameBuffer(FrameBufferObject *_fbo, iVec4 _source, iVec4 _dest)
//{
//    CheckGLERROR();
//
//    glBindFramebuffer(GL_READ_FRAMEBUFFER, _fbo->GL_Handle);
//    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, Handle());
//
//    glBlitFramebuffer
//    (
//        _source.x, _source.y, _source.z, _source.w,
//        _dest.x, _dest.y, _dest.z, _dest.w,
//        GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT, GL_LINEAR
//    );
//    glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
//    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
//    CheckGLERROR();
//
//}

///* Blits the contents of _source with area of _srcRect onto the _destRect of this Surface */
//int blit_Surface(Surface *_source, iVec4 _srcRect, iVec4 _destRect)
//{
//    blit_FrameBuffer(_source->FBO, _srcRect, _destRect);
//}
//

///* Read a Rectangle of pixels from the Surface */
//void *read_Pixels(iVec4 _sourceRect, uint32_t _format = GL_RGBA, uint32_t _type = GL_UNSIGNED_SHORT_4_4_4_4) //format = GL_ALPHA, GL_RGB, and GL_RGBA. type = GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, or GL_UNSIGNED_SHORT_5_5_5_1.
//{/// NOTE: Should I lock this first
//    void *results = new int[_sourceRect.z * _sourceRect.w * sizeof(int)];
//    CheckGLERROR();
//    glBindFramebuffer(GL_READ_FRAMEBUFFER, FBO->GL_Handle);
//    glReadPixels(_sourceRect.x, _sourceRect.y, _sourceRect.z, _sourceRect.w, _format, _type, results);
//    glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
//    CheckGLERROR();
//    return results;
//}
//

// ImGui::InpitFloat("Scale", &A)     
// ImGui::InpitFloat("Scale", &A)
// Dragable Position Slider for the Camera 
// {
//    int val = 0, val2 = 100;
//    ImGui::DragFloatRange2("Range", &Camera_Position.x, &Camera_Position.y);
//    Application::getCamera().s_Position(Camera_Position);
//}
/// IF i UPDATE CAMERA HERE THE SLIDERS CAN MOVE THE CAMERA, IF I UPDATE AFTER THIS THE SLIDERS TRANSLATE IT BACK INTO PLACE EVERY FRAME NULLIFYING WHAT IS BEING DONE TO IT.
// Position Slider for the Camera 
//{                   //Application::getCamera().Update();
// ImGui::SliderFloat3("Position", Slide, -1000, 1000);
// Application::getCamera().Translate({ Slide[0], Slide[1] });
// Application::getCamera().s_Position({ Slide[0], Slide[1] });
// Application::getCamera().set_Zoom(Slide[2]);
//}
// { -(SCREEN_X / 2), -(SCREEN_Y / 2)}; 
// Application::getCamera().g_Position();

//void init_CPUmonitor() {
//    SYSTEM_INFO sysInfo;
//    FILETIME ftime, fsys, fuser;
//
//    GetSystemInfo(&sysInfo);
//    numProcessors = sysInfo.dwNumberOfProcessors;
//
//    GetSystemTimeAsFileTime(&ftime);
//    memcpy(&lastCPU, &ftime, sizeof(FILETIME));
//
//    self = GetCurrentProcess();
//    GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
//    memcpy(&lastSysCPU, &fsys, sizeof(FILETIME));
//    memcpy(&lastUserCPU, &fuser, sizeof(FILETIME));
//}
//double getCurrentValueCPU() {
//    FILETIME ftime, fsys, fuser;
//    ULARGE_INTEGER now, sys, user;
//    double percent;
//
//    GetSystemTimeAsFileTime(&ftime);
//    memcpy(&now, &ftime, sizeof(FILETIME));
//
//    GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
//    memcpy(&sys, &fsys, sizeof(FILETIME));
//    memcpy(&user, &fuser, sizeof(FILETIME));
//    percent = (sys.QuadPart - lastSysCPU.QuadPart) +
//        (user.QuadPart - lastUserCPU.QuadPart);
//    percent /= (now.QuadPart - lastCPU.QuadPart);
//    percent /= numProcessors;
//    lastCPU = now;
//    lastUserCPU = user;
//    lastSysCPU = sys;
//
//    return percent * 100;
//}
//
//
//
//
//int branchless_min(int a, int b)
//{// Interesting take... terrible perf
//    return a * (a < b) + b * (b <= a);// (a * 1) _ (b * 0);;
//}
//int branchless_max(int a, int b)
//{
//    return a * (a > b) + b * (b >= a);
//}
//
// CMAKE Pluggin
// https://marketplace.visualstudio.com/items?itemName=DaisukeAtaraxiA.VSslnToCMakePlugin
//#pragma optimize( "", off )
//CORONA VIRUS STUDY
//https://jamanetwork.com/journals/jama/fullarticle/2762130
//  OpenGL::make_Context_Current
//  (
//      Application::getWindow().g_DeviceContext(), 
//      Application::getWindow().g_Loading_Context()
//  );
//  what is shared are 
//      shaders, programs, textures, buffers, samplers, renderbuffers, sync objects.
//      FBO are shared only when created through EXT version of extension.
//      ARB version FBO are NOT shared. 
//      if you mix EXT and ARB version of FBO functions it can lead to undefined behavior.
//  OpenGL::make_Context_Current
//  (
//      Application::getWindow().g_DeviceContext(), 
//      Application::getWindow().g_GL_Context()
//  );
//  Bucket_Test->Submit
//  (
//      new Renderer_test::Geometry(new VertexBufferObject<Vec2>(Quad), new VertexBufferObject<Vec4>(Cols), new VertexBufferObject<Vec2>(UVcoord)),
//      MAT
//  );
// 
//  Bucket_Test->Submit
//  (
//      new Renderer_test::Geometry(new VertexBufferObject<Vec2>(Verts), new VertexBufferObject<Vec4>(Cols), new VertexBufferObject<Vec2>(UVcoord)),
//      MAT
//  );







/*

//#define GLM_FORCE_RADIANS       //Triggers Error telling us we need to use Macro GLM_ENABLE_EXPERIMENTAL in order to use Experimental GLM

#define GLM_ENABLE_EXPERIMENTAL 

#include "../../../../../Bin/glm/glm/glm.hpp"
#include "../../../../../Bin/glm/glm/gtx/rotate_vector.hpp"

class camera3d
{
public:
    camera3d() = default;
    camera3d
    (
        float posX, float posY, float PosZ,
        float dirX, float dirY, float dirZ
    );
    void Bind();

    void moveForward(float val);    // move along direction vector
    void moveBackward(float val);
    void moveRight(float val);      // move side to side
    void moveLeft(float val);
    void moveUp(float val);         // move along up vector
    void moveDown(float val);

    void rotateRight(float rad);    // rotaties about up vector
    void rotateLeft(float rad);
    void rotateUp(float rad);       // rotate about right/left vector
    void rotateDown(float rad);

    void rollRight(float rad);      // roll about direction vector
    void rollLeft(float rad);

    glm::vec3 position;
    glm::vec3 direction;
    glm::vec3 up;          // assume <0,1,0> on initialization

    Mat4 ProjectionMatrix; 

};

//#include "camera3d.h"
//#include <QDebug>




/*


// Camera is initialized with a position and direction
camera3d::camera3d
(
    float posX, float posY, float posZ,
    float dirX, float dirY, float dirZ
)
{
    position = glm::vec3(posX, posY, posZ);
    direction = glm::normalize(glm::vec3(dirX, dirY, dirZ));

    // find up direction
    glm::vec3 right = glm::cross(direction, glm::vec3(0.0, 1.0, 0.0));
    up = glm::normalize(glm::cross(right, direction));
    ProjectionMatrix = glm::perspective(glm::radians(90.0f), (float)SCREEN_X / (float)SCREEN_Y, 0.1f, 1000.0f);
}

void camera3d::moveForward(float val) {
    position = position + val * direction;
}

void camera3d::moveBackward(float val) {
    position = position - val * direction;
}

void camera3d::moveRight(float val) {
    glm::vec3 right = glm::cross(direction, up);
    position = position + val * right;
}

void camera3d::moveLeft(float val) {
    glm::vec3 left = -glm::cross(direction, up);
    position = position + val * left;
}

void camera3d::moveUp(float val) {
    position = position + val * up;
}

void camera3d::moveDown(float val) {
    position = position - val * up;
}

void camera3d::rotateRight(float rad) {
    direction = glm::rotate(direction, rad, -up);
}

void camera3d::rotateLeft(float rad) {
    direction = glm::rotate(direction, -rad, -up);
}

void camera3d::rotateUp(float rad) {
    glm::vec3 right = glm::cross(direction, up);
    up = glm::rotate(up, rad, right);
    direction = glm::rotate(direction, rad, right);
}

void camera3d::rotateDown(float rad) {
    glm::vec3 right = glm::cross(direction, up);
    up = glm::rotate(up, -rad, right);
    direction = glm::rotate(direction, -rad, right);
}

void camera3d::rollRight(float rad) {
    up = glm::rotate(up, rad, -direction);
}

void camera3d::rollLeft(float rad) {
    up = glm::rotate(up, -rad, -direction);
}

void  camera3d::Bind()
{

    Vec3 vz = glm::normalize(position - (position + direction));
    Vec3 vx = glm::normalize(glm::cross(up, vz));
    Vec3 vy = glm::cross(vz, vx);
    Mat4 ViewMatrix =
        Mat4
        (
            Vec4(vx, 0),
            Vec4(vy, 0),
            Vec4(vz, 0),
            Vec4(position, 1)
        );


    Shader::get().SetUniform("ViewMatrix", ViewMatrix );
    Shader::get().SetUniform("ProjectionMatrix", ProjectionMatrix);
}

// Position = position;
// Rotation = rotation;
//
// Forward = Vec3(0.0f, 0.0f, 1.0f);
// Right = Vec3(0.1f, 0.0f, 0.0f);
// Up = Vec3(0.0f, 1.0f, 0.0f);
//
// ProjectionMatrix = glm::perspective(glm::radians(FOV), AspectRatio, Near, Far);
// ViewMatrix = Mat4(1.0f);
// set(this);
// }
// ViewMatrix = glm::lookAt(Position, Position - Forward, Up);
//
//return results;
//    = Mat4
//(
//    Vec4(, , , ),
//    Vec4(, , , ),
//    Vec4(, , , ),
//    Vec4(, , , )
//);
 //  ProjectionMatrix = glm::perspective(glm::radians(FOV), AspectRatio, Near, Far);


  */
 */













 //	 	ProfilerTest->Update((uint32_t)(Time));
		/*   Make a Profiler Window which Displays the FPS as a graph */
        {/// THIS IS ALL FUCKED UP, Implement ImGUI with the Profiler ~EXTREMELY IMPORTANT~!
           /// 6/27 TRASH TRASH TRASH WHY ARE YOU STILL HERE? 
            float Aspect = getCamera().AspectRatio;
            float Size = 100;
            ProfilerTest = new Profiling::DisplayWindow
            (
                { SCREEN_X / 2  , SCREEN_Y / 2 },
                { std::floor((Size)* Aspect), std::floor((Size * 2)) },
                { std::floor(Size*.35 * Aspect), std::floor((Size)) }
            );
            ProfilerTest->Update(1);
        }


//    Mesh   *TestMesh{ nullptr };
//    Shader *TextureShader{ nullptr };
//    Texture *TestTexture{ nullptr };
//    Texture *TestTexture2{ nullptr };

 
   /* Load Test Textures to Test With using two different Texture Constructors */
       //{
       //    Graphics::Bitmap *Bmp = new Graphics::Bitmap("../Resources/Test.bmp");
       //    TestTexture = new Texture(*Bmp);
       //    TestTexture2 = new Texture("../Resources/Test2.bmp");
       //}
       //
       // TextureShader = new  Shader(VTextureRenderer, FTextureRenderer); ;

 


	//Vec2 Vertices[3] = { {200.0, 200.0 },  { 400.0, 200.0 },  { 0.0, 400.0 } };
	//Vec2 UVcoords[3] = { {  0.0,   0.0 },  {   1.0,   0.0 },  { 1.0,   1.0 } };
	//GLuint Indices[3] = { 0, 1, 2 };






        /* Create FBO to Test with */
       // {
       //     FBO = new FrameBufferObject(SCREEN_X, SCREEN_Y);
       // delete(FBO);
       // }



//    GLuint VAO{ 0 }, VBO{ 0 };
 //   VertexBufferObject<Vec2> *TestGeo;
 //   VertexBufferObject<Vec4> *TestColor;
 //   OpenGL::Geometry *GEOMETRY; 
 //std::vector<Vec2> Triangle_list =
//{
//    Vec2(-1),Vec2(-1),
//    Vec2(1),Vec2(-1),
//    Vec2(-1),Vec2(1),
//};
        /* Create a Triangle to Test with */
        //getWindow().defaultShader().Bind();
        //{
        //    VAO = OpenGL::new_VAO();
        //    OpenGL::bind_VAO(VAO);
        //
        //    VBO = OpenGL::new_VBO();
        //    OpenGL::bind_VBO(VBO);
        //    OpenGL::set_BufferData(sizeof(Vertices), &Vertices);
        //    OpenGL::set_Attribute(getWindow().defaultShader().g_Handle(), 2, "aPos");
        //}
      //       GEOMETRY = new OpenGL::Geometry(Verts,Cols);
      //TestColor = new VertexBufferObject<Vec4>(, );
      //TestGeo   = new VertexBufferObject<Vec2>();
      //test_RenderPass->set_Attributes
      //(
      //    new VertexBufferObject<Vec2>(Verts),
      //    new VertexBufferObject<Vec4>(Cols )
      //);
      // TestGeo->Update(Verts);
      // TestColor->Update(Cols);
      //GEOMETRY->Add(TestGeo);
      //GEOMETRY->Add(TestColor);
      //FBO->Unbind(); 
      //==> Renders the Frame Buffer Object we Rendered all the Images to
      // MainRenderer->renderImage({ 0, 0 }, { SCREEN_X, SCREEN_Y }, FBO->RenderTarget);
      // MainRenderer->renderImage({ 0, 0 }, { SCREEN_X, SCREEN_Y }, test_RenderPass->FBO->RenderTarget);
      // test_RenderPass->update_Geometry(SCENE.Vertices);
      // MainRenderer->Submit(*TextureShader, *TestTexture, *TestMesh);
      // TestECS->UpdateSystems(MainSystems, (float)(Time / 1000.0f));


 















//     Vec4 clear_color{ .1,.1,.1,1 };
//    RECT clientRect;
//         GetClientRect(getWindow().g_Handle(), &clientRect);
//         int windowWidth = clientRect.right - clientRect.left;
//         int windowHeight = clientRect.bottom - clientRect.top;
//         
//         
//    glViewport(0, 0, SCREEN_X, SCREEN_Y);
//    glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);
//    glClear(GL_COLOR_BUFFER_BIT);




//  HGLRC  backup = wglGetCurrentContext(); 
//  HDC DC_Backup = getWindow().g_DeviceContext();
//  ImGui::GetPlatformIO().Monitors.resize(0);
//  ::EnumDisplayMonitors(NULL, NULL, ImGui_ImplWin32_UpdateMonitors_EnumFunc, NULL);
//g_WantUpdateMonitors = false;

 /*
 static void ImGui_ImplDX9_CreateWindow(ImGuiViewport* viewport)
 {
     ImGuiViewportDataDx9* data = IM_NEW(ImGuiViewportDataDx9)();
     viewport->RendererUserData = data;

     // PlatformHandleRaw should always be a HWND, whereas PlatformHandle might be a higher-level handle (e.g. GLFWWindow*, SDL_Window*).
     // Some back-ends will leave PlatformHandleRaw NULL, in which case we assume PlatformHandle will contain the HWND.
     HWND hwnd = viewport->PlatformHandleRaw ? (HWND)viewport->PlatformHandleRaw : (HWND)viewport->PlatformHandle;
     IM_ASSERT(hwnd != 0);

     ZeroMemory(&data->d3dpp, sizeof(D3DPRESENT_PARAMETERS));
     data->d3dpp.Windowed = TRUE;
     data->d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
     data->d3dpp.BackBufferWidth = (UINT)viewport->Size.x;
     data->d3dpp.BackBufferHeight = (UINT)viewport->Size.y;
     data->d3dpp.BackBufferFormat = D3DFMT_UNKNOWN;
     data->d3dpp.hDeviceWindow = hwnd;
     data->d3dpp.EnableAutoDepthStencil = FALSE;
     data->d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
     data->d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;   // Present without vsync

     HRESULT hr = g_pd3dDevice->CreateAdditionalSwapChain(&data->d3dpp, &data->SwapChain); IM_UNUSED(hr);
     IM_ASSERT(hr == D3D_OK);
     IM_ASSERT(data->SwapChain != NULL);
 }
 */


 //   glViewport(0, 0, (int)GUI_io.DisplaySize.x, (int)GUI_io.DisplaySize.y);
//   glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);
//    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);





\imgui_internal.h(100):  note: see declaration of 'ImGuiDockNodeSettings'
\imgui.h(1432):          note: while compiling class template member function 'ImVector<ImGuiDockNodeSettings> &ImVector<ImGuiDockNodeSettings>::operator =(const ImVector<ImGuiDockNodeSettings> &)'
\imgui.h(1431):          note: see reference to function template instantiation 'ImVector<ImGuiDockNodeSettings> &ImVector<ImGuiDockNodeSettings>::operator =(const ImVector<ImGuiDockNodeSettings> &)' being compiled
\imgui_internal.h(1172): note: see reference to class template instantiation 'ImVector<ImGuiDockNodeSettings>' being compiled


















void Application::Init()
{
    IMGUI_CHECKVERSION();
    ImGUI_Context =  ImGui::CreateContext();
    ImGuiIO&  GUI_io = ImGui::GetIO(); (void)GUI_io;
    
    GUI_io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;       // Enable Keyboard Controls
    GUI_io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;           // Enable Docking
    GUI_io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;         // Enable Multi-Viewport / Platform Windows
    
    ImGui_ImplWin32_Init(Application::getWindow().g_Handle());
    ImGui_ImplOpenGL3_Init("#version 130");
}

void Application::Render()
{ 
    ImGuiIO&  GUI_io = ImGui::GetIO();
     
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplWin32_NewFrame();
    ImGui::NewFrame();
    {
            ImGui::ShowDemoWindow();   //OnRenderGUI();
    }
    ImGui::EndFrame();

    ImGui::Render();

    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());


    /*=========================================================================
        Have tried with and without this Context backup, no luck either way.
      ========================================================================= */


    if (GUI_io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        HGLRC  backup = wglGetCurrentContext(); 
        HDC DC_Backup = getWindow().g_DeviceContext();// Apps main Windows HDC

        ImGui::UpdatePlatformWindows();
        ImGui::RenderPlatformWindowsDefault();
        wglMakeCurrent(DC_Backup, backup);
    }

   SwapBuffers(DeviceContext); 
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}


void Application::OnRenderGUI()
{
    ImGui::ShowDemoWindow();
    
    static float Slide[3] = { 0,0,-300 };
    
    /* Start the Camera Widget */
    ImGui::Begin("Camera");
    {
        Vec2 Camera_Position = WorldCamera->g_Position();
    
        /* Position Slider for the Camera */
        {
            ImGui::SliderFloat3("Position", Slide, -1000, 1000);
            WorldCamera->Translate({ Slide[0], Slide[1] });
            WorldCamera->set_Zoom(Slide[2]);
        }
    
        /* Position Slider for the Camera */
        {
            ImGui::InputFloat("X", &Camera_Position.x, 10.0f, 1.0f, "%.3f");
            ImGui::InputFloat("Y", &Camera_Position.y, 10.0f, 1.0f, "%.3f");
            WorldCamera->s_Position(Camera_Position);
        }
    
        /* Clickable Position Slider for the Camera */
        {
            float
                H = (float) WorldCamera->Height(), 
                W = (float) WorldCamera->Width();
            ImGui::InputFloat("Width", &W, 10.0f, 1.0f, "%.3f");
            ImGui::InputFloat("Height", &H, 10.0f, 1.0f, "%.3f");
            WorldCamera->Size = { W,H };
        }
        /* Dragable Position Slider for the Camera */
        {
            int val = 0, val2 = 100;
            ImGui::DragFloatRange2("Range", &Camera_Position.x, &Camera_Position.y);
            WorldCamera->s_Position(Camera_Position);
        }
    
        /* Color Picker Widget for the Background Color */
        {
            Vec4 c = getWindow().g_ClearColor();
            float Col[3] = { c.x,c.y,c.z };
            ImGui::ColorPicker3("Background Color", Col, 0);
            glClearColor(Col[0], Col[1], Col[2], 1);
            getWindow().s_ClearColor({ Col[0], Col[1], Col[2], 1 });
        }
    
        static float Top_Time = 0;
        if (FrameTimes.back() > Top_Time)
        {
            Top_Time = FrameTimes.back();
        }
        ImGui::PlotLines("Frame Times", (float*)&FrameTimes.front(), FrameTimes.size(), 0, std::string("FPS:" + std::to_string((uint32_t)FrameTimes.back())).c_str(), 0, Top_Time, ImVec2(ImGui::GetWindowWidth(), 50));
    
    }
    ImGui::End();
    
    /* Displays the FrameBuffers */
    ImGui::Begin("FrameBuffers");
    {
        /* Displays the FrameBuffer */
        float WinSize = (float)(ImGui::GetWindowHeight() - (ImGui::GetWindowHeight() * 0.15));
        ImGui::Image(reinterpret_cast<ImTextureID*>((size_t)FBO->RenderTarget->g_Handle()), ImVec2(WinSize, WinSize));
        ImGui::SameLine();
        ImGui::Image(reinterpret_cast<ImTextureID*>((size_t)FBO->DepthTarget->g_Handle()), ImVec2(WinSize, WinSize));
        ImGui::SameLine();
    
        ImGui::Image(reinterpret_cast<ImTextureID*>((size_t)test_RenderPass->FBO->RenderTarget->g_Handle()), ImVec2(WinSize, WinSize));
        ImGui::SameLine();
        ImGui::Image(reinterpret_cast<ImTextureID*>((size_t)test_RenderPass->FBO->DepthTarget->g_Handle()) , ImVec2(WinSize, WinSize));
        ImGui::SameLine();
    
    
        char *Buff = const_cast<char*>(OpenGL_ErrorList.c_str());
        ImGui::InputTextMultiline("OpenGL Errors",Buff, OpenGL_ErrorList.size());
    }
    ImGui::End();
} 























              /// This needs to go
            std::string VRenderer =
                "#version 330 core                                       \n\
                layout(location = 0) in vec2 Position;             \n\
                layout(location = 1) in vec4 VColor;                \n\
                uniform mat4 ProjectionMatrix;                           \n\
                uniform mat4 ViewMatrix;                                 \n\
                out vec4 Col;                                            \n\
                void main()                                              \n\
                {                                                        \n\
                    Col = VColor;                                   \n\
                    mat4 ModelViewMatrix = (ViewMatrix * mat4(1.0));     \n\
                    mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);\n\
                    gl_Position = ModelViewProjectionMatrix * vec4( Position.x, Position.y, -1.0, 1.0); \n\
                }";
          
            std::string FRenderer =
                "#version 330 core    \n\
                in vec4 Col;          \n\
                out vec4 FragColor;   \n\
                void main()           \n\
                {                     \n\
                    FragColor = Col;  \n\
                }";
          
            /// NOTE: I BELIEVE DEFAULT SHADER IS BROKE
           // test_RenderPass = new OpenGL::RenderPass(SCREEN_X, SCREEN_Y, new Shader(VRenderer, FRenderer)); //&MainRenderer->new_RenderPass(SCREEN_X, SCREEN_Y, MainRenderer->InstanceRenderer);
           // test_RenderPass->attach(GEOMETRY);


float Plot_Getter(void* data, int idx)
{
//    ImGui::ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
    const float v = 0;// (float)data[idx]; //*(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);
    return v;
}


        //Vertices_VBO->Bind();
        //OpenGL::set_Attribute(RENDERER->g_Handle(), sizeof(Vec2) / sizeof(float), "Position");
        //Colors_VBO->Bind();
        //OpenGL::set_Attribute(RENDERER->g_Handle(), 4, "VColor");
       //
        //glBindVertexArray(0);
        // glBindBuffer(GL_ARRAY_BUFFER, 0);
        /* Setup the Shader so that our Locations are Linked */
        // {
         // RENDERER->Bind();
         // { 
         //     Vertices_VAO->Bind();
         // 
         //     Vertices_VBO->Update(Vertices);
         //     OpenGL::set_Attribute(RENDERER->g_Handle(), sizeof(Vec_t) / sizeof(float), "Position");
         //     Colors_VBO->Update(Colors);
         //     OpenGL::set_Attribute(RENDERER->g_Handle(), 4, "VColor");
         // 
         // 
         //     //Vertices_VAO->Attach(BufferTypes::VERTEX, Vertices_VBO);
         //     //Vertices_VAO->Attach(BufferTypes::COLOR,  Colors_VBO);
         // } 
         // RENDERER->Unbind();
//m_program->bind();
//{
//    m_object.bind();
//    glDrawArrays(GL_TRIANGLES, 0, sizeof(sg_vertexes) / sizeof(sg_vertexes[0]));
//    m_object.release();
//}
//m_program->release();
//
//
//Vertices_VBO->Update(Vertices);
//OpenGL::set_Attribute(RENDERER->g_Handle(), sizeof(Vec_t) / sizeof(float), "Position");
//Colors_VBO->Update(Colors);
//OpenGL::set_Attribute(RENDERER->g_Handle(), 4, "VColor");
       // }



    // GLuint VAO{ 0 }, VBO{ 0 }, COL{ 0 };
        // VAO = OpenGL::new_VAO();  // new VertexArrayObject();
// VBO = OpenGL::new_VBO();  // Vertices_VBO = new VertexBufferObject<Vec_t>();
// COL = OpenGL::new_VBO();

        //OpenGL::bind_VAO(VAO);
        //{
        //    OpenGL::bind_VBO(VBO);
        //    OpenGL::set_BufferData(Vertices);
        //    OpenGL::set_Attribute(RENDERER->g_Handle(), sizeof(Vec_t) / sizeof(float), "Position");
        //
        //    OpenGL::bind_VBO(COL);
        //    OpenGL::set_BufferData(Colors);
        //    OpenGL::set_Attribute(RENDERER->g_Handle(), 4, "Color");
        //}

     //   Vertices_VBO->Update(Vertices);
     //   VBO = OpenGL::new_VBO();
     //   OpenGL::bind_VBO(VBO);
     //   OpenGL::set_BufferData(sizeof(Vertices), &Vertices);
     //   OpenGL::set_Attribute(getWindow().defaultShader().g_Handle(), 2, "aPos");
     //   Vertices[i].z + RANDOM_RANGE(Amount),
     //   Vertices[i].w + RANDOM_RANGE(Amount)
     //   OpenGL::bind_VBO(VBO);
     //   OpenGL::set_BufferData(Vertices);
     // OpenGL::bind_VAO(VAO);
     // OpenGL::Renderer::drawArray( VBO, Vertices.size() );




//_wassert(_CRT_WIDE(#_msg), _CRT_WIDE(__FILE__), (unsigned)(__LINE__)) , 0));

/// ====================================================================================================================================

//  #define CREATURE_ASSERT(_expression, _msg) (void) ((!!(_expression)) _OR_ \
//  (int)(\
//  []()->bool {DEBUGPrint(\
//  CON_Red,\
//  "\n ~ERROR~: " << _CRT_WIDE(#_msg)\
//  << "\n FILE: " <<  _CRT_WIDE(__FILE__)\
//  << "\n LINE: " << (unsigned)(__LINE__)\
//  ); return 1;}\
//  )\            //std::cerr 

//  );
/* If !(condition) it means Assertion Failed and displays */
/* Colored Debug Console Printer                          */
 /* Expression to Evaluate                                 */
 /* FILE NAME                                              */
 /* LINE NUMBER                                            */
 /* ERROR MESSAGE                                          */
 /* Only Terminate if Terminate On Error Flag is Set       */
 /*  If it reaches here the Expression PASSED: */
 /*  Likely will replace this with a Scoped Static Bool    */
/*  It will prevent it from rapidly repeating in Loops    */
 /*  Expression to Evaluate                                */
 /*  FILE NAME                                             */
 /*  LINE NUMBER                                           */
 /*  SUCCESS MESSAGE                                       */
#ifndef NDEBUG
#   define ASSERT(condition, message) \
    do { \
        if (!(condition)) {\
DEBUGPrint(CON_Red,  "\n Assertion: `" << #condition << "\n File: " << __FILE__ \
<< "\n Line: " << __LINE__ << "\n Msg: " << message );\
            std::terminate(); \
        } \
    } while (false)
#else
#   define ASSERT(condition, message) do { } while (false)
#endif

/// ====================================================================================================================================

#define CREATURE_ASSERT(condition, message) do { \
if (!(condition)) { DEBUGPrint(CON_Red,(message)); } \
assert ((condition)); } while(false)



/// ====================================================================================================================================
#ifdef NDEBUG
constexpr std::uint_least64_t debug_mode = 0;
#else
constexpr std::uint_least64_t debug_mode = 1;
#endif

template< typename... Args >
void print_assertion(std::ostream& out, Args&&... args)
{
    out.precision(20);
    if constexpr (debug_mode)
    {
        (out << ... << args) << std::endl;
        abort();
    }
}
#ifdef better_assert
#undef better_assert
#endif
#define better_assert(EXPRESSION, ... ) ((EXPRESSION) ? (void)0 : print_assertion(std::cerr, "Assertion failure: ",  #EXPRESSION, " in File: ", __FILE__, " in Line: ",  __LINE__ __VA_OPT__(,) __VA_ARGS__))
/// ====================================================================================================================================





// ============================================================================================================================================================================
//                                 3/4/2020
//          Clean up  #Main.cpp
// ============================================================================================================================================================================


//glVertexAttribPointer(
//	0,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.
//	3,                  // size
//	GL_FLOAT,           // type
//	GL_FALSE,           // normalized?
//	0,                  // stride
//	(void*)0            // array buffer offset
//);
//1265 681   1280 720 = (15,39)
//  _width += 15;
//   _height += 39;


/*
PFNGLVIEWPORTPROC glad_glViewport = NULL;
PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv = NULL;
PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf = NULL;
PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv = NULL;
glad_glViewportPositionWScaleNV
*/

//glGenVertexArrays(1, &VAO);
// glBindVertexArray(VAO);
//  glBindBuffer(GL_ARRAY_BUFFER, VBO);
//  glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), &Vertices, GL_STATIC_DRAW);
  //glBindBuffer(GL_ARRAY_BUFFER, VBO);
 // GLuint Location = 4;
   //Location = glGetAttribLocation(getWindow().defaultShader().g_ID(), "aPos");
  //glEnableVertexAttribArray(Location);
  //glVertexAttribPointer(Location, 2, GL_FLOAT, GL_FALSE, 0, (char *)NULL);


    Vec2 ProfilerVerts[4] =
    {
        {-1.0,-1.0 },
        { 1.0,-1.0 },
        { 0.0, 1.0 },
        { 1.0, 1.0 }
    };

    Vec2 ProfilerUV[4] =
    {
        { 0.0, 0.0 },
        { 1.0, 0.0 },
        { 1.0, 1.0 },
        { 0.0, 1.0 }
    };

    GLuint ProfilerIndices[3] =
    {
        0,1,2,
    };
*/


//	glBindBuffer(GL_ARRAY_BUFFER, VBO);
//	{
        //glDrawArrays(GL_TRIANGLES, 0, 3);
//	}
//	glBindBuffer(GL_ARRAY_BUFFER, 0);
        //for_loop(y, 100)
        //{
        //	for_loop(x, 100)
        //	{
        //		float
        //			Px = x * 21,
        //			Py = y * 21;
        //		MainRenderer->renderQuad(Vec2(Px, Py), Vec2(20, 20));
        //	}
        //}
/*

        Vec2 _size = Vec2(8, 8);
        Vec2 Space = Vec2(1, 1);
        Vec2 Count = Vec2(80, 60);

 for_loop(y, Count.y)
 {
     for_loop(x, Count.x)
     {
         Vec2 _topleft
         (
             x * (_size.x + Space.x),
             y * (_size.y + Space.y)
         );
 
         TestBatch.push_back(Vec2(_topleft.x, _topleft.y));
         TestBatch.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
         TestBatch.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
         TestBatch.push_back(Vec2(_topleft.x + _size.x, _topleft.y + _size.y));
         TestBatch.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
         TestBatch.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
     }
 }
 MainRenderer->SetRenderColor(0, 255, 255, 255);
 for_loop(y, Count.y)
 {
     for_loop(x, Count.x)
     {
         Vec2 _topleft
         (
             x * (_size.x + Space.x),
             (y + Count.y) * (_size.y + Space.y)
         );
 
         TestBatch2.push_back(Vec2(_topleft.x, _topleft.y));
         TestBatch2.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
         TestBatch2.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
         TestBatch2.push_back(Vec2(_topleft.x + _size.x, _topleft.y + _size.y));
         TestBatch2.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
         TestBatch2.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
     }
 }
 
*/
// ============================================================================================================================================================================
//                                 3/3/2020
//          Clean up  #Texture.cpp
// ============================================================================================================================================================================

/*   
layout(location = 0) in vec2 aPos; 
uniform vec4 Position; 
uniform mat4 ProjectionMatrix;     
uniform mat4 ViewMatrix;           
void main()                        
{                                  
    mat4 ModelViewMatrix = (ViewMatrix * mat4(1.0));  
    mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);
    gl_Position = ModelViewProjectionMatrix * vec4( (aPos.x * Position.z) + Position.x, (aPos.y * Position.w) +  Position.y, -1.0, 1.0); 
}

#version 330 core             
out vec4 FragColor;            
void main()                    
{                              
    FragColor = vec4(1,1,1,1); 
}

*/

/*



for(auto& S: Shaders)
        {
            for(auto& T: Textures)
            { }
        }
    enum  Surface_t { Normals, Albedo, Metallic };

    using SurfaceFragment = std::pair<Surface_t, Texture_ID_t>;
    using Surface = std::vector<SurfaceFragment>;
    using Material = std::pair<Surface, Shader_ID_t>;
    using RenderPair = std::pair<Material, Mesh_ID_t>;

    std::vector<Shader*> Shaders;
    std::vector<Texture*> Textures;
    std::vector<Mesh*> Meshes;
*/




	// Simple move assignment operator
 //VertexArrayObject& operator=(VertexArrayObject&& other)
 //{
 //   // *this = 
 //    return *std::move(other);//
 //}
/*
#ifdef BINDLESS_ATTRIBUTES
void Bind() {}
void Unbind() {}

template<typename T>
void Attach(BufferTypes bufferT, VertexBufferObject<T>* buffer)
{
	if (GL_Handle == NULL)
	{
		glGenVertexArrays(1, &GL_Handle);
	}
	Bind();
	GLint Amount = sizeof(T) / sizeof(float);
	Buffers.push_back(buffer);

	switch (bufferT)
	{
	case INDICE:
		buffer->AttributeType = INDICE;
		return;
		break;
	case VERTEX:
		buffer->AttributeType = VERTEX;
		break;
	case COLOR:
		buffer->AttributeType = COLOR;
		break;
	case NORMAL:
		buffer->AttributeType = NORMAL;
		break;
	case UVCOORD:
		buffer->AttributeType = UVCOORD;
		break;
	case TANGENT:
		buffer->AttributeType = TANGENT;
		break;
	}
}
#else
//#endif

 */



/*

    glTexImage2D(
        Target, 0,
        _internalFormat,
        _size.x, _size.y,
        Border,
        _dataFormat,
        _type, (void*)NULL);

    Texture(Vec2 _size,
        int32_t _dataFormat = GL_RGBA,
        int32_t _internalFormat = GL_RGBA,
        uint32_t _wrap = GL_CLAMP_TO_EDGE,
        uint32_t _filtering = GL_NEAREST,
        uint32_t _type = GL_FLOAT);

 //   glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24, 1024, 768, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
 
 */



 //GLuint TextureID;
 //GLuint DepthTexture;
 //GLenum InternalFormat;
 //GLenum PixelFormat;
 //GLenum DataType;

//_static uint32_t Texture::debugVAO;
//_static uint32_t Texture::debugVBO;
//_static Shader* Texture::debugShader;
//_static Camera2D Texture::debugCamera;
//_static Vec2 QuadData[6] =
//{
//    Vec2(0, 0),  Vec2(1, 0),  Vec2(0, 1),
//    Vec2(1, 1),  Vec2(0, 1),  Vec2(1, 0)
//};
//_static void Texture::InitDebug()
//{
//    debugCamera = Camera2D(1280, 740);
//    debugShader = new Shader(VdebugRenderer, FdebugRenderer);
//
//    debugVAO = OpenGL::new_VAO();
//    debugVBO = OpenGL::new_VBO();
//
//    debugShader->Bind();
//    {
//        OpenGL::bind_VAO(debugVAO);
//        OpenGL::bind_VBO(debugVBO);
//        OpenGL::set_Attribute(2, "aPos");
//    }
//    debugShader->Unbind();
//}
// void Texture::Render(int _x, int _y, int _w, int _h)
// {
// 
//     Mat4 Transform = glm::mat4(1.0f); //  Set Identity and Rotate all axis followed with the Translation.
//     Transform = glm::translate(Transform, Vec3(_x, _y, 0));
//     Transform = glm::rotate(Transform, glm::radians(0.f), Vec3(1.0f, 0.0f, 0.0f));
//     Transform = glm::rotate(Transform, glm::radians(0.f), Vec3(0.0f, 1.0f, 0.0f));
//     Transform = glm::rotate(Transform, glm::radians(0.f), Vec3(0.0f, 0.0f, 1.0f));
// 
//     ///Shader::GetActiveShader()->SetUniform("ProjectionMatrix", OrthographicMatrix(640, 480));
//     ///Shader::GetActiveShader()->SetUniform("ViewMatrix", Mat4(1));
//     ///Shader::GetActiveShader()->SetUniform("ModelMatrix", Transform);
// 
//     ///Plane temp(Vec3(0), Vec3(0), (float)_w, (float)_h);
//     ///Shader::GetActiveShader()->SetTextureUniform("DiffuseTexture", this);
//     ///temp.Render(*Shader::GetActiveShader());
// 
//     debugShader->Bind();
//     {
//         OpenGL::bind_VAO(debugVAO);
//         debugCamera.Bind();
//         debugShader->SetUniform("Position", Vec4(_x, _y, _w, _h));
// 
//         glBindBuffer(GL_ARRAY_BUFFER, debugVBO);
//         glDrawArrays(GL_TRIANGLES, 0, 6);
//     }
//     debugShader->Unbind();
// }
//
//    _static std::string Texture::VdebugRenderer =
//        "#version 330 core         \n\
//layout(location = 0) in vec2 aPos; \n\
//uniform vec4 Position;             \n\
//uniform mat4 ProjectionMatrix;     \n\
//uniform mat4 ViewMatrix;           \n\
//out vec2 TexCoords;                \n\
//void main()                        \n\
//{                                  \n\
//    TexCoords = aPos.xy;           \n\
//    mat4 ModelViewMatrix = (ViewMatrix * mat4(1.0));  \n\
//    mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);\n\
//    gl_Position = ModelViewProjectionMatrix * vec4( (aPos.x * Position.z) + Position.x, (aPos.y * Position.w) +  Position.y, -1.0, 1.0); \n\
//}";
//
//    _static std::string Texture::FdebugRenderer =
//        "#version 330 core \n\
//uniform sampler2D DebugText;   \n\
//in vec4 Col;                   \n\
//in vec2 TexCoords;             \n\
//out vec4 FragColor;            \n\
//void main()                    \n\
//{                              \n\
//    vec4 Samp = texture2D(DebugText, TexCoords); \n\
//    FragColor = Samp;   \n\
//}";
//
//  //texture2D(sampler2D(DiffuseTexture), TexCoords.xy); 
//Vec2 TexCoords[6] =
//{
//    Vec2(0.0f, 1.0f), Vec2(0.0f, 0.0f),        Vec2(1.0f, 0.0f),
//    Vec2(0.0f, 1.0f), Vec2(1.0f, 0.0f),        Vec2(1.0f, 1.0f)
//};
 //====================== DEBUG STUFF ==============================================================
 //================================================================================================
 //static std::string VdebugRenderer;
 //static std::string FdebugRenderer;
 //static uint32_t debugVAO;
 //static uint32_t debugVBO;
 //static Shader* debugShader;
 //static Camera2D debugCamera; 
 //
 //static Vec2 QuadData[6];
 //static Vec2 TexCoords[6];
 // public:
 //static void InitDebug();
     //  InternalFormat = GL_RGBA;// GL_RGBA;GL_RED;// 
       // Format = GL_RGBA;// _INTEGER;// GL_RGBA_INTEGER; GL_RED;//
    //  
    //  bool Texture::Load()
    //  {
    //  	Bind();
    //  
    //  	SetMinFiltering(GL_LINEAR_MIPMAP_LINEAR);  // Texture Layout when sampling past texture
    //  	SetMagFiltering(GL_LINEAR);
    //  
    //  	SetWrap(GL_REPEAT); // Texture Layout when sampling past texture
    //  
    //  
    //  	if (Picture->Channels == 4)
    //  	{
    //  		Format = GL_RGBA;
    //  		InternalFormat = GL_RGBA;
    //  	}
    //  	else if (Picture->Channels == 3)
    //  	{
    //  		Format = GL_RGB;
    //  		InternalFormat = GL_RGB;
    //  	}
    //  	_GL(glTexImage2D(Target, 0, InternalFormat, Picture->Size.x, Picture->Size.y, 0, Format, GL_UNSIGNED_BYTE, Picture->Data)); // 	_GL(glTexImage2D(Target, 0, GL_RGB, Picture.Size.x, Picture.Size.y, 0, GL_RGB, GL_UNSIGNED_BYTE, Picture.Data));
    //  	glGenerateMipmap(Target);
    //  	Handle = glGetTextureHandleARB(TextureID);
    //  	glMakeTextureHandleResidentARB(Handle);
    //  
    //  	Unbind();
    //  	return true;
    //  }
    //  
    //Target
///     Texture::Texture(Bitmap& image, int _x, int _y, int _width, int _height)
///     {// Generate a Texture from a Sub image 
///     	Picture = new Bitmap();
///     	///*Picture = Bitmap::FlippedImage(image);
///     
///     	glGenTextures(1, &GL_Handle);
///     	Bind();
///     
///     	SetMinFiltering(GL_LINEAR_MIPMAP_LINEAR);  // Texture Layout when sampling past texture
///     	SetMagFiltering(GL_LINEAR);
///     	SetWrap(GL_REPEAT); // Texture Layout when sampling past texture
///     
///     	size_t Stride = Picture->Channels();
///     	size_t SrcByteHeight = Picture->Height() * Stride;
///     	size_t SrcByteWidth = Picture->Width() * Stride;
///     
///     	size_t DestByteHeight = _height * Stride;
///     	size_t DestByteWidth = _width * Stride;
///     
///     	size_t RowSize = DestByteWidth;
///     
///     	size_t DestIndex = 0, SourceIndex = 0;// (_x * Stride);
///     
///     	unsigned char* TempImage = new unsigned char[DestByteHeight * DestByteWidth];
///     	size_t Buffered = 0;
///     	if (DestByteWidth + (_x * Stride) > SrcByteWidth)
///     	{
///     		RowSize -= (_x * Stride);
///     		DestByteWidth -= (_x * Stride);
///     		Buffered = (_x * Stride);
///     	}
///     
///     	int Counter = 0;
///     	for (int py = 0; py < _height; ++py)
///     	{
///     		unsigned char* Src = &Picture->Data[SourceIndex];
///     		unsigned char* Dest = &TempImage[DestIndex];
///     
///     		memcpy(Dest, Src, RowSize);
///     
///     		SourceIndex += SrcByteWidth;
///     		DestIndex += DestByteWidth;
///     
///     		Counter++;
///     	}
///     	Picture->Data = TempImage;
///     
///     
///     	*Picture = Bitmap::FlippedImage(*Picture);
///     
///     	if (Picture->Channels() == 4)
///     	{
///     		Format = GL_RGBA;
///     		InternalFormat = GL_RGBA;
///     	}
///     	else if (Picture->Channels() == 3)
///     	{
///     		Format = GL_RGB;
///     		InternalFormat = GL_RGB;
///     	}
///     
///     
///     	glTexImage2D(Target, 0, InternalFormat, (Picture->Width()), Picture->Height(), 0, Format, GL_UNSIGNED_BYTE, Picture->Data()); // 	_GL(glTexImage2D(Target, 0, GL_RGB, Picture.Size.x, Picture.Size.y, 0, GL_RGB, GL_UNSIGNED_BYTE, Picture.Data));
///     	glGenerateMipmap(Target);
///     
///     	Handle = glGetTextureHandleARB(GL_Handle);
///     	glMakeTextureHandleResidentARB(Handle);
///     	delete (TempImage);
///     	Unbind();
///     }

// ============================================================================================================================================================================
//                                 2/20/2020
//          Clean up  
// ============================================================================================================================================================================




        /* QuadRenderer->Bind();
        {
            Shader::get().SetUniform("ModelMatrix", Mat4(1.0f));
            mainCamera.Bind();
           // Renderer::drawArray(QuadVBO, QuadData.size());
            Renderer::drawArrayInstanced(QuadVBO, 6, 1000);

            DEBUG_CODE(CheckGLERROR());
        }
        QuadRenderer->Unbind();*/
//	void renderLine(Vec2 _start, Vec2 _end);
//void renderLineBatch(const std::vector<Vec2> _batch);
//vec4(1.0, 1.0, 1.0, 1.0); vec4(1.0, 1.0, 1.0, 1.0) + Col; 
// 		std::string VquadRenderer =
// 			"#version 330 core     \n\
// layout(location = 0) in vec2 aPos; \n\
// layout(location = 1) in vec4 Color;\n\
// uniform mat4 ProjectionMatrix;     \n\
// uniform mat4 ViewMatrix;           \n\
// uniform mat4 ModelMatrix;          \n\
// out vec4 Col;                      \n\
// void main()                        \n\
// {                                  \n\
//     Col = Color;                   \n\
//     mat4 ModelViewMatrix = (ViewMatrix * ModelMatrix);  \n\
//     mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);\n\
//     gl_Position = ModelViewProjectionMatrix * vec4(aPos.x, aPos.y, -1.0, 1.0); \n\
// }";
//
// 		std::string FquadRenderer =
// 			"#version 330 core \n\
// out vec4 FragColor;            \n\
// in vec4  Col;            \n\
// void main()                    \n\
// {                              \n\
//     FragColor = Col;\n\
// }";
//
////gl_Position = (ProjectionMatrix * (ViewMatrix * ModelMatrix)) * vec4(aPos.x, aPos.y, -1.0, 1.0); \n\
//
//        // QuadRenderer = new Shader(VquadRenderer, FquadRenderer);
//        // Shader* QuadRenderer;
//
//std::vector<FrameBufferObject> RenderTargets;
//std::vector<Shader> Programs;
////std::vector<VertexArrayObject> VAOs;
////std::vector<VertexBufferObject<Vec3>> VBOs;
//std::vector<Mesh> Meshes;
//
//VertexData.push_back(Vec2(Position.x - Offset.x, Position.y + Offset.y));
//VertexData.push_back(Vec2(Position.x - Offset.x, Position.y - Offset.y));
//VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
//VertexData.push_back(Vec2(Position.x - Offset.x, Position.y + Offset.y));
//VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
//VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
//
//Vec2 Position = Vec2(0);
//Vec4 Vertices[6] =
//{   // positions   // texCoords
//	Vec4(0 ,         Size.y   ,    0.0f,  1.0f),
//	Vec4(0 ,        -Size.y   ,    0.0f,  0.0f),
//	Vec4(Size.x ,  -Size.y   ,    1.0f,  0.0f),
//	Vec4(0 ,         Size.y   ,    0.0f,  1.0f),
//	Vec4(Size.x ,  -Size.y   ,    1.0f,  0.0f),
//	Vec4(Size.x ,   Size.y   ,    1.0f,  1.0f)
//};
//glGenBuffers(1, &VBO);
//glBindBuffer(GL_ARRAY_BUFFER, VBO);
//glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), &Vertices, GL_STATIC_DRAW);
//VAO->Attach(VERTEX, new VertexBufferObject<Vec2>(&newVertices[0], 6));
//VAO->Attach(UVCOORD, new VertexBufferObject<Vec2>(&TexCoords[0], 6));
////Program = new Shader("Resources\\DebugQuad.sfx");
//
//Vec2 Vertices[6];
//Vec2 TexCoords[6] =
//{
//    Vec2(0.0f, 1.0f),
//    Vec2(0.0f, 0.0f),
//    Vec2(1.0f, 0.0f),
//    Vec2(0.0f, 1.0f),
//    Vec2(1.0f, 0.0f),
//    Vec2(1.0f, 1.0f)
//};
//VA.Bind();
//for(auto& VB: VBOs)
//{ }
//for (auto& FB : RenderTargets)
//{
//    FB.Bind();
//    for (auto& S: Programs)
//    {
//        S.Enable();
//        for (auto& VA : VAOs)
//        {
//            VA.Bind();
//            /*
//            for(auto& VB: VA.Buffers)
//            {
//                VB->Bind();
//            }
//            for(auto& M: Meshes)
//            {
//                M.Bind();
//            }*/
//            Renderer::drawArray(QuadVBO, VertexData.size() * 0.5f);
//        }
//    }
//}
///     struct RenderPass
///     {
///     	void Submit(Mesh& _mesh, Texture& _tex)
///     	{
///           //  SurfaceMap[_tex.g_Handle()].push_back( _mesh );
///     	}
///     	void Render()
///     	{
///             for (auto& Te : SurfaceMap)
///             {
///                 int Slot{ 0 };
///             	for (auto& S : Te.first)
///             	{// Cycle over and fill all the Slots for the Surface,  Diffuse, the Bump map, Shine, Displacement etc..
///             		glActiveTexture(GL_TEXTURE0 + (Slot++));
///             		glBindTexture(GL_TEXTURE_2D, S);
///             	}
///             
///             	for(auto& M : Te.second)
///             	{ 
///             		//M.
///             	}
///             }
///     	}
///     	//std::unordered_map<std::vector<uint32_t>, std::vector<Mesh>> SurfaceMap;
///     	std::vector<std::vector<int>> Pairs;
///     	std::vector<Texture*> Texts;
///     	std::vector<Mesh*> Meshes;
///     	Shader* GPUrenderer;
///     	FrameBufferObject FBO;
///     	DEBUG_CODE(const char* Name{""};)
///     };
/// 	struct Surface_s
/// 	{
/// 		struct Material {
/// 			Texture Tex;
/// 		};
/// 		Shader* MaterialShader;
/// 	};
/// 	void Submit(RenderPair _matMesh)
/// 	{
/// 
/// 	}
///		std::unordered_map<Material, uint32_t> Pairs;
/*=======================================================================================================================================================*/
//
//
//
//
//void QuadBatch::Render()
//{
//}
//
//void QuadBatch::renderQuad(Vec2 _topleft, Vec2 _size, Vec4 _color)
//{
//
//	QuadData.push_back(Vec2(_topleft.x, _topleft.y));
//	QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
//	QuadData.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
//	QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y + _size.y));
//	QuadData.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
//	QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
//
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//}
//
//
//
//LineRenderer->Bind();
//{
//    Shader::get().SetUniform("ModelMatrix", Mat4(1.0f));
//    mainCamera.Bind();
//    Renderer::drawArray(LineVBO, QuadData.size());
//    DEBUG_CODE(CheckGLERROR());
//}
//LineRenderer->Unbind();
//LineData.clear();
// LineRenderer = new Shader(VlineRenderer, FlineRenderer);
// 
// LineVAO = OpenGL::new_VAO();
// LineVBO = OpenGL::new_VBO();
// LineRenderer->Bind();
// {// Sets up the VAO for the Lines
//     OpenGL::bind_VAO(LineVAO);
//     OpenGL::bind_VBO(LineVBO);
//     OpenGL::set_Attribute(LineRenderer->g_ID(), 2, "aPos");  
// }
// LineRenderer->Unbind();
//		std::string VlineRenderer =
//			"#version 330 core     \n\
//layout(location = 0) in vec2 aPos; \n\
//uniform mat4 ProjectionMatrix;     \n\
//uniform mat4 ViewMatrix;           \n\
//uniform mat4 ModelMatrix[100];          \n\
//void main()                        \n\
//{                                  \n\
//    mat4 ModelViewMatrix = (ViewMatrix * ModelMatrix[gl_InstanceID]);  \n\
//    mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);\n\
//    gl_Position = ModelViewProjectionMatrix * vec4(aPos.x, aPos.y, -1.0, 1.0); \n\
//}";
//
//		std::string FlineRenderer =
//			"#version 330 core \n\
//out vec4 FragColor;            \n\
//void main()                    \n\
//{                              \n\
//    FragColor = vec4(1.0, 1.0, 1.0, 1.0);  \n\
//}";
//void Renderer2D::renderLineBatch(const std::vector<Vec2> _batch)
//{
//    LineData.insert(LineData.end(), _batch.begin(), _batch.end());
//}
//
//
//ColorData.push_back(CurrentRenderColor);
//ColorData.push_back(CurrentRenderColor);
//ColorData.push_back(CurrentRenderColor);
//ColorData.push_back(CurrentRenderColor);
//ColorData.push_back(CurrentRenderColor);
//
// void Renderer2D::renderLine(Vec2 _start, Vec2 _end)
// {
//     LineData.push_back(_start);
//     LineData.push_back(_end);
// }
//		Shader* LineRenderer;
//       Vec2
//           _topleft = Vec2(30, 30),
//           _bottomright = Vec2(200.f, 200.f);
//
//       Vec2 Offset = Vec2
//       (// Later we may perform a check to ensure values are properly ordered
//           (_bottomright.x - _topleft.x) * 0.5f,
//           (_bottomright.y - _topleft.y) * 0.5f
//       );
//       Vec2 Position = { 100, 100 };
//
// VertexData.push_back({ 200.0, 200.0 });
// VertexData.push_back({ 400.0, 200.0 });
// VertexData.push_back({ 0.0, 400.0 });
// VertexData.push_back(Vec2(Position.x - Offset.x, Position.y + Offset.y));
// VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
// VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
 //       renderQuad(Vec2(100,100), Vec2(200,200));
        //==============================================================================
        //Vec2 Offset = Vec2
       //(// Later we may perform a check to ensure values are properly ordered
       //    (_size.x - _topleft.x) * 0.5f,
       //    (_size.y - _topleft.y) * 0.5f
       //);
       //
       //VertexData.push_back(Vec2(-Offset.x, +Offset.y));
       //VertexData.push_back(Vec2(-Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(+Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(-Offset.x, +Offset.y));
       //VertexData.push_back(Vec2(+Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(+Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(-Offset.x, +Offset.y));
       //VertexData.push_back(Vec2(-Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(+Offset.x, -Offset.y));
// Currently Memcpy is far slower than Insert. Like 1/2 the speed
/// size_t Sz = QuadData.size() + _batch.size();
       /// size_t Start = QuadData.size();
       /// QuadData.reserve(Sz);
       /// memcpy(&QuadData[Start ], &_batch[0], _batch.size() * sizeof(Vec2));
//  for_loop(y, 10)
//  {
//      for_loop(x, 10)
//      {
//          Transform Tr = Transform({ x,y,0 }, { 0,0,0 }, "Tr");
//          Transforms.push_back(Tr.get());
//      }
//  }
/*
        Vec2 _topleft = { 0 ,0 };    _size = {1, 1};
        QuadData.push_back(Vec2(_topleft.x, _topleft.y));
        QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
        QuadData.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
        QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y + _size.y));
        QuadData.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
        QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y));


*/// Vec2 Sz
// {
//    ( Right * ZoomLevel)* AspectRatio ,
//     Bottom  * ZoomLevel,
// };

//  Sz.x,
//Sz.y,
//    Sz *= _amount;
//	float
//		Sx = Right * ZoomLevel * 0.5f,
//		Sy = Bottom * ZoomLevel * 0.5f;
//

///ProjectionMatrix =
///	glm::ortho
///	(
///		0.0f - Sx,
///		Right * ZoomLevel,
///		Bottom * ZoomLevel,
///		0.0f - Sy,
///		Near,
///		Far
///	);  //OrthographicMatrix(_size.x, _size.y);
///}
   // TODO("This is not currently setup correctly 2/18/2020: The Left and Right should zoom in on that current location of the Camera");

/*=======================================================================================================================================================
/*                                               NOTES
/*=======================================================================================================================================================

template <typename valType>
GLM_FUNC_QUALIFIER detail::tmat4x4<valType> ortho
(
    valType const & left,
    valType const & right,
    valType const & bottom,
    valType const & top,
    valType const & zNear,
    valType const & zFar
)
{
    detail::tmat4x4<valType> Result(1);
    Result[0][0] = valType(2) / (right - left);
    Result[1][1] = valType(2) / (top - bottom);
    Result[2][2] = - valType(2) / (zFar - zNear);
    Result[3][0] = - (right + left) / (right - left);
    Result[3][1] = - (top + bottom) / (top - bottom);
    Result[3][2] = - (zFar + zNear) / (zFar - zNear);
    return Result;
}
 /*   Vec2 Diff = Size - Vec2
    (
        Right* (1.0f / ZoomLevel),
        Bottom* (1.0f / ZoomLevel)
    );
    
       
    Print("Zoom Level: " << (1.0f / ZoomLevel));

    if (ZoomLevel > 0)
    {
        ProjectionMatrix =
            glm::ortho
            (
                Position.x   * (1.0f / ZoomLevel),
                Right  *  (1.0f / ZoomLevel),
                Bottom *  (1.0f / ZoomLevel),
                Position.y   *  (1.0f / ZoomLevel),
                Near,
                Far
            );
    }
    else
    {
        ProjectionMatrix =
            glm::ortho
            (
                Position.x   * -(1.0f / ZoomLevel),
                Right  *  -(1.0f / ZoomLevel),
                Bottom *  -(1.0f / ZoomLevel),
                Position.y   *  -(1.0f / ZoomLevel),
                Near,
                Far
            );

    }
    */
//    ZoomLevel += (1.0f /_amount);
	//	ProjectionMatrix = glm::ortho(0.0f, size.x, size.y, 0.0f, -1.0f, 1.0f);  //OrthographicMatrix(size.x, size.y);
	//	ViewMatrix = glm::translate(Mat4(1.0f), Vec3(-100, 0, 0));
//Top = _top;
//Left = _left;
//ProjectionMatrix = glm::ortho(0.0f, Right, Bottom, 0.0f, -1.0f, 100.0f);  //OrthographicMatrix(_size.x, _size.y);
//ViewMatrix = glm::translate(Mat4(1.0f), Vec3(0, 0, 0));//200, 200, 0))
//Size(size)



/*=======================================================================================================================================================*/
//ViewMatrix = glm::translate(ViewMatrix, Vec3(-_amount.x, -_amount.y, 0));
//ViewMatrix = glm::translate(ViewMatrix, Vec3(-_amount, 0, 0));
//ViewMatrix = glm::translate(ViewMatrix, Vec3(0, -_amount, 0));
//  ZoomLevel += _amount;
//  
//  float
//  Sx = Right * ZoomLevel * 0.5f,
//  Sy = Bottom * ZoomLevel * 0.5f;
//  
//  
//  
//  ProjectionMatrix =
//  glm::ortho
//  (
//  	0.0f - Sx,
//  	Right * ZoomLevel,
//  	Bottom * ZoomLevel,
//  	0.0f - Sy,
//  	Near,
//  	Far
//  );  //OrthographicMatrix(_size.x, _size.y);



//================= #APPLICATION


/*


    //Print("Callback:" << uMsg);
    ///switch (uMsg)
    ///{
    ///
    ///case WM_ACTIVATE:                       // Watch For Window Activate Message
    ///{
    ///	if (!HIWORD(wParam))                    // Check Minimization State
    ///	{
    ///		Print("Active");                    // Program Is Active
    ///	}
    ///	else
    ///	{
    ///		Print("Inactive");              // Program Is No Longer Active
    ///	}
    ///
    ///	break;                              // Return To The Message Loop
    ///}
    ///
    ///case WM_SYSCOMMAND:                     // Intercept System Commands
    ///{
    ///	switch (wParam)                     // Check System Calls
    ///	{
    ///	case SC_SCREENSAVE:                 // Screensaver Trying To Start?
    ///	case SC_MONITORPOWER:               // Monitor Trying To Enter Powersave?
    ///		return 0;                       // Prevent From Happening
    ///	}
    ///	break;                              // Exit
    ///}
    ///
    ///case WM_CLOSE:                          // Did We Receive A Close Message?
    ///{
    ///	Print("Close");
    ///	PostQuitMessage(0);                 // Send A Quit Message
    ///	break;    // Jump Back
    ///}
    ///
    ///case WM_KEYDOWN:                        // Is A Key Being Held Down?
    ///{
    ///	Application::getDevice().Keyboard.Keys[wParam] = true;                    // If So, Mark It As TRUE
    ///	break;                      // Jump Back
    ///}
    ///
    ///case WM_KEYUP:                        // Is A Key Being Held Down?
    ///{
    ///	Application::getDevice().Keyboard.Keys[wParam] = false;                    // If So, Mark It As TRUE
    ///	break;                      // Jump Back
    ///}
    ///
    ///case WM_MOUSEMOVE:
    ///{
    ///	 Application::getDevice().Mouse.Relative = Application::getDevice().Mouse.Position;
    ///	 Application::getDevice().Mouse.Position = { (float)GET_X_LPARAM(lParam),(float)GET_Y_LPARAM(lParam) };
    ///
    ///	 Application::getDevice().Mouse.Relative.x = Application::getDevice().Mouse.Position.x - Application::getDevice().Mouse.Relative.x;
    ///	 Application::getDevice().Mouse.Relative.y = Application::getDevice().Mouse.Position.y - Application::getDevice().Mouse.Relative.y;
    ///
    ///	Print("MouseMove:" <<  Application::getDevice().Mouse.Relative.x << " : " <<  Application::getDevice().Mouse.Relative.y);
    ///	Print("Position:" <<   Application::getDevice().Mouse.Position.x << " : " <<  Application::getDevice().Mouse.Position.y);
    ///
    ///}
    ///
    ///case WM_LBUTTONDOWN:
    ///{
    ///	Print("MouseDown");
    ///	break;
    ///}
    ///
    ///case WM_LBUTTONUP:
    ///{
    ///	Print("Left Button Up");
    ///	break;
    ///}
    ///
    ///case WM_LBUTTONDBLCLK:
    ///{
    ///	Print("L DClick ");
    ///	break;
    ///}
    ///
    ///case WM_RBUTTONDOWN:
    ///{
    ///	Print(" RButtonDown");
    ///	break;
    ///}
    ///
    ///case WM_RBUTTONUP:
    ///{
    ///	Print(" RButUP");
    ///	break;
    ///}
    ///
    ///case WM_RBUTTONDBLCLK:
    ///{
    ///	Print(" R Button DClick");
    ///	break;
    ///}
    ///
    ///case WM_MBUTTONDOWN:
    ///{
    ///	Print(" MButtonDown");
    ///	break;
    ///}
    ///
    ///case WM_MBUTTONUP:
    ///{
    ///	Print("M BUtton UP ");
    ///	break;
    ///}
    ///
    ///case WM_MBUTTONDBLCLK:
    ///{
    ///	Print(" MButton DClick");
    ///	break;
    ///}
    ///
    ///case WM_XBUTTONDOWN:
    ///{
    ///	Print(" XButtonDown");
    ///	break;
    ///}
    ///case WM_XBUTTONUP:
    ///{
    ///	Print(" X Up");
    ///	break;
    ///}
    ///
    ///case WM_XBUTTONDBLCLK:
    ///{
    ///	Print(" X DClick");
    ///	break;
    ///}
    ///
    ///case WM_SIZE:
    ///{
    ///	Application::getWindow().ResizeWindow(HIWORD(wParam), LOWORD(wParam));
    ///	break;
    ///}
    ///default:
    ///	return DefWindowProc(hwnd, uMsg, wParam, lParam);
    ///}



#if 0
while (true)
{
    MSG msg;
    BOOL bRet;
    while (PeekMessage(&msg, Application::getWindow().g_Handle(), 0, 0, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    Update();
    Render();
}
#else


Application::Window::Event::Event()
    :
    ID(0),
    ///WinID(0),
    Time(0)
{
    memset(&data, 0, 16);
}
Application::Window::Event::Event(MsgType msg)
    :
    ID(msg),
    ///WinID(0),
    Time(0)
{
    memset(&data, 0, 16);
}
*/
//struct Application
//{
//	struct Window
//	{
//		struct InputDevices
//		{
//			struct {}Mouse;
//			struct {}Keyboard;
//		}Input;
//		struct EventHandler
//		{}EventSystem;
//	}mainWindow;
//};
        /*
        struct Event
        {// Event Union Defining an Event the Engine can produce
            Event();
            Event(MsgType msg);

            MsgType ID;
            ///	WindowID WinID;
            unsigned long Time;
            Vec2 Location{ 0, 0 };
#pragma pack(push, 1)
            union msgUnion
            {// All messages are 128 bits
                msgUnion() = default;

                msgUnion& operator =(const msgUnion& other)
                {
                    memcpy(this, &other, sizeof(other)); // Should be 16 bytes, check this if any changes get made
                    return *this;
                }

                struct msgstruct
                {
                    uint32_t wordParam;
                    uint64_t longParam;
                    uint32_t Padding;
                }MSG; // 128 bits
                struct kbstruct
                {
                    uint32_t KeyCode;
                    uint32_t ScanCode;
                    uint32_t Action;
                    uint32_t Mods;
                }Keyboard; // 128
                struct mousestruct
                {
                    uint32_t Button;
                    uint32_t x;
                    uint32_t y;
                    int16_t relX;
                    int16_t relY;
                }Mouse; // 128
                struct buttonstruct
                {
                    struct buttons
                    {
                        uint8_t
                            Left,
                            Right,
                            Middle,
                            Wheel;
                    }Buttons; // 32
                    uint32_t Action;
                    uint32_t Modification;
                    uint32_t Padding;
                }MouseButton; // 128
                struct textstruct {}TextInput;
            }data;
#pragma pack(pop)
            Event(MSG _msg)
            {
                Location.x = _msg.pt.x;
                Location.y = _msg.pt.y;

                ID = _msg.message;
                this->data.MSG.longParam = _msg.lParam;
                this->data.MSG.wordParam = _msg.wParam;
                this->data.MSG.Padding = 0;
                this->Time = _msg.time;
            }
            bool Handled() { return (ID == 0); }
        };
*/

/*	{// OpenGL Rendering Context Scope
        //  wglCreateContext	    Creates a new rendering context.
        //  WglMakeCurrent	        Sets a thread's current rendering context.
        //  WglGetCurrentContext	Obtains a handle to a thread's current rendering context.
        //  WglGetCurrentDC      	Obtains a handle to the device context associated with a thread's current rendering context.
        //  WglDeleteContext	    Deletes a rendering context.

        GL_Context = wglCreateContext(DeviceContext);
        if (!wglMakeCurrent(DeviceContext, GL_Context))
        {
            std::cout << "Making Current Rendering Context Failed" << "\n";
        }
        if (!GL_Context)
        {
            MessageBox
            (/// Turn all this into a Macro for Clearity
                NULL,
                "GL Context Creation Failed  "
                "Cannot Create Renderer",
                "Error",
                MB_OK
            );
        }

        if (!gladLoadGL())
        {// If the Loading of OpenGL functions fails report it and exit
            int error_code = glad_glGetError();
            std::cout << "Failed to initialize GLAD" << error_code << std::endl;
            __debugbreak();
        };

        Title = std::string("OPENGL VERSION ") + std::string((char*) glGetString(GL_VERSION));
        SetWindowTextA
        (
            Handle,
            Title.c_str()
        );

        //  wglCreateContext	    Creates a new rendering context.
        //  WglMakeCurrent	        Sets a thread's current rendering context.
        //  WglGetCurrentContext	Obtains a handle to a thread's current rendering context.
        //  WglGetCurrentDC      	Obtains a handle to the device context associated with a thread's current rendering context.
        //  WglDeleteContext	    Deletes a rendering context.
    }*/


    ///std::ostream& operator <<(std::ostream& os, ErrorMessage& _msg)
///{
///	os << "Error: " << _msg.ErrorNumber << "\n At: " << _msg.Time << "\n ";
///	return os;
///}
///std::ostream& operator<<(std::ostream& stream, const Vec2& vector)
///{
///	stream << "X:[" << vector.x << "] - Y:[" << vector.y << "]";
///	return stream;
///std::string BasicVertexShader = "#version 330 \n\
///layout(location = 0) in vec3 Position;\n\
///out vec3 VColor;\n\
///out vec4 FragPosition;\n\
///void main()\n\
///{\n\
///FragPosition = vec4(Position.xyz, 1.0f);\n\
///VColor = vec3(1.0,1.0,1.0);\n\
///}";
///
///std::string BasicFragmentShader = "#version 330 \n\
///out vec4 color;         \n\
///in vec3 VColor;    \n\
///in vec4 FragPosition;   \n\
///void main(){            \n\
///color = vec3(1, 1, 0, 1);  \n\
///}";
///std::string VertexShader = " #version 330 core \n\
///layout(location = 0) in vec3 aPos; 			\n\
///uniform mat4 ProjectionMatrix;              \n\
///uniform mat4 ViewMatrix;                    \n\
///uniform mat4 ModelMatrix;                   \n\
///out vec4 VColor; 						\n\
///void main()									\n\
///{											\n\
///	gl_Position = vec4(aPos, 1.0);			\n\
///	VColor = vec4(0.5, 1.0, 0.0, 1.0); \n\
///}";
///vec4(texture(texture1,TexCoords.xy).xyzw); 
///std::string FragmentShader = "#version 330 core \n\
///out vec4 FragColor;                             \n\
///in vec4 VColor;                            \n\
///void main()                                     \n\
///{                                               \n\
///	FragColor = VColor;                    \n\
///}";
///
///    std::string vRenderer =
///    "#version 330 core \n\
///    layout(location = 0) in vec4 aPos;          \n\
///    uniform mat4 ProjectionMatrix;                    \n\
///    uniform mat4 ViewMatrix;                         \n\
///    uniform mat4 Model;                         \n\
///    out vec3 VColor;                       \n\
///    out vec2 TexCoords;                         \n\
///    void main()                                 \n\
///    {                                           \n\
///        mat4 ModelViewMatrix = (ViewMatrix * Model);  \n\
///        mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);\n\
///        TexCoords = aPos.zw;                          \n\
///        gl_Position = ModelViewProjectionMatrix * vec4(aPos.x, aPos.y, -1.0, 1.0); \n\
///    }";
///    std::string fRenderer =
///    "#version 330 core \n\
///    in vec3 VColor;                              \n\
///    uniform sampler2D texture1;                       \n\
///    out vec4 FragColor;                               \n\
///    in  vec2 TexCoords;                               \n\
///    void main()                                       \n\
///    {                                                 \n\
///        FragColor = vec4(texture(texture1,TexCoords.xy).xyzw);  \n\
///    }";
///    
===================== #APPLICATION_END
            
            

// ============================================================================================================================================================================
// ============================================================================================================================================================================
   











   
//DEBUGPrint(CON_DarkRed, "Created Queue: ");

//======================================================================================
//========================= DEBUG INFOMATION ======================================================
// #include<Windows.h>
// 
// extern HANDLE hConsole;
// #define SetColor(x) SetConsoleTextAttribute(hConsole, x);
// //
// //#define DEBUGPrint(col, x) {DEBUGMutex.lock();\
// //SetColor(col);\
// //std::thread::id CurrentThread = std::this_thread::get_id();\
// //std::cout <<  x << " : " << CurrentThread<< std::endl;\
// //SetColor(7);\
// DEBUGMutex.unlock();}
// #define DEBUGPrint(col,x)
// extern std::mutex DEBUGMutex;
// 
//======================================================================================
//======================================================================================
//	_function->ThreadID = std::this_thread::get_id();
//				std::thread::id ThreadID{ std::this_thread::get_id() };
//HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
// template<typename _FUNC, typename...ARGS >
// auto Launch_Now(_FUNC&& _func, ARGS&&... args)
// {
// 	return _func(args...);					DEBUGPrint(CON_DarkPurple, " Call from a Different Thread");
// 
// }

//std::printf(x );\
//DEBUGPrint(CON_DarkYellow, "Async Called: " << &_func);
//	Print(typeid(_func).
//int PushColor = 2;
//int PopColor = 3;
//std::mutex DEBUGMutex;

//DEBUGPrint(CON_Green, "Function Called from " << _func->ThreadID << "- Pop CurrentThread: \n");
//DEBUGPrint(PopColor,"%d \n", _func->ThreadID);
//DEBUGPrint(PopColor, "- Pop CurrentThread: \n");

//DEBUGPrint(CON_Blue, "Func Address: 0x" << &_func);
//DEBUGPrint(CON_Red, "Try Push CurrentThread: ");

//DEBUGPrint(CON_DarkBlue, "Func Address: 0x" << &_func);
//DEBUGPrint(CON_DarkRed, "Push CurrentThread: ");

//DEBUGPrint(PopColor, "Function Called from "); DEBUGPrint(PopColor,"%d \n", _func->ThreadID); DEBUGPrint(PopColor, "- Pop CurrentThread: \n");
//DEBUGPrint(CON_DarkGreen, "Function Called from " << _func->ThreadID << "- Pop CurrentThread:");

				//Print(Main_ThreadID << std::thread::this_thread.get_id());
				//DEBUGPrint(CON_Yellow, "Running Function: " << Function->ThreadID);


   
   
   
   if (_func->LaunchThread == QueueID) Print("Job Pushed to Thread it was Launched from. Possible Error if Recursive Call made ");

                if (_func->LaunchThread == QueueID) Print("Job Pushed to Thread it was Launched from. Possible Error if Recursive Call made ");


//template<typename _R>
//bool is_ready(Future<_R> & _fut)
//{
//	return _fut.valid();
//}

#include<csetjmp>
#define PRINT_Thread(x)   Print(x);\
                          std::thread::id CurrentThread = std::this_thread::get_id();\
                          Print("Current Thread " << CurrentThread << "Launched Thread: " << LaunchThread)


#if 1
			/* Executor for our Threadpool Allocating our Asyncronous objects, returning their Futures an handles work sharing throughout all the available Queues*/
			///<Possibly to avoid Code bloat Make Async create the asynTask and Future and cast the task to Executionwer before sending it to the rest of the function to process>
			///<This way it will only duplicate the Async code and not the rest when not needed>
			template<typename _FUNC, typename...ARGS >
			auto Async(_FUNC&& _func, ARGS&&... args)->std::future<typename asyncTask<_FUNC, ARGS... >::type>
			{// Accept arbitrary Function signature, Bind its arguments and add to a Work pool for Asynchronous execution


				auto _function = new asyncTask<_FUNC, ARGS... >(std::move(_func), std::forward<ARGS>(args)...);  // Create our task which binds the functions parameters
				auto result = _function->get_future();                                                           // Get the future of our async task for later use
				Submit(static_cast<Executor*>(_function));
                return result;
            }

			void Submit(Executor *_task)
			{
				auto i = Index++;  
				auto ThreadID = std::this_thread::get_id();

							
			/*     SUSPEND: Attempt at making a Fork point so the current location of the program is pushed to the 
			    Threadpool to allow the child function to return first

			*********INCOMPLETE*********/
			template<typename _Func, typename ...ARGS>
            struct Suspend final
				: public Executor
            {	
				NO_COPY_OR_ASSIGNMENT(Suspend);

				using child_type = std::invoke_result_t<_Func, ARGS...>;
            	virtual ~Suspend() noexcept = default; // Virtual destructor to ensure proper Deallocation of object
				std::jmp_buf* Context{}; // This thing gets in the way with Cryptic Error message if not properly initialize so I am using pointer
				int Return{ -1 };
            	/* Pushes current Threads execution to our Queue */
				Suspend(std::jmp_buf* _context, _Func&& _function, ARGS&&... _args) noexcept
					:
					Context( _context ),
					Function(std::forward<_Func>(_function)),
					Arguments(std::forward<ARGS>(_args)...)
            	{ 
					Status = Valid;
					PRINT_Thread("Suspend Thread: ");
				}

            	/* Returns Execution to where previously suspend */
            	virtual void Invoke() noexcept override
            	{
					PRINT_Thread("Suspend Thread Invoke: ");
 				    Status = Waiting;
				    auto result = std::apply(Function, Arguments); // Can not continue on until function returns which goes into result
					ReturnValue.set_value(result);// Result sets the return value of the future. Our main thread is allowed to Run now...

            	}
            
				auto get_future() noexcept
				{ 
					PRINT_Thread("Getting the Future of the Suspended Task ");
					Status = Submitted;

					return ReturnValue.get_future();
				}

				void set_return(child_type& _value)
				{
					PRINT_Thread("Setting Value of the Suspended Task. ");
					ReturnValue.set_value(_value);
				}

            private:
				using Fptr = child_type(*)(ARGS...);    // Function pointer type for our function
				const Fptr Function;                    // Pointer to our Child Function
				const std::tuple<ARGS...> Arguments;    // Tuple which Binds the Parameters to the Child Function call
				std::promise<child_type> ReturnValue;   // Return Value of our function stored as a Promise
            };




///<Possibly to avoid Code bloat Make Async create the asynTask and Future and cast the task to Executionwer before sending it to the rest of the function to process>
///<This way it will only duplicate the Async code and not the rest when not needed>

				
				auto ThreadID = std::this_thread::get_id();
				//===================================== IF TASK WAS LANCHED FROM ANOTHER RUNNING TASK ==================================================
				//if (Main_ThreadID != ThreadID)                // If this is being call from one of the Threadpool Threads.
				//{// If not our main thread run now
				//	_function->Invoke();                                                                         // Invoke Immediately as our Thread is alreadylocked up
				//	delete& (*_function);                                                                       // Destroy the Object which our Async Class Allocated
				//	return result;
				//}
				//======================================================================================================================================




				//===================================== IF TASK WAS LANCHED FROM ANOTHER RUNNING TASK ==================================================
				//if (Main_ThreadID != ThreadID)                // If this is being call from one of the Threadpool Threads.
				//{// If not our main thread run now
				//	_function->Invoke();                                                                         // Invoke Immediately as our Thread is alreadylocked up
				//	delete& (*_function);                                                                       // Destroy the Object which our Async Class Allocated
				//	return result;
				//}
				//======================================================================================================================================
																												 // Ensure fair work distribution
				int Attempts = 5;
				for (unsigned int n{ 0 }; n != ThreadCount * Attempts; ++n)                                      // Attempts is Tunable for better work distribution
				{// Cycle over all Queues K times and attempt to push our function to one of them

					if (ThreadQueue[static_cast<size_t>((i + n) % ThreadCount)].try_push(_task))
					{// If succeeded return our functions Future
						return;
					}
				}

				// In the rare instance that all attempts at adding work fail just push it to the Owned Queue for this thread
				ThreadQueue[i % ThreadCount].push(_task);
				return;
			}
#else








// Mat4 Rotate_Translate(Vec3 _pos, Vec3 _rot)
// {
//     return glm::rotate
//     ( // ensure unneeded copying as the results from the last transform are immediately used in the next step
//         glm::rotate
//         (
//             glm::rotate
//             (
//                 glm::translate
//                 ( // Starts with the Translation here
//                     glm::mat4(1.0f),
//                     _pos
//                 ),
//                 glm::radians(_rot.x),
//                 Vec3(1.0f, 0.0f, 0.0f)),
//             glm::radians(_rot.y),
//             Vec3(0.0f, 1.0f, 0.0f)),
//         glm::radians(_rot.z),
//         Vec3(0.0f, 0.0f, 1.0f)
//     );
// }
		
/*
Co-Routine implementation
https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
In the context of the C programming language, function arguments are pushed on the stack in the right-to-left order,
i.e. the last argument is pushed first. In Linux, GCC sets the de facto standard for calling conventions. Since GCC version 4.5,
the stack must be aligned to a 16-byte boundary when calling a function (previous versions only required a 4-byte alignment.)

C++ Calling Conventions in ASM

_CDECL

caller:
	; make new call frame
	; (some compilers may produce an 'enter' instruction instead)
	push    ebp       ; save old call frame
	mov     ebp, esp  ; initialize new call frame
	; push call arguments, in reverse
	; (some compilers may subtract the required space from the stack pointer,
	; then write each argument directly, see below.
	; The 'enter' instruction can also do something similar)
	; sub esp, 12      : 'enter' instruction could do this for us
	; mov [ebp-4], 3   : or mov [esp+8], 3
	; mov [ebp-8], 2   : or mov [esp+4], 2
	; mov [ebp-12], 1  : or mov [esp], 1
	push    3
	push    2
	push    1
	call    callee    ; call subroutine 'callee'
	add     eax, 5    ; modify subroutine result
					  ; (eax is the return value of our callee,
					  ; so we don't have to move it into a local variable)
	; restore old call frame
	; (some compilers may produce a 'leave' instruction instead)
	; add   esp, 12   ; remove arguments from frame, ebp - esp = 12.
					  ; compilers will usually produce the following instead,
					  ; which is just as fast, and, unlike the add instruction,
					  ; also works for variable length arguments
					  ; and variable length arrays allocated on the stack.
	mov     esp, ebp  ; most calling conventions dictate ebp be callee-saved,
					  ; i.e. it's preserved after calling the callee.
					  ; it therefore still points to the start of our stack frame.
					  ; we do need to make sure
					  ; callee doesn't modify (or restores) ebp, though,
					  ; so we need to make sure
					  ; it uses a calling convention which does this
	pop     ebp       ; restore old call frame
	ret               ; return

*/







/* 
_DATA SEGMENT
hello_msg db "Hello world", 0
info_msg  db "Info", 0
_DATA ENDS
To define read-only and executable data, do that inside the text segment:

_TEXT    SEGMENT
hello_msg db "Hello world", 0
info_msg  db "Info", 0
_TEXT    ENDS

EXTERN c_ext_byte: byte
EXTERN c_ext_word: word
EXTERN c_ext_dword: dword
EXTERN c_ext_qword: qword
EXTERN c_ext_ptr: qword
EXTERN c_ext_my_function: PROC
EXTERN MessageBoxA: PROC
EXTERN GetForegroundWindow: PROC

PUBLIC access_extern_data
access_extern_data PROC
; Dereference all the data according to each data's sizes
mov    al, byte ptr [c_ext_byte]
mov ax, word ptr [c_ext_word]
mov eax, dword ptr [c_ext_dword]
mov rax, qword ptr [c_ext_qword]
; Remember, a pointer is just a QWORD
mov rax, qword ptr [c_ext_ptr]
; Similarily, a function pointer is also a QWORD
mov rax, offset c_ext_my_function
sub rsp, 4 * 8 ; Register shadow stack
call rax ; call the C function
add rsp, 4 * 8 ; Restore the stack
ret
access_extern_data ENDP

EXTERN MessageBoxA: PROC
EXTERN GetForegroundWindow: PROC
PUBLIC hello_world_asm
hello_world_asm PROC
push rbp ; save frame pointer
mov rbp, rsp ; fix stack pointer
sub rsp, 8 * (4 + 2) ; allocate shadow register area + 2 QWORDs for stack alignment
; Get a window handle
call GetForegroundWindow
mov rcx, rax
; WINUSERAPI int WINAPI MessageBoxA(
;  RCX =>  _In_opt_ HWND hWnd,
;  RDX =>  _In_opt_ LPCSTR lpText,
;  R8  =>  _In_opt_ LPCSTR lpCaption,
;  R9  =>  _In_ UINT uType);
mov rdx, offset hello_msg
mov r8, offset info_msg
mov r9, 0 ; MB_OK
and rsp, not 8 ; align stack to 16 bytes prior to API call
call MessageBoxA
; epilog. restore stack pointer
mov rsp, rbp
pop rbp
ret
hello_world_asm ENDP

*/ 
/*==================================================================================================================
/*                                                TRASH   #RenderUtilities 1/22/2020
/*==================================================================================================================*/

                   //glBindBuffer(GL_ARRAY_BUFFER, VBO);
                   //{
                   //    glDrawArrays(GL_TRIANGLES, 0, 6);
                   //}
                   //glBindBuffer(GL_ARRAY_BUFFER, 0);

/*

//Vec4 Vertices[4] =
//{
//	{ -1.0, -1.0,             0.0, 0.0 },
//	{  0.0, -1.0,             1.0, 0.0 },
//	{  0.0,  0.0,             1.0, 1.0 },
//	{ -1.0,  0.0,             0.0, 1.0 }
//};
		//float S = 1.2;
		float S = 200.2;
		Vec2 UVcoords[4] =
		{
			{  },
			{  },
			{  },
			{  }
		};

			Vec4 Vertices[6] =
			{   // positions   // texCoords
				Vec4(-S,  S,    0.0f,  1.0f),
				Vec4(-S, -S,    0.0f,  0.0f),
				Vec4( S, -S,    1.0f,  0.0f),
				Vec4(-S,  S,    0.0f,  1.0f),
				Vec4( S, -S,    1.0f,  0.0f),
				Vec4( S,  S,    1.0f,  1.0f)
			}; */

//ReadBuffer[x + (int)Size.x * y].r = R;
//ReadBuffer[x + (int)Size.x * y].g = G;
//ReadBuffer[x + (int)Size.x * y].b = B;
   //ReadBuffer[x + (int)Size.x * y] = Pixel(R, G, B, 255);
   //if (x % 2 == 0)
   //{
//	WriteBuffer[x + (int)Size.x * y].g = 0;
//	WriteBuffer[x + (int)Size.x * y].b = 0;
//	WriteBuffer[x + (int)Size.x * y].a = 0;
	//ReadBuffer[x + (int)Size.x * y].r = R;
	//ReadBuffer[x + (int)Size.x * y].g = G;
	//ReadBuffer[x + (int)Size.x * y].b = B;
	//ReadBuffer[x + (int)Size.x * y].g = 255;
	//setPixel(x, y, Pixel(255, 255, 255, 255));//rabg

//	setPixel(x, y, Pixel(0, 255,  0, 0));//rabg
	//setPixel(x, y, Pixel(0, 0, 255, 0));//rabg
//	setPixel(x, y, Pixel(0, 0, 0, 255));//rabg
//}

//vec4(VColor.xyz, 1.0); 

/*	VColor = texture(texture1, aPos.zw).xyz; \n\

"#version 330\
uniform mat4 ProjectionMatrix;\
uniform mat4 ViewMatrix;\
uniform mat4 ModelMatrix;\
layout(location = 0) in vec3 Position;\
layout(location = 1) in vec2 TextureCoord;\
out vec2 FPosition;\
out vec2 TCoord;\
void main(){\
	mat4 ModelViewMatrix = (ViewMatrix * ModelMatrix);\
	mat4 ModelViewProjectionMatrix = (Matrix.projection * ModelViewMatrix);\
	vec4 WorldPosition = vec4(Position, 1.0f);\
	FPosition = (ModelMatrix * vec4(Position, 1.0f)).xyz;\
	TCoord = TextureCoord;\
	gl_Position = ModelViewProjectionMatrix * vec4(Position.xyz, 1.0f);\
}\

"#version 330\
in vec3 FPosition;\
in vec2 TCoord;\
out vec4 FragColor;\
void main()\
{\
	vec4 color = texture(sampler2D(DiffuseTexture), TCoord.xy);\
	FragColor = color;\
}

*/

//	setPixel(20, 0, 100);
	/*
		W --- > R --- W ---
		//memcpy((char*)ReadBuffer + (LineSize - sizeof(Pixel)), (char*)WriteBuffer, size() - (LineSize - sizeof(Pixel)));

	*/













#TRASHEDSHADER
//VertID = glCreateShader(GL_VERTEX_SHADER);
//FragID = glCreateShader(GL_FRAGMENT_SHADER);
//
//std::string vertSourceString = vert;
//std::string fragSourceString = frag;
//
//const char* vertSource = vertSourceString.c_str();
//const char* fragSource = fragSourceString.c_str();
//
//glShaderSource(VertID, 1, &vertSource, NULL);
//glCompileShader(VertID);
//GetShaderError(Vert);
//
//glShaderSource(FragID, 1, &fragSource, NULL);
//glCompileShader(FragID);
//GetShaderError(Frag);
//
//glAttachShader(GL_Handle, VertID);
//glAttachShader(GL_Handle, FragID);
//glLinkProgram(GL_Handle);
//GetShaderError(Program);
//
//glValidateProgram(GL_Handle);
//glDetachShader(GL_Handle, VertID);
//glDetachShader(GL_Handle, FragID);
//glDeleteShader(VertID);
//glDeleteShader(FragID);
//
//glUseProgram(GL_Handle);

#if 0
	// Create the shaders
	uint32_t ERR = 0;
	if ((ERR = glGetError()))
	{
		Print("Error" << ERR);
		__debugbreak();
	}

	uint32_t VertexShaderID   = glCreateShader(GL_VERTEX_SHADER);
	uint32_t FragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);

	// Read the Vertex Shader code from the file
	std::string VertexShaderCode = VertexShader;
	std::string FragmentShaderCode = FragmentShader;


	GLint Result = false;
	int InfoLogLength{ 0 };

	// Compile Vertex Shader
	//printf("Compiling shader : %s\n", vertex_file_path);
	char const* VertexSourcePointer = VertexShaderCode.c_str();
	glShaderSource(VertexShaderID, 1, &VertexSourcePointer, NULL);
	glCompileShader(VertexShaderID);

	// Check Vertex Shader
	glGetShaderiv(VertexShaderID, GL_COMPILE_STATUS, &Result);
	glGetShaderiv(VertexShaderID, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> VertexShaderErrorMessage;
		VertexShaderErrorMessage.resize(InfoLogLength + 1);

		glGetShaderInfoLog(VertexShaderID, InfoLogLength, NULL, &VertexShaderErrorMessage[0]);
		printf("%s\n", &VertexShaderErrorMessage[0]);
	}

	// Compile Fragment Shader
	char const* FragmentSourcePointer = FragmentShaderCode.c_str();
	glShaderSource(FragmentShaderID, 1, &FragmentSourcePointer, NULL);
	glCompileShader(FragmentShaderID);

	// Check Fragment Shader
	glGetShaderiv(FragmentShaderID, GL_COMPILE_STATUS, &Result);
	glGetShaderiv(FragmentShaderID, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> FragmentShaderErrorMessage;
		FragmentShaderErrorMessage.resize(InfoLogLength + 1);
		glGetShaderInfoLog(FragmentShaderID, InfoLogLength, NULL, &FragmentShaderErrorMessage[0]);
		printf("%s\n", &FragmentShaderErrorMessage[0]);
	}

	// Link the program
	printf("Linking program\n");
	 BasicShader = glCreateProgram();
	 glAttachShader(BasicShader, VertexShaderID);
	 glAttachShader(BasicShader, FragmentShaderID);
	 glLinkProgram(BasicShader);
	 
	// Check the program
	 glGetProgramiv(BasicShader, GL_LINK_STATUS, &Result);
	 glGetProgramiv(BasicShader, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> ProgramErrorMessage;
		ProgramErrorMessage.resize(InfoLogLength + 1);
	 	glGetProgramInfoLog(BasicShader, InfoLogLength, NULL, &ProgramErrorMessage[0]);
		printf("%s\n", &ProgramErrorMessage[0]);
	}

	 glDetachShader(BasicShader, VertexShaderID);
	 glDetachShader(BasicShader, FragmentShaderID);
	 
	 glDeleteShader(VertexShaderID);
	 glDeleteShader(FragmentShaderID);

	ERR = 0;
	 if ((ERR = glGetError()))
	 {
	 	Print("Error" << ERR);
	 	__debugbreak();
	 }
#else
	// Create the shaders
#if 0
	CheckGLERROR();

	VertID = glCreateShader(GL_VERTEX_SHADER);
	FragID = glCreateShader(GL_FRAGMENT_SHADER);

	// Read the Vertex Shader code from the file
	std::string VertexShaderCode = _vertstring;
	std::string FragmentShaderCode = _fragstring;


	GLint Result = false;
	int InfoLogLength{ 0 };

	// Compile Vertex Shader
	//printf("Compiling shader : %s\n", vertex_file_path);
	const char * VertexSourcePointer = VertexShaderCode.c_str();
	glShaderSource(VertID, 1, &VertexSourcePointer, NULL);
	glCompileShader(VertID);

	// Check Vertex Shader
	glGetShaderiv(VertID, GL_COMPILE_STATUS, &Result);
	glGetShaderiv(VertID, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> VertexShaderErrorMessage;
		VertexShaderErrorMessage.resize(InfoLogLength + 1);

		glGetShaderInfoLog(VertID, InfoLogLength, NULL, &VertexShaderErrorMessage[0]);
		printf("%s\n", &VertexShaderErrorMessage[0]);
	}

	// Compile Fragment Shader
	char const* FragmentSourcePointer = FragmentShaderCode.c_str();
	glShaderSource(FragID, 1, &FragmentSourcePointer, NULL);
	glCompileShader(FragID);

	// Check Fragment Shader
	glGetShaderiv(FragID, GL_COMPILE_STATUS, &Result);
	glGetShaderiv(FragID, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> FragmentShaderErrorMessage;
		FragmentShaderErrorMessage.resize(InfoLogLength + 1);
		glGetShaderInfoLog(FragID, InfoLogLength, NULL, &FragmentShaderErrorMessage[0]);
		printf("%s\n", &FragmentShaderErrorMessage[0]);
	}

	// Link the program
	printf("Linking program\n");
	GL_Handle = glCreateProgram();
	glAttachShader(GL_Handle, VertID);
	glAttachShader(GL_Handle, FragID);
	glLinkProgram(GL_Handle);

	// Check the program
	glGetProgramiv(GL_Handle, GL_LINK_STATUS, &Result);
	glGetProgramiv(GL_Handle, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> ProgramErrorMessage;
		ProgramErrorMessage.resize(InfoLogLength + 1);
		glGetProgramInfoLog(GL_Handle, InfoLogLength, NULL, &ProgramErrorMessage[0]);
		printf("%s\n", &ProgramErrorMessage[0]);
	}

	glDetachShader(GL_Handle, VertID);
	glDetachShader(GL_Handle, FragID);

	glDeleteShader(VertID);
	glDeleteShader(FragID);

	CheckGLERROR();

#else

/*
	enum ShaderType { VERTEX, FRAGMENT, PROGRAM };
  
	VertID = glCreateShader(GL_VERTEX_SHADER);
	FragID = glCreateShader(GL_FRAGMENT_SHADER);

 	const char* vertSource = _vertstring.c_str();
	const char* fragSource = _fragstring.c_str();
 
	

	glShaderSource(VertID, 1, &vertSource, NULL);
	glCompileShader(VertID);
	GetShaderError(Vert);
 
	CheckGLERROR();

	glShaderSource(FragID, 1, &fragSource, NULL);
	glCompileShader(FragID);
	GetShaderError(Frag);
	uint32_t ERR = 0;
	
	CheckGLERROR();

	glAttachShader(GL_Handle, VertID);
	glAttachShader(GL_Handle, FragID);
	glLinkProgram(GL_Handle);
	GetShaderError(Program);

	CheckGLERROR();

	glValidateProgram(GL_Handle);
	glDetachShader(GL_Handle, VertID);
	glDetachShader(GL_Handle, FragID);
	glDeleteShader(VertID);
	glDeleteShader(FragID);

	glUseProgram(GL_Handle);

	CheckGLERROR();

	return;
 */
#endif

 ==================================================================================================================================================================================
            #12/19															  															  
            #Threadpool.h		
            #Reason: Move constructor and Move Assign were never called so they are unneeded
====================================================================================================================================================================================
Perhaps I will want them later because I considered moving the object around but currently managing its Pointer to base has been relatively effective

/*      Possibly not needed but created Move and Assignment Operators just in case.
	NOTE: May remove in the future as neither of these are ever calls and the user is incapable of */
asyncTask(asyncTask&& _other) noexcept
	:
	Function(std::move(_other.Function)),
	Arguments(std::forward<ARGS>(_other.Arguments)),
	ReturnValue(std::move(_other.ReturnValue))
{// This test has shown it never gets called throughout the objects lifetime
	std::cout << "Called the Forward Function" << "\n";
}
asyncTask& operator=(asyncTask&& _other) noexcept
{// Nor does this
	Function = std::move(_other.Function);
	Arguments = std::forward<ARGS>(_other.Arguments);
	ReturnValue = std::move(_other.ReturnValue);
	std::cout << "Called Assignment Operator " << "\n";
}

 ==================================================================================================================================================================================
                                                               #11/28															  															  
															  #Threadpool.cpp/h		
															  #Reason: Unable to access these due to Threadpool managing and owning asyncTask Objects
====================================================================================================================================================================================

This was removed as it appears to not be needed. Try to keep this in mind because it may have been more proper than now current method
// typename std::decay_t<_Func>, typename std::decay_t<ARGS>... > ; //std::invoke_result_t<_Func&, ARGS&...>;




//template<typename _F, typename ...ARGS>
//uint16_t Wrapper<_F, ARGS...>::Offset{ 0 };




				type get()
				{
					Status = Aquired;
					ReturnValue.get();
				}
				bool is_ready()
				{
					return ReturnValue.valid() ? (ReturnValue.wait_for(std::chrono::seconds(0)) == std::future_status::ready) : false;
				}


 ==================================================================================================================================================================================
                                                               #11/28															  															  
															  #Threadpool.cpp/h		
															  #IMPORTANT
															  #Reason: Cleanup of experimental Threadpool and Worker class
====================================================================================================================================================================================


include<iostream>
#include<Windows.h>
#pragma optimize( "", off )

#define MY_WRAPPER
#define _PROFILE_MEMORY

#include"Profiling\SystemInfo.h"
#include"Profiling\MemoryPerf\MemTracker.h"
#include"Core\Threading\Threadpool.h"
#include"Profiling\Timing\Benchmark.h"

#include"Core\Common.h"

using namespace Core;
using namespace Threading;
//#define LOOP_COUNT 100
int LOOP_COUNT = 10000;
#include<string>
/*
Physics Solver:    https://www.gdcvault.com/play/1013359/High-Performance-Physics-Solver-Design
*/

/*
template <class F, class Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& t);
*/


void  P0R0()
{
	std::cout << "P0R0" << "\n";
}
float P1R1(int _param)
{
	std::cout << "P1R1: " << _param << "\n";
	return static_cast<float>(_param * _param);
}
void  P1R0(int _param)
{
	std::cout << "P1R0:" << _param << "\n";
}
void  P2R0(int _param, int _param2)
{
	std::cout << "P1R0:" << _param << ":" << _param2 << "\n";
}
int   P0R1()
{
	std::cout << "P0R1" << "\n";
	return 42;
}

//void operator()(_Func&& _function, _Args&&..._args)
//{
//	return _function(_args...);
//}



/*
struct A { int x; int y; int z; };
A a{.y = 2, .x = 1}; // error; designator order does not match declaration order
A b{.x = 1, .z = 2}; // ok, b.y initialized to 0


		_Ret operator()(_Args&&..._args)
		{
			return FuncStorage(_args...);
		}
*/

/// aggregate in C++17/*
/*
			auto A = new(alloca(sizeof(Wrapper<decltype(TestFunctionE), int>))) Wrapper(TestFunctionE, std::move(LOOP_COUNT));
			auto B = alloca(Wrapper(TestFunctionB, 1431);
			auto C = alloca(Wrapper(TestFunctionD, 123.321f, 10);
			auto D = alloca(Wrapper(TestFunctionA);
			auto E = alloca(Wrapper(TestFunctionC, 3.14159f, 123);
			auto F = alloca(Wrapper(TestFunctionF, std::move(LOOP_COUNT));
			auto G = alloca(Wrapper(TestFunctionG, std::move(LOOP_COUNT));
			auto H = alloca(Wrapper(TestFunctionH, std::move(LOOP_COUNT));
			auto I = alloca(Wrapper(TestFunctionI, std::move(LOOP_COUNT));
			auto J = alloca(Wrapper(TestFunctionJ, std::move(LOOP_COUNT));
			auto K = alloca(Wrapper([](int)->int { Print("Lambda Function Threadpool call"); return 11; }, 10000);


*/

OPTIMIZATION_OFF()
/*

(alloca(sizeof(Wrapper<decltype(TestFunctionE), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionB), int >)))
(alloca(sizeof(Wrapper<decltype(TestFunctionD),float,int >)))
(alloca(sizeof(Wrapper<decltype(TestFunctionA)  >)))
(alloca(sizeof(Wrapper<decltype(TestFunctionC),float,int >)))
(alloca(sizeof(Wrapper<decltype(TestFunctionF), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionG), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionH), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionI), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionJ), int>)))

*/
#define NUMBER_OF_THREADS 2000
int main()
{/* Open STD http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3857.pdf */
	ThreadPool::get();

#ifdef MY_WRAPPER
	while (true)
	{
		//alloca()
		Function_Counter = 0;
		LOOP_COUNT += 1000;// 22100 is when Threadpool and Linear start to become one.
		Print("\n\n\n\n Loop Counter:" << LOOP_COUNT << " iterations in the Worker Functions\n");

		Profiling::Timing::Profile_Timer<100> Bench;
		{
			std::vector<std::vector<uint32_t>> Test;

			///      auto L = new auto A = new asyncTask(TestFunctionE, std::move(LOOP_COUNT));
			auto Af = Core::Threading::ThreadPool::get().Async([] {int ret = 10; return ret; });

			auto A = ThreadPool::get().Async(TestFunctionE, std::move(LOOP_COUNT));
			auto B = ThreadPool::get().Async(TestFunctionE, std::move(LOOP_COUNT));
			auto C = ThreadPool::get().Async(TestFunctionB, 1431);
			auto D = ThreadPool::get().Async(TestFunctionD, 123.321f, 10);
			auto E = ThreadPool::get().Async(TestFunctionA);
			auto F = ThreadPool::get().Async(TestFunctionC, 3.14159f, 123);
			auto G = ThreadPool::get().Async(TestFunctionF, std::move(LOOP_COUNT));
			auto H = ThreadPool::get().Async(TestFunctionG, std::move(LOOP_COUNT));
			auto I = ThreadPool::get().Async(TestFunctionH, std::move(LOOP_COUNT));
			auto J = ThreadPool::get().Async(TestFunctionI, std::move(LOOP_COUNT));
			auto K = ThreadPool::get().Async(TestFunctionJ, std::move(LOOP_COUNT));

//new asyncTask(TestFunctionB, 1431);
//new asyncTask(TestFunctionD, 123.321f, 10);
//new asyncTask(TestFunctionA);
//new asyncTask(TestFunctionC, 3.14159f, 123);
//new asyncTask(TestFunctionF, std::move(LOOP_COUNT));
//new asyncTask(TestFunctionG, std::move(LOOP_COUNT));
//new asyncTask(TestFunctionH, std::move(LOOP_COUNT));
//new asyncTask(TestFunctionI, std::move(LOOP_COUNT));     auto  TPTest5 = ThreadPool::get().Async(A);
//new asyncTask(TestFunctionJ, std::move(LOOP_COUNT));     auto  TPTest1 = ThreadPool::get().Async(B);
//new asyncTask([](int)->int { Print("Lambda Function Threadpool call"); return 11; }, 10000);     auto  TPTest4 = ThreadPool::get().Async(C);
//new asyncTask(TestFunctionLarge, (uint64_t)(rand() % 1000), (uint64_t)(rand() % 1000), (uint64_t)(rand() % 1000), (uint64_t)(rand() % 1000), (uint64_t)(rand() % 1000));     auto  TPTest3 = ThreadPool::get().Async(D);
  
// auto  TPTest2 = ThreadPool::get().Async(E);
// auto  TPTest6 = ThreadPool::get().Async(F);
// auto  TPTest7 = ThreadPool::get().Async(G);
// auto  TPTest8 = ThreadPool::get().Async(H);
// auto  TPTest9 = ThreadPool::get().Async(I);
// auto TPTest10 = ThreadPool::get().Async(J);
// auto TPTest11 = ThreadPool::get().Async(K);
     
		//	ThreadPool::get().Async(TestFunctionE, std::move(LOOP_COUNT));
			//Sleep(5);
			Print("Thread Pool Cluster");

			std::vector<std::future<float>> Fut;
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				auto F = ThreadPool::get().Async(TestFunctionC, 123.321f, std::move(i));
				Fut.push_back(std::forward<std::future<float>>(F));
			}	

			uint64_t result{ 0 };
			int counter = Fut.size();
			int C2{ 0 }, C3{ 0 };
//for (auto& G : Fut)
//{
//	result += G.get();
//	GotFuture--;
//}
			while (counter)
			{
				for (auto& F : Fut)
				{
					if (!is_ready(F))
					{/* if not ready yet, check the next */
						++C2;
						continue;
					}
					result += F.get(); /* it is ready */
					//Print("Result: " << result);
					++C3;
					--counter;
				}
			}

			Print("End Thread Pool Cluster: " << result);

//   Test.push_back(TPTest6.get());
//   Test.push_back(TPTest7.get());
//   Test.push_back(TPTest8.get());
//   Test.push_back(TPTest9.get());
//   Test.push_back(TPTest10.get());

			while (Function_Counter < 10) {/* SpinLock until every single function called returns as measured via the atomic int Function_Counter. */ }

		 	Print("Threadpool: " << result);
		 	//Print("ThreadPool: " << TPTest4.get() << " : " << TestCompile(Test));
///
///		//	delete A; delete B; delete C; delete D; delete E; delete F; delete G; delete H; delete I; delete J;
///		//	delete K;
///
 			Bench.Stop();
		}
 
		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> ThreadBM;
		{
			auto  TPTest5T = std::async(std::launch::async | std::launch::deferred, TestFunctionE, LOOP_COUNT);
			auto  TPTest1T = std::async(std::launch::async | std::launch::deferred, TestFunctionB, 1431);
			auto  TPTest4T = std::async(std::launch::async | std::launch::deferred, TestFunctionD, 123.321f, 10);
			auto  TPTest3T = std::async(std::launch::async | std::launch::deferred, TestFunctionA);
			auto  TPTest2T = std::async(std::launch::async | std::launch::deferred, TestFunctionC, 3.14159f, 123);
			auto  TPTest6T = std::async(std::launch::async | std::launch::deferred, TestFunctionF, LOOP_COUNT);
			auto  TPTest7T = std::async(std::launch::async | std::launch::deferred, TestFunctionG, LOOP_COUNT);
			auto  TPTest8T = std::async(std::launch::async | std::launch::deferred, TestFunctionH, LOOP_COUNT);
			auto  TPTest9T = std::async(std::launch::async | std::launch::deferred, TestFunctionI, LOOP_COUNT);
			auto TPTest10T = std::async(std::launch::async | std::launch::deferred, TestFunctionJ, LOOP_COUNT);
			auto TPTest11T = new  asyncTask([](int)->int { Print("Lambda Function Call std::Async"); return 11; }, 10000);

			Print("Async Cluster");
			std::vector<std::future<float>> Fut;
	        for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
	        {
	        	auto TPTest4loop = std::async(std::launch::async, TestFunctionC, 123.321f, i);
				Fut.push_back(std::move(TPTest4loop));
	        }	
			Print("End Async Cluster");


			uint64_t result{ 0 };
			int counter = Fut.size();
			while (counter)
			{
				for (auto& F : Fut)
				{
					if (!is_ready(F))
					{// if not ready yet, check the next  
						continue;
					}
					result += F.get(); // it is ready 
					--counter;
				}
			}
			Print("Async :" << result);
			while (Function_Counter < 10) {// SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
 }
			std::vector<std::vector<uint32_t>> Test;

			Test.push_back(TPTest5T.get());
			Test.push_back(TPTest6T.get());
			Test.push_back(TPTest7T.get());
			Test.push_back(TPTest8T.get());
			Test.push_back(TPTest9T.get());
			Test.push_back(TPTest10T.get());
			Print("Async: " << TPTest4T.get() << " : " << TestCompile(Test));

			ThreadBM.Stop();
		}


		uint64_t  results;
		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> LBench;
		{
			auto Test5 = TestFunctionE(std::move(LOOP_COUNT));// .5ms
			auto Test4 = TestFunctionD(123.321f, 10);
			auto Test1 = TestFunctionB(1431);
			auto Test3 = TestFunctionA();
			auto Test2 = TestFunctionC(3.14159f, 123);
			auto Test6 = TestFunctionF(std::move(LOOP_COUNT));//.3
			auto Test7 = TestFunctionG(std::move(LOOP_COUNT));//3.21
			auto Test8 = TestFunctionH(std::move(LOOP_COUNT));// .32
			auto Test9 = TestFunctionI(std::move(LOOP_COUNT));//2.8
			auto Test10 = TestFunctionJ(std::move(LOOP_COUNT));//2.6
			auto Test11 = [](int)->int { Print("Lambda Function Linear call"); return 11; };


			while (Function_Counter > 10) {// SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
			}

			uint64_t result{ 0 };
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				result += TestFunctionC( 123.321f, rand()% NUMBER_OF_THREADS);
			}
			Print("Linear :" << result);
			

			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(Test5);
			Test.push_back(Test6);
			Test.push_back(Test7);
			Test.push_back(Test8);
			Test.push_back(Test9);
			Test.push_back(Test10);
			Print("Linear: " << Test4 << " : " << TestCompile(Test));

			LBench.Stop();
		}

		std::cout << " Straight Linear = " << LBench.Results / 1000.0f << " ms" << "\n";//0.020034
		std::cout << "     Thread Pool = " << Bench.Results / 1000.0f << " ms" << "\n";
		std::cout << "      std::async = " << ThreadBM.Results / 1000.0f << " ms" << "\n";//0.020034
		Sleep(1500);
	}
#else

	while (true)
	{
		//LOOP_COUNT += 1000; // 23000 is where Linear = using Thread pool or Async
		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> Bench;
		{
			auto  TPTest5 = ThreadPool::get().Async(TestFunctionE, LOOP_COUNT);
			auto  TPTest1 = ThreadPool::get().Async(TestFunctionB, 1431);
			auto  TPTest4 = ThreadPool::get().Async(TestFunctionD, 123.321f, 10);
			auto  TPTest3 = ThreadPool::get().Async(TestFunctionA);
			auto  TPTest2 = ThreadPool::get().Async(TestFunctionC, 3.14159f, 123);
			auto  TPTest6 = ThreadPool::get().Async(TestFunctionF, LOOP_COUNT);
			auto  TPTest7 = ThreadPool::get().Async(TestFunctionG, LOOP_COUNT);
			auto  TPTest8 = ThreadPool::get().Async(TestFunctionH, LOOP_COUNT);
			auto  TPTest9 = ThreadPool::get().Async(TestFunctionI, LOOP_COUNT);
			auto TPTest10 = ThreadPool::get().Async(TestFunctionJ, LOOP_COUNT);

			std::vector<std::future<float>> Fut;
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				auto  TPTest4loop = ThreadPool::get().Async(TestFunctionC, 123.321f, std::move(i));// (alloca(sizeof(Wrapper<decltype(TestFunctionC), float, int >))) 
				Fut.push_back(std::forward<std::future<float>>(TPTest4loop));
			}

			uint64_t result{ 0 };
			int counter = Fut.size();
			int C2{ 0 }, C3{ 0 };
			while (counter)
			{
				for (auto& F : Fut)
				{
					if (!is_ready(F))
					{//* if not ready yet, check the next 
						++C2;
						continue;
					}
					result += F.get(); //* it is ready 
					++C3;
					--counter;
				}
			}
			while (Function_Counter < 10) {//* SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
 }
		
			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(TPTest5.get());
			Test.push_back(TPTest6.get());
			Test.push_back(TPTest7.get());
			Test.push_back(TPTest8.get());
			Test.push_back(TPTest9.get());
			Test.push_back(TPTest10.get());

			Print("ThreadPool: " << TPTest4.get() << " : " << TestCompile(Test));
			Bench.Stop();
		}


		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> ThreadBM;
		{
			auto  TPTest5T = std::async(TestFunctionE, LOOP_COUNT);
			auto  TPTest1T = std::async(TestFunctionB, 1431);
			auto  TPTest4T = std::async(TestFunctionD, 123.321f, 10);
			auto  TPTest3T = std::async(TestFunctionA);
			auto  TPTest2T = std::async(TestFunctionC, 3.14159f, 123);
			auto  TPTest6T = std::async(TestFunctionF, LOOP_COUNT);
			auto  TPTest7T = std::async(TestFunctionG, LOOP_COUNT);
			auto  TPTest8T = std::async(TestFunctionH, LOOP_COUNT);
			auto  TPTest9T = std::async(TestFunctionI, LOOP_COUNT);
			auto TPTest10T = std::async(TestFunctionJ, LOOP_COUNT);


			Print("Async Cluster");
			std::vector<std::future<float>> Fut;
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				auto  TPTest4loop = std::async(std::launch::async, TestFunctionC, 123.321f, i);
				Fut.push_back(std::move(TPTest4loop));
			}
			uint64_t result{ 0 };
			int counter = Fut.size();
			while (counter)
			{
				for (auto& F : Fut)
				{
					if (!is_ready(F))
					{// if not ready yet, check the next 
						continue;
					}
					result += F.get(); // it is ready 
					--counter;
				}
			}
			Print("Async :" << result);
			Print("End Async Cluster");


			while (Function_Counter < 10) {// SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
			}

			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(TPTest5T.get());
			Test.push_back(TPTest6T.get());
			Test.push_back(TPTest7T.get());
			Test.push_back(TPTest8T.get());
			Test.push_back(TPTest9T.get());
			Test.push_back(TPTest10T.get());
			Print("Async: " << TPTest4T.get() << " : " << TestCompile(Test));


			ThreadBM.Stop();
		}

		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> LBench;
		{
			auto Test5 = TestFunctionE(LOOP_COUNT);
			auto Test1 = TestFunctionB(1431);
			auto Test4 = TestFunctionD(123.321f, 10);
			auto Test3 = TestFunctionA();
			auto Test2 = TestFunctionC(3.14159f, 123);
			auto Test6 = TestFunctionF(LOOP_COUNT);
			auto Test7 = TestFunctionG(LOOP_COUNT);
			auto Test8 = TestFunctionH(LOOP_COUNT);
			auto Test9 = TestFunctionI(LOOP_COUNT);
			auto Test10 = TestFunctionJ(LOOP_COUNT);

			std::vector<float> Fut;
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				auto  TPTest4loop = TestFunctionC(123.321f, i);
				Fut.push_back(std::move(TPTest4loop));
			}
			uint64_t result{ 0 };
			int counter = Fut.size();
			while (counter)
			{
				for (auto& F : Fut)
				{
					result += F; // it is ready 
					--counter;
				}
			}
			Print("Linear Result: " << result);
			while (Function_Counter < 10) {//* SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
			}


			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(Test5);
			Test.push_back(Test6);
			Test.push_back(Test7);
			Test.push_back(Test8);
			Test.push_back(Test9);
			Test.push_back(Test10);
			Print("Linear: " << Test4 << " : " << TestCompile(Test));
			LBench.Stop();
		}
		//std::vector<Wrapper_Base*> FunctionList;

		Function_Counter = 0;

		Profiling::Timing::Profile_Timer<100> WrapperBenchmark;
		{

			//  FunctionList.emplace_back(new Wrapper(TestFunctionE, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionB, 1431));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionD, 123.321f, 10));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionA));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionC, 3.14159f, 123));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionF, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionG, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionH, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionI, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionJ, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper([](int)->int { Print("Lambda Function Function List calls"); return 11; }, 10000));

			//for (auto& F : FunctionList)
			//{
			//	F->Invoke();
			//}
			WrapperBenchmark.Stop();
		}
 
	//	std::cout << "  Wrapper Linear = " << WrapperBenchmark.Results / 1000.f << " ms" << "\n"; // 0.020808  Difference of .000774
	//	std::cout << " Straight Linear = " << LBench.Results / 1000.f << " ms" << "\n";//0.020034
		std::cout << "     Thread Pool = " << Bench.Results / 1000.f << " ms" << "\n";
	//	std::cout << "      std::async = " << ThreadBM.Results / 1000.f << " ms" << "\n";//0.020034
		Sleep(1500);
	}
#endif

	//	Profiling::Memory::TrackDumpBlocks();
	//	Profiling::Memory::TrackListMemoryUsage();
	return 0;
}
OPTIMIZATION_ON()



#THREADPOOL.CPP


#include"Threadpool.h"

#pragma warning( push )
#pragma warning( disable : 4244 )
#pragma warning( disable : 4018 ) // Optimization off warning of mine

///template<typename _F,typename ...ARGS>
///void* Wrapper<_F,ARGS...>::MemoryBlock;
///

std::atomic<uint32_t> Create{ 0 };
std::atomic<uint32_t> Delete{ 0 };
std::atomic<uint32_t> GotFuture{ 0 };
//template<typename _F, typename ...ARGS>
//uint16_t Wrapper<_F, ARGS...>::Offset{ 0 };

/*

https://www.youtube.com/watch?v=zULU6Hhp42w&list=PLl8Qc2oUMko_FMAaK7WY4ly0ikLFrYCE3&index=4

*/
#define SLEEP_TIME 0
std::atomic<int> Function_Counter{ 0 };

#ifdef MY_WRAPPER

namespace Core
{
	namespace Threading
	{
		bool JobQueue::Try_Pop(Worker_Function*& func)
		{/* Try to aquire a function off the Queue to run */
			std::unique_lock<std::mutex> Lock{ QueueMutex, std::try_to_lock };
			if (!Lock || TaskQueue.empty())
			{
				return false;
			}
			func = TaskQueue.front();//std::forward(TaskQueue.front());// std::move(
		 	TaskQueue.pop_front();
			return true;
		}

		bool JobQueue::pop(Worker_Function*& func)
		{
			std::unique_lock<std::mutex> Lock{ QueueMutex };
			while (TaskQueue.empty() && !is_Done)
			{
				is_Ready.wait(Lock);
			}
			if (TaskQueue.empty())
			{
				return false;
			}
			func = std::move(TaskQueue.front());
			TaskQueue.pop_front();
			return true;
		}

		void JobQueue::Done()
		{
			{
				std::unique_lock<std::mutex> Lock{ QueueMutex };
				is_Done = true;
			}
			is_Ready.notify_all();
		}

		ThreadPool::ThreadPool()
		{
			for (int N{ 0 }; N < ThreadCount; ++N)
			{
				Worker_Threads.emplace_back([&, N] {Run(N); });
			}
		}
		ThreadPool::~ThreadPool()
		{
			for (auto& Q : ThreadQueue)
			{
				Q.Done();
			}
			for (auto& WT : Worker_Threads)
			{
				WT.join();
			}
		}

		void ThreadPool::Run(unsigned int _i)
		{
			while (true)
			{
				Worker_Function* Func{ nullptr }; 
				for (unsigned int N{ 0 }; N != ThreadCount; ++N)
				{
					if (ThreadQueue[static_cast<size_t>((_i + N) % ThreadCount)].Try_Pop(Func))
					{
						break;
					}
				}
				if (!Func && !ThreadQueue[_i].pop(Func)) 
				{
					break; // Possibly need this to be a continue
				}
				//Print("Before: " << Func);
				Func->Invoke();

				/// If this is deleted before the future is gotten an error is thrown stating the Future has been aquired multiple times.
			 	delete &(*Func);
				++Delete;
				//Func = nullptr;
				
				//Print("After: " << Func);

			}
		}
	}// End NS Threading
}// End NS Core

#else
namespace Core
{
	namespace Threading
	{

		bool JobQueue::Try_Pop(Worker_Function& func)
		{/* Try to aquire a function off the Queue to run */
			std::unique_lock<std::mutex> Lock{ QueueMutex, std::try_to_lock };
			if (!Lock || TaskQueue.empty())
			{
				return false;
			}
			/// Something is wrong here. Will lock if the pop is performed here
			func = std::move(TaskQueue.front());
			TaskQueue.pop_front();
			return true;
		}
		bool JobQueue::pop(Worker_Function& func)
		{
			std::unique_lock<std::mutex> Lock{ QueueMutex };
			while (TaskQueue.empty() && !is_Done)
			{
				is_Ready.wait(Lock);
			}
			if (TaskQueue.empty())
			{
				return false;
			}
			func = std::move(TaskQueue.front());//std::forward(TaskQueue.front());// std::move(
			TaskQueue.pop_front();
			return true;
		}

		void JobQueue::Done()
		{
			{
				std::unique_lock<std::mutex> Lock{ QueueMutex };
				is_Done = true;
			}
			is_Ready.notify_all();
		}

		ThreadPool::ThreadPool()
		{
			for (int N{ 0 }; N < ThreadCount; ++N)
			{
				Worker_Threads.emplace_back([&, N] {Run(N); });
			}
		}
		ThreadPool::~ThreadPool()
		{
			for (auto& Q : ThreadQueue)
			{
				Q.Done();
			}
			for (auto& WT : Worker_Threads)
			{
				WT.join();
			}
		}
		// { nullptr };// = new Wrapper_Base();
		void ThreadPool::Run(unsigned int _i)
		{
			while (true)
			{
				Worker_Function Func;
				bool Popped{ false };
				for (unsigned int N{ 0 }; N != ThreadCount; ++N)
				{
					if (ThreadQueue[static_cast<size_t>((_i + N) % ThreadCount)].Try_Pop(Func))
					{
						Popped = true; // This finally fixes the bad function call because if Try_Pop removes item from queue it still gets ran.
						break;
					}
				}
				if (!Popped && !ThreadQueue[_i].pop(Func))//!Func && 
				{
					break; // Possibly need this to be a continue
				}
				Func();
			}
		}
	}// End NS Threading
}// End NS Core
#endif









#include<iostream>
#include<string>

#pragma optimize( "", off )
/* unoptimized code section */
#define Worker_Print(x) //std::cout << x << " : "


OPTIMIZATION_OFF()
void TestFunction(int _count, int _output)
{
	int result{ 0 };
	for (int i{ 0 }; i < _count; ++i)
	{
		result++;
		result += std::pow(result, _output);
	}
	std::cout << "PARAM:" << _output << "Finished Work: " << result << "\n";
}
OPTIMIZATION_ON()


OPTIMIZATION_OFF()
int TestFunctionA()
{
	Worker_Print( "FunctionA");
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return 11;
}
OPTIMIZATION_ON()


OPTIMIZATION_OFF()
int TestFunctionB(int _param)
{
	int result;
	Worker_Print("FunctionB: " << _param) ;
	//result.set_value(10);
	result = _param * 2;
	Sleep(SLEEP_TIME);
++Function_Counter;
	return result;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
float TestFunctionC(float _paramA, int _paramB)
{
	Worker_Print("FunctionC: " << _paramA << " : " << _paramB );
	//Print("FuncC Param is " << _paramB << " : ");

	Sleep(SLEEP_TIME);
	++Function_Counter;
	return _paramA * _paramB * (rand() % 1000);
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::string TestFunctionD(float _paramA, int _paramB)
{
	Worker_Print("FunctionD " << _paramA << " : " << _paramB );
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return "String: " + std::to_string(_paramA) + " : " + std::to_string(_paramB);
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionE(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;

	uint64_t result{ 0 };
	for (int i{ 0 }; i < _paramA; ++i)
	{
		//	std::cout << "E: " << i*i ;
		result += i * i;
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionF(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	uint64_t result{ 0 };
	for (int i{ 0 }; i < _paramA; ++i)
	{
		double A = sqrt(i*i);
		//		std::cout << "F: " << A ;
		result += _paramA * i + A;
		SomethingAllocated.push_back(result);
	}	
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()


OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionG(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	uint64_t result{ 0 };
	int B = rand() % _paramA;
	int C{ 0 };

	for (int i{ 0 }; i < _paramA; ++i)
	{
		double A = sqrt(i*i);
		//		std::cout << "G: " << A ;
		result += (_paramA * i) / pow(A, i);
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionH(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	double A{ 0 };
	uint64_t result{ 0 };
	int B = rand() % _paramA;
	int C{ 0 };

	for (int i{ 0 }; i < _paramA; ++i)
	{
		A = sqrt(i*i);
	    Worker_Print( "H: " << A );
		result += i * A;
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionI(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	uint64_t A{ 0 };

	int B = rand() % _paramA;
	int C{ 0 };

	for (int i{ 0 }; i < _paramA; ++i)
	{
		A = pow(_paramA, i);
		if (!((i+1) % (B+1)))C += A;
		Worker_Print( "I: " << A );	
		uint32_t result = A * C;
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionJ(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	float A = 0;
	int B = rand() % _paramA;
	int C{ 0 };
	for (int i{ 0 }; i < _paramA; ++i)
	{
		A = pow(i, _paramA) / i;
		if (A == B)C = i;
		Worker_Print("J: " << A << ":");
		uint32_t result = A * C;
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
uint64_t Worker_TestFunction(size_t _count)
{
	int B = rand() % _count;
	int C{ 0 };
	for(uint32_t i{0}; i< _count; ++i)
	{
		std::cout << i << ":";
		if (!((i+1) % (B+1)))C++;
	}
	return _count * C;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
uint64_t TestCompile(std::vector<std::vector<uint32_t>> _input)
{
	uint64_t result{ 0 };
	for (auto& Y : _input)
	{
		for (auto& X : Y)
		{
			result += X;
		}
	}
	return result;
}
OPTIMIZATION_ON()
OPTIMIZATION_OFF()

uint64_t TestFunctionLarge(uint64_t _p1, uint64_t _p2, uint64_t _p3, uint64_t _p4, uint64_t _p5)
{
	uint64_t result = _p1 + _p2 +_p3 +_p4 + _p5;
	Print(result);
	return result;
}

OPTIMIZATION_ON()

#pragma warning( pop )

/*NOTES:

Intel Game Engine Design:
https://software.intel.com/en-us/articles/designing-the-framework-of-a-parallel-game-engine

Faster STD::FUNCTION Implementation
https://github.com/skarupke/std_function/blob/master/function.h


Lock Free Ring Buffer
https://github.com/tempesta-tech/blog/blob/master/lockfree_rb_q.cc

Lock-Free Programming
https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf

A Fast Lock-Free Queue for C++
http://moodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++

Introduction to Multithreaded Algorithms
http://ccom.uprrp.edu/~ikoutis/classes/algorithms_12/Lectures/MultithreadedAlgorithmsApril23-2012.pdf

A Thread Pool with C++11
http://progsch.net/wordpress/?p=81

Parallelizing the Naughty Dog Engine
https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine

C++11 threads, affinity and hyperthreading
https://eli.thegreenplace.net/2016/c11-threads-affinity-and-hyperthreading/

Thread pool worker implementation
https://codereview.stackexchange.com/questions/60363/thread-pool-worker-implementation

Thread pool implementation using c++11 threads
https://github.com/mtrebi/thread-pool

C++11 Multithreading  Part 8: std::future , std::promise and Returning values from Thread
https://thispointer.com/c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/


CppCon 2015: Fedor Pikus PART 2 Live Lock-Free or Deadlock (Practical Lock-free Programming) 
Queue
https://www.youtube.com/watch?v=1obZeHnAwz4&t=3055s


Thread Pool Implementation on Github:
https://github.com/mtrebi/thread-pool/blob/master/README.md#queue

Threadpool with documentation:
https://www.reddit.com/r/cpp/comments/9lvji0/c_threadpool_with_documentation/

Original White paper on Work stealing Queues:
http://supertech.csail.mit.edu/papers/steal.pdf

Code overview - Thread Pool & Job System
https://www.youtube.com/watch?v=Df-6ws_EZno

while(running)
{
    Try to Lock and return True or False
	True:
	False: Push it to 
}
*/


##HEADER


#pragma once
#include <thread>
#include <functional>
#include <future>
#include <deque>
#include <queue>
#include <array>
#include <tuple>

#include<Windows.h>
#include"Core\Common.h"
#include<iostream>

#pragma warning( push )
#pragma warning( disable : 4244 )
#pragma warning( disable : 4018 ) // Optimization off warning of mine

#define BLOCK_SIZE    1024 * 100
#define MY_WRAPPER

static void* Wrap_MemoryBlock = malloc(BLOCK_SIZE * sizeof(char)); // nullptr;
static uint16_t  Wrap_Offset{ 0 };


extern std::atomic<uint32_t> Create;
extern std::atomic<uint32_t> Delete;
extern std::atomic<uint32_t> GotFuture;


/* Non-blocking test of std::future to see if value is avalible yet */
template<typename R>
bool is_ready(std::future<R> const& f)
{
	return f.valid() ? f.wait_for(std::chrono::seconds(0)) == std::future_status::ready : false;
}

/// template<typename Function, typename ...Args>
/// result_type = std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>;

extern std::atomic<int> Function_Counter;
//https://code.woboq.org/llvm/libcxx/include/type_traits.html

/// Use this switch with Compiler Explorer inorder to allow it to compile: -std=c++17 -O3
// MSVC Threadpool implementation for Concurrency
// https://docs.microsoft.com/en-us/cpp/parallel/concrt/task-scheduler-concurrency-runtime?view=vs-2019
#ifdef MY_WRAPPER

struct Wrapper_Base
{/// __declspec(novtable) USE THIS
	virtual ~Wrapper_Base() {
	}//Print("Base");

	virtual void Invoke() = 0;
	void operator()() 
	{
		Invoke();
	}
	/* Implement a Then, When_all and Deferred Function handling */


	enum asyncStatus
	{
		Valid, Waiting, Busy, Submitted, Ready, Aquired
	};

	asyncStatus Status;
};

template<typename _Func, typename ...ARGS>
struct asyncTask
	: public Wrapper_Base
{
	using type = std::invoke_result_t<std::decay_t<_Func&>, std::decay_t<ARGS>...>;
	using reference_type = type&;
	using Fptr = type(*)(ARGS...);

	Fptr Function;
	std::tuple<ARGS...> Arguments;
	std::promise<type> ReturnValue;

	int RefCount{ 0 };
	asyncTask(_Func&& _function, ARGS&&... _args) noexcept
		:
		Function(std::move(_function)),
		Arguments(std::forward<ARGS>(_args)...)
	{
		Status = Valid;
	}
	virtual ~asyncTask() {  }//Print("Derived Destruct");

	asyncTask(asyncTask&& _other) noexcept
		:
		Function(std::move(_other.Function)),
		Arguments(std::forward<ARGS>(_other.Arguments)),
		ReturnValue(std::move(_other.ReturnValue))
	{
		std::cout << "Called the Forward Function" << "\n";
	}
	asyncTask& operator=(asyncTask&& _other) noexcept
	{
		Function = std::move(_other.Function);
		Arguments = std::forward<ARGS>(_other.Arguments);
		ReturnValue = std::move(_other.ReturnValue);
		std::cout << "Called Assignment Operator " << "\n";
	}

	virtual void Invoke()  override
	{
		 Status = Busy;
		 auto result = std::apply(Function, Arguments);
  		 ReturnValue.set_value(result);
		 Status = Waiting;
	}

	std::future<type> get_future()
	{
		Status = Submitted;
		++Create;
		GotFuture++;
		RefCount++;
		return ReturnValue.get_future();
	}

	type get()
	{
		Status = Aquired;
		ReturnValue.get();
	}

	bool is_ready()
	{
		return ReturnValue.valid() ? (ReturnValue.wait_for(std::chrono::seconds(0)) == std::future_status::ready) : false;
	}
	asyncTask(const asyncTask&) = delete;
	asyncTask& operator=(const asyncTask& _other) = delete;
};


  typedef Wrapper_Base Worker_Function;


// NOTE: https://riptutorial.com/cplusplus/example/15806/create-a-simple-thread-pool
namespace Core
{
	namespace Threading
	{

		struct JobQueue
		{
		public:
			JobQueue() = default;

			std::condition_variable is_Ready;
			std::mutex QueueMutex;
			bool is_Done{ false };
			void Done();

			std::deque<Worker_Function*> TaskQueue;

			bool Try_Pop(Worker_Function*& func);
			bool pop(Worker_Function*& func);

			bool try_push(Worker_Function *func)
			{
				{
					std::unique_lock<std::mutex> Lock{ QueueMutex, std::try_to_lock };
					if (!Lock)
					{/* If our mutex is already locked simply return */
						return false;
					}
					/* Else place on the back of our Queue*/
					TaskQueue.push_back(std::move(func));//(func));std::move<_FUNC>
				}/* Unlock the Mutex */
				is_Ready.notify_one(); /* Tell the world about it */
				return true;/* Lets Async know u*/
			}
			void push(Worker_Function* func)
			{/* Adds a Function to our Queue */
				{
					std::unique_lock<std::mutex> Lock{ QueueMutex };
					TaskQueue.emplace_back(std::move(func));//std::move<_FUNC> std::forward<_FUNC&>(&((Worker_Function *)
				}
			}
		};

		class ThreadPool
		{
			const unsigned int ThreadCount{  std::thread::hardware_concurrency() * 3};
			std::vector<std::thread> Worker_Threads;
			std::vector<JobQueue> ThreadQueue{ ThreadCount };
			std::atomic<unsigned int> Index{ 0 };

			ThreadPool();
			~ThreadPool();

			void Run(unsigned int _i);

		public:

			static ThreadPool &get()
			{
				static ThreadPool instance;
				return instance;
			}

			template<typename _FUNC, typename...ARGS >
			auto Async(_FUNC&& _func, ARGS&&... args)->std::future<typename asyncTask<_FUNC, ARGS... >::type> //Wrapper_Base::future<typename  Wrapper<_FUNC, ARGS... >::type>
			{// Accept arbitrary Function signature and arguments
				auto _function = new asyncTask<_FUNC, ARGS... >(std::move(_func), std::forward<ARGS>( args)...);
				auto result = _function->get_future();
				
				auto i = Index++;
				int K = 1;
				for (unsigned int n{ 0 }; n != ThreadCount * K; ++n) // K is Tunable 
				{
					if (ThreadQueue[static_cast<size_t>((i + n) % ThreadCount)].try_push(static_cast<Worker_Function*>(_function)))
					{
						
						return result;
					}
				}

				ThreadQueue[i % ThreadCount].push(static_cast<Worker_Function*>(_function));
				return result;
			}
			///===================================================================================================================================================================

		};
	}// End NS Threading
}// End NS Core 

			///===================================================================================================================================================================
			///     template<typename _FUNC, typename...ARGS >
			///     auto Async(asyncTask<_FUNC, ARGS... >  *_function)->std::future<typename asyncTask<_FUNC, ARGS... >::type> //Wrapper_Base::future<typename  Wrapper<_FUNC, ARGS... >::type>
			///     {// Accept arbitrary Function signature and arguments
			///     	auto i = Index++;
			///     	int K = 1;
			///     	for (unsigned int n{ 0 }; n != ThreadCount * K; ++n) // K is Tunable 
			///     	{
			///     		if (ThreadQueue[static_cast<size_t>((i + n) % ThreadCount)].try_push(static_cast<Worker_Function*>(_function)))
			///     		{
			///     			return _function->get_future();
			///     		}
			///     	}
			///     
			///     	ThreadQueue[i % ThreadCount].push(static_cast<Worker_Function*>(_function));
			///     
			///     	return _function->get_future();
			///     }
			///================================= EXPERIMENTAL ====================================================================================================================



#else


/// template<typename Function, typename ...Args>
/// result_type = std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>;
			// class _RET = std::result_of_t<_FUNC>,class _RET =std::result_of_t<_FUNC()>, 

 //_FUNC&& _func, ARGS&&...args)->std::future<decltype(_func(args...))>//  //

extern std::atomic<int> Function_Counter;
//https://code.woboq.org/llvm/libcxx/include/type_traits.html


typedef std::function<void()> Worker_Function;



// NOTE: https://riptutorial.com/cplusplus/example/15806/create-a-simple-thread-pool
namespace Core
{
	namespace Threading
	{

		struct JobQueue
		{
		public:
			JobQueue() = default;

			std::condition_variable is_Ready;
			std::mutex QueueMutex;
			bool is_Done{ false };
			void Done();


			std::deque<Worker_Function> TaskQueue;

			bool Try_Pop(Worker_Function& func);
			bool pop(Worker_Function& func);
			template<typename _FUNC> bool try_push(_FUNC&& func)
			{
				{
					std::unique_lock<std::mutex> Lock{ QueueMutex, std::try_to_lock };
					if (!Lock)
					{/* If our mutex is already locked simply return */
						return false;
					}
					/* Else place on the back of our Queue*/
					TaskQueue.emplace_back(std::forward<_FUNC>(func));
				}
				is_Ready.notify_one();
				return true;
			}
			template<typename _FUNC> void push(_FUNC&& func)
			{/* Adds a Function to our Queue */
				{
					std::unique_lock<std::mutex> Lock{ QueueMutex };
					TaskQueue.emplace_back(std::forward<_FUNC>(func));//std::move<_FUNC> std::forward<_FUNC&>(&((Worker_Function *)
				}
			}
	};
		class ThreadPool
		{
			const unsigned int ThreadCount{ std::thread::hardware_concurrency() - 1 };
			std::vector<std::thread> Worker_Threads;
			std::vector<JobQueue> ThreadQueue{ ThreadCount };
			std::atomic<unsigned int> Index{ 0 };

			ThreadPool();
			~ThreadPool();

			void Run(unsigned int _i);
		public:

			static ThreadPool& get()
			{
				static ThreadPool instance;
				return instance;
			}
			// class _RET = std::result_of_t<_FUNC>,class _RET =std::result_of_t<_FUNC()>, 

 //_FUNC&& _func, ARGS&&...args)->std::future<decltype(_func(args...))>//  //

			template<typename _FUNC, typename...ARGS >
			auto Async(_FUNC&& _func, ARGS&&...args)->std::future<decltype(_func(args...))>//  //
			{// Accept arbitrary Function signature and arguments
				auto i = Index++;

				auto task_PTR =
					std::make_shared<std::packaged_task<decltype(_func(args...))()>>
					(// Bind the argument and make a new packaged task to retrieve a future from on completion. 
						std::bind
						(
							std::forward<_FUNC>(_func),
							std::forward<ARGS>(args)...
						)
						);
				//	if(_q[(i + n) % _count]
				std::function<void()> wrapper_func = [task_PTR]()
				{// Utilize std::functions type erasure to wrap the Task pointer
					(*task_PTR)();
				};


				int K = 8;
				for (unsigned int n{ 0 }; n != ThreadCount * K; ++n) // K is Tunable 
				{
					if (ThreadQueue[static_cast<size_t>((i + n) % ThreadCount)].try_push(wrapper_func))
					{
						return task_PTR->get_future();
					}
				}

				ThreadQueue[i % ThreadCount].push(wrapper_func);
				return  task_PTR->get_future();
			}
		};
}// End NS Threading
}// End NS Core 

#endif






int TestFunctionA();
int TestFunctionB(int _param);
uint64_t TestFunctionLarge(uint64_t _p1, uint64_t _p2, uint64_t _p3, uint64_t _p4, uint64_t _p5);
 
float TestFunctionC(float _paramA, int _paramB);

std::string TestFunctionD(float _paramA, int _paramB);
std::vector<uint32_t> TestFunctionE(int _paramA);
std::vector<uint32_t> TestFunctionF(int _paramA);
std::vector<uint32_t> TestFunctionG(int _paramA);
std::vector<uint32_t> TestFunctionH(int _paramA);
std::vector<uint32_t> TestFunctionI(int _paramA);
std::vector<uint32_t> TestFunctionJ(int _paramA);

uint64_t TestCompile(std::vector<std::vector<uint32_t>> _input);
uint64_t Worker_TestFunction(size_t _count);




template<typename _Ty, size_t _SZ>
class ring_buffer
{
public:
	using value_type = _Ty;
	using reference = _Ty & ;
	using pointer = const _Ty*;

	ring_buffer() = default;

	bool push_back(reference _element)
	{/// Just deferring this function to make it compatible with older Queue system for Threadpool
		return push(_element);
	}
	bool push(reference _element)
	{// Adds new Element to Queue
		std::atomic<size_t> OldWritePosition;/// = WritePosition.load();
		std::atomic<size_t> NewWritePosition = NextElement(OldWritePosition);
		if (NewWritePosition)/// == ReadPosition.load())
		{/* If Read position and Write position are the same Buffer is Full */
			return false;
		}
///		Data[OldWritePosition] = _element;
		WritePosition = NewWritePosition;
	}

	/// WE MIGHT BE ABLE TO PACK THE READER AND WRITER INTO THE SAME ATOMIC INTEGER WHICH WILL REDUCE THE OVERHEAD
	bool pop(reference _returnElement)
	{/* Returns True if more elements in Queue*/
		while (true)
		{/* READER Multiple in Existance */
			std::atomic<size_t> OldReadPosition = ReadPosition.load();

			if (WritePosition.load() == OldReadPosition.load())
			{// If attempting to read the same position again or buffer is full return false;
				return false;
			}

			_returnElement = Data[OldReadPosition];// Perhaps std::move() would be better for performance
			if (ReadPosition.compare_exchange_strong(OldReadPosition, NextElement(OldReadPosition)))
			{
				return true;
			}
		}
	}

	auto front()
	{/// Possibly wrong currently a place holder to make the experimental ringbuffer compatible with older style of queue
		return &Data[ReadPosition];
	}
	void pop_front() 
	{/// Possibly wrong currently a place holder to make the experimental ringbuffer compatible with older style of queue
		WritePosition = NextElement(WritePosition);
	}
	bool empty()
	{/// Possibly wrong currently a place holder to make the experimental ringbuffer compatible with older style of queue
		return (ReadPosition == WritePosition);
	}

	reference operator[](const int _offset)
	{
		return Data[_offset]; //[ReadPosition % BufferSize];
	}

	bool destroy()
	{
		delete[](Data);
	}

	size_t size()
	{
		return BufferSize;
	}

private:

	std::array<std::atomic<_Ty*>, _SZ + 1> Data;

	size_t NextElement(size_t _pos)
	{
		return ++_pos == BufferSize ? 0 : _pos;
	}

	size_t
		ReadPosition{ 0 },
		WritePosition{ 0 };
	size_t Length, Size, Start, End, Elements;
	size_t BufferSize = _SZ + 1;
};

#pragma warning( pop )

//
//pointer begin()
//{
//	return &Data[ReadPosition.location()];
//}
//pointer end()
//{
//	return &Data[WritePosition.location()];
//}
//
//	using iterator = rbIterator<_Ty>;
//iterator MyFirst() { return Data; }
//iterator MyLast() { return Data; }
//iterator MyEnd() { return MyLast(); }
// _NODISCARD iterator begin() noexcept
	// {	// return iterator for beginning of mutable sequence
	// 	return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
	// }



/*
		void make_Ready()//std::unique_lock<std::mutex>* _Lock)///, bool _At_thread_exit) Create a Defered signal so value is set when thread ends
		{
			//	_Has_stored_result = true;
		///if (_At_thread_exit) { // notify at thread exit
		///	_Cond._Register(*_Lock, &_Ready);
		///}
		///else { // notify immediately
			isReady = true;
			MutxCV.notify_all();
		///}
		}
		*/




		//type get()
		//{ // block until ready then return the stored result or
		//		// throw the stored exception
		//	//future _Local{ std::move(*this) };
		//	return type();// 0;//_STD move(_Local._Get_value());
		//}
		//std::future<std::invoke_result_t<_Func&, ARGS...>>& get_future()
		//{
		//	std::promise<std::invoke_result_t<_Func&, ARGS...>> result
		//}

		/*


			_State_manager& operator=(const _State_manager& _Other) { // assign from _Other
			_Copy_from(_Other);
			return *this;
		}

		_State_manager& operator=(_State_manager&& _Other) { // assign from rvalue _Other
			_Move_from(_Other);
			return *this;
		}

		_NODISCARD bool valid() const noexcept { // return status
			return _Assoc_state && !(_Get_only_once && _Assoc_state->_Already_retrieved());
		}

		void wait() const { // wait for signal
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Wait();
		}
			template <class _Clock, class _Dur>
		future_status wait_until(const chrono::time_point<_Clock, _Dur>& _Abs_time) const { // wait until time point
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			return _Assoc_state->_Wait_until(_Abs_time);
		}

		_Ty& _Get_value() const { // return the stored result or throw stored exception
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			return _Assoc_state->_Get_value(_Get_only_once);
		}

		void _Set_value(const _Ty& _Val, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_value(_Val, _Defer);
		}

		void _Set_value(_Ty&& _Val, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_value(_STD forward<_Ty>(_Val), _Defer);
		}
		   void _Abandon() { // abandon shared state
			if (_Assoc_state) {
				_Assoc_state->_Abandon();
			}
		}

		void _Set_exception(exception_ptr _Exc, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_exception(_Exc, _Defer);
		}

		void _Swap(_State_manager& _Other) { // exchange with _Other
			_STD swap(_Assoc_state, _Other._Assoc_state);
		}
		*/

		//		        unique_lock<mutex> _Lock(_Mtx);
		//    _Maybe_run_deferred_function(_Lock);
		//    while (!_Ready) {
		//        _Cond.wait(_Lock);
		//    }
		/* Likely will need this later down the line */
	//template <>
	//class future<void>
	//{
	//	using type = std::void_t<>;//_Ty;
	//	//using reference_type = type&;
	//	//using pointer_type = _Ty*;
	//
	//	future() noexcept = default;
	//
	//	/* construct from rvalue future object noexcept*/
	//	future(future && _Other) : std::move(_Other) { }
	//
	//	/* assign from rvalue future object noexcept(put this back when everything is good to go)*/
	//	future& operator=(future && _Right) { memmove(this, _Right, sizeof(future));	return *this; }
	//	~future() noexcept = default;
	//
	//	/**/
	//	reference_type& get()
	//	{
	//		while (!isReady) {}
	//		return std::move(*Value);
	//	}
	//	/**/
	//	inline void set(reference_type _value)
	//	{/// maybe pass by value....
	//	//	Value = _value;
	//	//	isReady = true;
	//	}
	//
	//	void wait()
	//	{
	//		/*
	//		        unique_lock<mutex> _Lock(_Mtx);
	//    _Maybe_run_deferred_function(_Lock);
	//    while (!_Ready) {
	//        _Cond.wait(_Lock);
	//    }
	//		*/
	//		while (!isReady) {}
	//	}
	//	pointer_type Value = nullptr;
	//
	//	future(const future&) = delete;
	//	future& operator=(const future&) = delete;
	//};
		//virtual future<void>& get_future() = 0;

		//virtual void get_future() = 0;







	/*
	template<class _Ty>
	struct future
	{
		using type = _Ty;
		using pointer_type = _Ty*;

		/// using reference_type = type&; Removed because of possible void call to this function. That would result in invalid type so either overload
		/// This future Template with a <void> version or perhaps branch in our wrapper to never deal with the future if there is no return value anyway

		future() noexcept = default;
		~future() noexcept = default;

		/* construct from rvalue future object noexcept*/
		//future(future&& _Other)  {this = std::forward(_Other); } //std::move(_Other)

		/* assign from rvalue future object noexcept(put this back when everything is good to go)*/
		///future& operator=(future&& _Right) 
		///{ ERROR
		///	//memmove(*this, _Right, sizeof(future));	return *this; 
		///	*this = std::forward(_Right);
		///	return *this;
		///}

		/*reference_type
		type get()
		{
			//std::unique_lock<std::mutex> value_Lock(Mutx);
			while (!isReady) {}
			return std::move(*Value);
		}
		/*
		inline void set(type* _value)
		{/// maybe pass by value....reference_type
			Value = _value;
			make_Ready();
		}

		/* Wait until the stored function returns and we are able to aquire its return value
		void wait()
		{
		//	std::unique_lock<std::mutex> value_Lock(Mutx);
			while (!isReady)
			{
				//Mutx_CV.wait(value_Lock);
			}
			make_Ready();
		}
		/* Signal to our threads that our Value is ready to be retrieved
		void make_Ready()
		{
			TODO("Make This class non movable or assignable again currently commented out");
			isReady = true;
		///	Mutx_CV.notify_all();
		}

		bool isReady{ false };/// Just make this the CV but my hands are cold so lets get this shit done
		pointer_type Value = nullptr;
		///std::mutex Mutx;
		///std::condition_variable Mutx_CV;
		bool Retrieved{false};


		///RETURN THESE AND MAKE THIS NON COPYABLE AGAIN!!!
		///==================
		//future(const future&) = delete;
		//future& operator=(const future&) = delete;
	};






//future<type> ReturnValue;
//future<type>& get_future()
//{
//	return ReturnValue;// std::move(ReturnValue);
//}
//	future<type> ReturnValue;
//virtual void operator()() override
//{
//	Invoke();
//}//	std::atomic<bool> isReady{ false };


*/
//    Wrapper() = default;
//  static void* operator new(size_t _size)
//  {
//  	//std::cout << "Overloading new operator with size: " << _size << "\n";
//  	//void* p = ::new Wrapper();// sizeof(
//  	void* p = Allocate(_size);//alloca(size);//&Wrapper<_Func, ARGS...>)();
////	Print("Place: " << p << "Memblock: " << Wrap_MemoryBlock << "Offset: " << Wrap_Offset);
//  	return p;
//  }
//  
//  static void operator delete(void* p)
//  {
//  //	std::cout << "Overloading delete operator " << "\n";
//  //	free(p);
//  }
    



====================================================================================================================================================================================
                                                               #11/28															  															  
															  #Threadpool.h															  															  
====================================================================================================================================================================================

private:
JUST GARBAGE i WAS PLAYING WITH
	static void Init()
	{
		if (!Wrap_MemoryBlock)
		{
			Wrap_MemoryBlock = malloc(BLOCK_SIZE * sizeof(char));
		}
	}
	static void *Allocate(uint16_t _sz) 
	{
		if (Wrap_Offset + _sz > BLOCK_SIZE)
		{
			Wrap_Offset = _sz;
			Print("==================Wrapped around=========================================");
		}
		else
		{
			Wrap_Offset += _sz;
		}
		return (void*)((char*)Wrap_MemoryBlock + (Wrap_Offset - _sz));
	}
	//		TODO("Overload new and delete to use a pool to Allocate on the stack if possible but unlikely. Create pool allocator with occassional defrag Event on the TP ");

//pointer begin()
//{
//	return &Data[ReadPosition.location()];
//}
//pointer end()
//{
//	return &Data[WritePosition.location()];
//}
//
//	using iterator = rbIterator<_Ty>;
//iterator MyFirst() { return Data; }
//iterator MyLast() { return Data; }
//iterator MyEnd() { return MyLast(); }
// _NODISCARD iterator begin() noexcept
	// {	// return iterator for beginning of mutable sequence
	// 	return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
	// }



/*
		void make_Ready()//std::unique_lock<std::mutex>* _Lock)///, bool _At_thread_exit) Create a Defered signal so value is set when thread ends
		{
			//	_Has_stored_result = true;
		///if (_At_thread_exit) { // notify at thread exit
		///	_Cond._Register(*_Lock, &_Ready);
		///}
		///else { // notify immediately
			isReady = true;
			MutxCV.notify_all();
		///}
		}
		*/




		//type get()
		//{ // block until ready then return the stored result or
		//		// throw the stored exception
		//	//future _Local{ std::move(*this) };
		//	return type();// 0;//_STD move(_Local._Get_value());
		//}
		//std::future<std::invoke_result_t<_Func&, ARGS...>>& get_future()
		//{
		//	std::promise<std::invoke_result_t<_Func&, ARGS...>> result
		//}

		/*


			_State_manager& operator=(const _State_manager& _Other) { // assign from _Other
			_Copy_from(_Other);
			return *this;
		}

		_State_manager& operator=(_State_manager&& _Other) { // assign from rvalue _Other
			_Move_from(_Other);
			return *this;
		}

		_NODISCARD bool valid() const noexcept { // return status
			return _Assoc_state && !(_Get_only_once && _Assoc_state->_Already_retrieved());
		}

		void wait() const { // wait for signal
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Wait();
		}
			template <class _Clock, class _Dur>
		future_status wait_until(const chrono::time_point<_Clock, _Dur>& _Abs_time) const { // wait until time point
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			return _Assoc_state->_Wait_until(_Abs_time);
		}

		_Ty& _Get_value() const { // return the stored result or throw stored exception
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			return _Assoc_state->_Get_value(_Get_only_once);
		}

		void _Set_value(const _Ty& _Val, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_value(_Val, _Defer);
		}

		void _Set_value(_Ty&& _Val, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_value(_STD forward<_Ty>(_Val), _Defer);
		}
		   void _Abandon() { // abandon shared state
			if (_Assoc_state) {
				_Assoc_state->_Abandon();
			}
		}

		void _Set_exception(exception_ptr _Exc, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_exception(_Exc, _Defer);
		}

		void _Swap(_State_manager& _Other) { // exchange with _Other
			_STD swap(_Assoc_state, _Other._Assoc_state);
		}
		*/

		//		        unique_lock<mutex> _Lock(_Mtx);
		//    _Maybe_run_deferred_function(_Lock);
		//    while (!_Ready) {
		//        _Cond.wait(_Lock);
		//    }
		/* Likely will need this later down the line */
	//template <>
	//class future<void>
	//{
	//	using type = std::void_t<>;//_Ty;
	//	//using reference_type = type&;
	//	//using pointer_type = _Ty*;
	//
	//	future() noexcept = default;
	//
	//	/* construct from rvalue future object noexcept*/
	//	future(future && _Other) : std::move(_Other) { }
	//
	//	/* assign from rvalue future object noexcept(put this back when everything is good to go)*/
	//	future& operator=(future && _Right) { memmove(this, _Right, sizeof(future));	return *this; }
	//	~future() noexcept = default;
	//
	//	/**/
	//	reference_type& get()
	//	{
	//		while (!isReady) {}
	//		return std::move(*Value);
	//	}
	//	/**/
	//	inline void set(reference_type _value)
	//	{/// maybe pass by value....
	//	//	Value = _value;
	//	//	isReady = true;
	//	}
	//
	//	void wait()
	//	{
	//		/*
	//		        unique_lock<mutex> _Lock(_Mtx);
	//    _Maybe_run_deferred_function(_Lock);
	//    while (!_Ready) {
	//        _Cond.wait(_Lock);
	//    }
	//		*/
	//		while (!isReady) {}
	//	}
	//	pointer_type Value = nullptr;
	//
	//	future(const future&) = delete;
	//	future& operator=(const future&) = delete;
	//};
		//virtual future<void>& get_future() = 0;

		//virtual void get_future() = 0;







	/*
	template<class _Ty>
	struct future
	{
		using type = _Ty;
		using pointer_type = _Ty*;

		/// using reference_type = type&; Removed because of possible void call to this function. That would result in invalid type so either overload
		/// This future Template with a <void> version or perhaps branch in our wrapper to never deal with the future if there is no return value anyway

		future() noexcept = default;
		~future() noexcept = default;

		/* construct from rvalue future object noexcept*/
		//future(future&& _Other)  {this = std::forward(_Other); } //std::move(_Other)

		/* assign from rvalue future object noexcept(put this back when everything is good to go)*/
		///future& operator=(future&& _Right) 
		///{ ERROR
		///	//memmove(*this, _Right, sizeof(future));	return *this; 
		///	*this = std::forward(_Right);
		///	return *this;
		///}

		/*reference_type
		type get()
		{
			//std::unique_lock<std::mutex> value_Lock(Mutx);
			while (!isReady) {}
			return std::move(*Value);
		}
		/*
		inline void set(type* _value)
		{/// maybe pass by value....reference_type
			Value = _value;
			make_Ready();
		}

		/* Wait until the stored function returns and we are able to aquire its return value
		void wait()
		{
		//	std::unique_lock<std::mutex> value_Lock(Mutx);
			while (!isReady)
			{
				//Mutx_CV.wait(value_Lock);
			}
			make_Ready();
		}
		/* Signal to our threads that our Value is ready to be retrieved
		void make_Ready()
		{
			TODO("Make This class non movable or assignable again currently commented out");
			isReady = true;
		///	Mutx_CV.notify_all();
		}

		bool isReady{ false };/// Just make this the CV but my hands are cold so lets get this shit done
		pointer_type Value = nullptr;
		///std::mutex Mutx;
		///std::condition_variable Mutx_CV;
		bool Retrieved{false};


		///RETURN THESE AND MAKE THIS NON COPYABLE AGAIN!!!
		///==================
		//future(const future&) = delete;
		//future& operator=(const future&) = delete;
	};






//future<type> ReturnValue;
//future<type>& get_future()
//{
//	return ReturnValue;// std::move(ReturnValue);
//}
//	future<type> ReturnValue;
//virtual void operator()() override
//{
//	Invoke();
//}//	std::atomic<bool> isReady{ false };


*/
====================================================================================================================================================================================
                                                               #11/28															  															  
															  #Main.cpp															  															  
====================================================================================================================================================================================

/*
		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> WrapperBenchmark;
		{
	    	std::vector<Wrapper_Base*> FunctionList;

//auto A =  new Wrapper(TestFunctionE, std::move(LOOP_COUNT));
//auto B =  new Wrapper(TestFunctionB, 1431);
//auto C =  new Wrapper(TestFunctionD, 123.321f, 10);
//auto D =  new Wrapper(TestFunctionA);
//auto E =  new Wrapper(TestFunctionC, 3.14159f, 123);
//auto F =  new Wrapper(TestFunctionF, std::move(LOOP_COUNT));
//auto G =  new Wrapper(TestFunctionG, std::move(LOOP_COUNT));
//auto H =  new Wrapper(TestFunctionH, std::move(LOOP_COUNT));
//auto I =  new Wrapper(TestFunctionI, std::move(LOOP_COUNT));
//auto J =  new Wrapper(TestFunctionJ, std::move(LOOP_COUNT));
//auto K =  new Wrapper([](int)->int { Print("Lambda Function Function List calls"); return 11; }, 10000);

			auto A = new(alloca(sizeof(Wrapper<decltype(TestFunctionE), int>)))       Wrapper(TestFunctionE, std::move(LOOP_COUNT));
			auto B = new(alloca(sizeof(Wrapper<decltype(TestFunctionB), int >)))      Wrapper(TestFunctionB, 1431);
			auto C = new(alloca(sizeof(Wrapper<decltype(TestFunctionD), float, int >))) Wrapper(TestFunctionD, 123.321f, 10);
			auto D = new(alloca(sizeof(Wrapper<decltype(TestFunctionA)  >)))          Wrapper(TestFunctionA);
			auto E = new(alloca(sizeof(Wrapper<decltype(TestFunctionC), float, int >))) Wrapper(TestFunctionC, 3.14159f, 123);
			auto F = new(alloca(sizeof(Wrapper<decltype(TestFunctionF), int>)))       Wrapper(TestFunctionF, std::move(LOOP_COUNT));
			auto G = new(alloca(sizeof(Wrapper<decltype(TestFunctionG), int>)))       Wrapper(TestFunctionG, std::move(LOOP_COUNT));
			auto H = new(alloca(sizeof(Wrapper<decltype(TestFunctionH), int>)))       Wrapper(TestFunctionH, std::move(LOOP_COUNT));
			auto I = new(alloca(sizeof(Wrapper<decltype(TestFunctionI), int>)))       Wrapper(TestFunctionI, std::move(LOOP_COUNT));
			auto J = new(alloca(sizeof(Wrapper<decltype(TestFunctionJ), int>)))       Wrapper(TestFunctionJ, std::move(LOOP_COUNT));
			auto K = new Wrapper([](int)->int { Print("Lambda Function Function List calls"); return 11; }, 10000);

			FunctionList.emplace_back(A);
			FunctionList.emplace_back(B);
			FunctionList.emplace_back(C);
			FunctionList.emplace_back(D);
			FunctionList.emplace_back(E);
			FunctionList.emplace_back(F);
			FunctionList.emplace_back(G);
			FunctionList.emplace_back(H);
			FunctionList.emplace_back(I);
			FunctionList.emplace_back(J);
			FunctionList.emplace_back(K);


			for (auto& F : FunctionList)
			{
				F->Invoke();
			}
			while (Function_Counter != 10) {/* Surely has passed but for completeness we will add  }
			auto R1 = A->ReturnValue.get_future().get();
			auto R2 = B->ReturnValue.get_future().get();
			auto R3 = C->ReturnValue.get_future().get();
			auto R4 = D->ReturnValue.get_future().get();
			auto R5 = E->ReturnValue.get_future().get();
			auto R6 = F->ReturnValue.get_future().get();
			auto R7 = G->ReturnValue.get_future().get();
			auto R8 = H->ReturnValue.get_future().get();
			auto R9 = I->ReturnValue.get_future().get();
			auto R10 = J->ReturnValue.get_future().get();
			auto R11 = K->ReturnValue.get_future().get();

			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(R1);
			Test.push_back(R6);
			Test.push_back(R7);
			Test.push_back(R8);
			Test.push_back(R9);
			Test.push_back(R10);
			Print("Wrapped: "<< R4 << " : " << TestCompile(Test));
			//delete A; delete B; delete C; delete D; delete E; delete F; delete G; delete H; delete I; delete J;
			delete K;
			WrapperBenchmark.Stop();
		}

		std::cout << "  Wrapper Linear = " << WrapperBenchmark.Results / 1000.0f << " ms" << "\n"; // 0.020808  Difference of .000774
		*/
====================================================================================================================================================================================
                                                               															  															  
															  															  															  
====================================================================================================================================================================================
