// ============================================================================================================================================================================
//                                 3/4/2020
//          Clean up  #Main.cpp
// ============================================================================================================================================================================


//glVertexAttribPointer(
//	0,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.
//	3,                  // size
//	GL_FLOAT,           // type
//	GL_FALSE,           // normalized?
//	0,                  // stride
//	(void*)0            // array buffer offset
//);
//1265 681   1280 720 = (15,39)
//  _width += 15;
//   _height += 39;


/*
PFNGLVIEWPORTPROC glad_glViewport = NULL;
PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv = NULL;
PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf = NULL;
PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv = NULL;
glad_glViewportPositionWScaleNV
*/

//glGenVertexArrays(1, &VAO);
// glBindVertexArray(VAO);
//  glBindBuffer(GL_ARRAY_BUFFER, VBO);
//  glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), &Vertices, GL_STATIC_DRAW);
  //glBindBuffer(GL_ARRAY_BUFFER, VBO);
 // GLuint Location = 4;
   //Location = glGetAttribLocation(getWindow().defaultShader().g_ID(), "aPos");
  //glEnableVertexAttribArray(Location);
  //glVertexAttribPointer(Location, 2, GL_FLOAT, GL_FALSE, 0, (char *)NULL);


    Vec2 ProfilerVerts[4] =
    {
        {-1.0,-1.0 },
        { 1.0,-1.0 },
        { 0.0, 1.0 },
        { 1.0, 1.0 }
    };

    Vec2 ProfilerUV[4] =
    {
        { 0.0, 0.0 },
        { 1.0, 0.0 },
        { 1.0, 1.0 },
        { 0.0, 1.0 }
    };

    GLuint ProfilerIndices[3] =
    {
        0,1,2,
    };
*/


//	glBindBuffer(GL_ARRAY_BUFFER, VBO);
//	{
        //glDrawArrays(GL_TRIANGLES, 0, 3);
//	}
//	glBindBuffer(GL_ARRAY_BUFFER, 0);
        //for_loop(y, 100)
        //{
        //	for_loop(x, 100)
        //	{
        //		float
        //			Px = x * 21,
        //			Py = y * 21;
        //		MainRenderer->renderQuad(Vec2(Px, Py), Vec2(20, 20));
        //	}
        //}
/*

        Vec2 _size = Vec2(8, 8);
        Vec2 Space = Vec2(1, 1);
        Vec2 Count = Vec2(80, 60);

 for_loop(y, Count.y)
 {
     for_loop(x, Count.x)
     {
         Vec2 _topleft
         (
             x * (_size.x + Space.x),
             y * (_size.y + Space.y)
         );
 
         TestBatch.push_back(Vec2(_topleft.x, _topleft.y));
         TestBatch.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
         TestBatch.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
         TestBatch.push_back(Vec2(_topleft.x + _size.x, _topleft.y + _size.y));
         TestBatch.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
         TestBatch.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
     }
 }
 MainRenderer->SetRenderColor(0, 255, 255, 255);
 for_loop(y, Count.y)
 {
     for_loop(x, Count.x)
     {
         Vec2 _topleft
         (
             x * (_size.x + Space.x),
             (y + Count.y) * (_size.y + Space.y)
         );
 
         TestBatch2.push_back(Vec2(_topleft.x, _topleft.y));
         TestBatch2.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
         TestBatch2.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
         TestBatch2.push_back(Vec2(_topleft.x + _size.x, _topleft.y + _size.y));
         TestBatch2.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
         TestBatch2.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
     }
 }
 
*/
// ============================================================================================================================================================================
//                                 3/3/2020
//          Clean up  #Texture.cpp
// ============================================================================================================================================================================

/*   
layout(location = 0) in vec2 aPos; 
uniform vec4 Position; 
uniform mat4 ProjectionMatrix;     
uniform mat4 ViewMatrix;           
void main()                        
{                                  
    mat4 ModelViewMatrix = (ViewMatrix * mat4(1.0));  
    mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);
    gl_Position = ModelViewProjectionMatrix * vec4( (aPos.x * Position.z) + Position.x, (aPos.y * Position.w) +  Position.y, -1.0, 1.0); 
}

#version 330 core             
out vec4 FragColor;            
void main()                    
{                              
    FragColor = vec4(1,1,1,1); 
}

*/

/*



for(auto& S: Shaders)
        {
            for(auto& T: Textures)
            { }
        }
    enum  Surface_t { Normals, Albedo, Metallic };

    using SurfaceFragment = std::pair<Surface_t, Texture_ID_t>;
    using Surface = std::vector<SurfaceFragment>;
    using Material = std::pair<Surface, Shader_ID_t>;
    using RenderPair = std::pair<Material, Mesh_ID_t>;

    std::vector<Shader*> Shaders;
    std::vector<Graphics::Texture*> Textures;
    std::vector<Mesh*> Meshes;
*/




	// Simple move assignment operator
 //VertexArrayObject& operator=(VertexArrayObject&& other)
 //{
 //   // *this = 
 //    return *std::move(other);//
 //}
/*
#ifdef BINDLESS_ATTRIBUTES
void Bind() {}
void Unbind() {}

template<typename T>
void Attach(BufferTypes bufferT, VertexBufferObject<T>* buffer)
{
	if (GL_Handle == NULL)
	{
		glGenVertexArrays(1, &GL_Handle);
	}
	Bind();
	GLint Amount = sizeof(T) / sizeof(float);
	Buffers.push_back(buffer);

	switch (bufferT)
	{
	case INDICE:
		buffer->AttributeType = INDICE;
		return;
		break;
	case VERTEX:
		buffer->AttributeType = VERTEX;
		break;
	case COLOR:
		buffer->AttributeType = COLOR;
		break;
	case NORMAL:
		buffer->AttributeType = NORMAL;
		break;
	case UVCOORD:
		buffer->AttributeType = UVCOORD;
		break;
	case TANGENT:
		buffer->AttributeType = TANGENT;
		break;
	}
}
#else
//#endif

 */



/*

    glTexImage2D(
        Target, 0,
        _internalFormat,
        _size.x, _size.y,
        Border,
        _dataFormat,
        _type, (void*)NULL);

    Texture(Vec2 _size,
        int32_t _dataFormat = GL_RGBA,
        int32_t _internalFormat = GL_RGBA,
        uint32_t _wrap = GL_CLAMP_TO_EDGE,
        uint32_t _filtering = GL_NEAREST,
        uint32_t _type = GL_FLOAT);

 //   glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24, 1024, 768, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
 
 */



 //GLuint TextureID;
 //GLuint DepthTexture;
 //GLenum InternalFormat;
 //GLenum PixelFormat;
 //GLenum DataType;

//_static uint32_t Texture::debugVAO;
//_static uint32_t Texture::debugVBO;
//_static Shader* Texture::debugShader;
//_static Camera2D Texture::debugCamera;
//_static Vec2 QuadData[6] =
//{
//    Vec2(0, 0),  Vec2(1, 0),  Vec2(0, 1),
//    Vec2(1, 1),  Vec2(0, 1),  Vec2(1, 0)
//};
//_static void Texture::InitDebug()
//{
//    debugCamera = Camera2D(1280, 740);
//    debugShader = new Shader(VdebugRenderer, FdebugRenderer);
//
//    debugVAO = OpenGL::new_VAO();
//    debugVBO = OpenGL::new_VBO();
//
//    debugShader->Bind();
//    {
//        OpenGL::bind_VAO(debugVAO);
//        OpenGL::bind_VBO(debugVBO);
//        OpenGL::set_Attribute(2, "aPos");
//    }
//    debugShader->Unbind();
//}
// void Texture::Render(int _x, int _y, int _w, int _h)
// {
// 
//     Mat4 Transform = glm::mat4(1.0f); //  Set Identity and Rotate all axis followed with the Translation.
//     Transform = glm::translate(Transform, Vec3(_x, _y, 0));
//     Transform = glm::rotate(Transform, glm::radians(0.f), Vec3(1.0f, 0.0f, 0.0f));
//     Transform = glm::rotate(Transform, glm::radians(0.f), Vec3(0.0f, 1.0f, 0.0f));
//     Transform = glm::rotate(Transform, glm::radians(0.f), Vec3(0.0f, 0.0f, 1.0f));
// 
//     ///Shader::GetActiveShader()->SetUniform("ProjectionMatrix", OrthographicMatrix(640, 480));
//     ///Shader::GetActiveShader()->SetUniform("ViewMatrix", Mat4(1));
//     ///Shader::GetActiveShader()->SetUniform("ModelMatrix", Transform);
// 
//     ///Plane temp(Vec3(0), Vec3(0), (float)_w, (float)_h);
//     ///Shader::GetActiveShader()->SetTextureUniform("DiffuseTexture", this);
//     ///temp.Render(*Shader::GetActiveShader());
// 
//     debugShader->Bind();
//     {
//         OpenGL::bind_VAO(debugVAO);
//         debugCamera.Bind();
//         debugShader->SetUniform("Position", Vec4(_x, _y, _w, _h));
// 
//         glBindBuffer(GL_ARRAY_BUFFER, debugVBO);
//         glDrawArrays(GL_TRIANGLES, 0, 6);
//     }
//     debugShader->Unbind();
// }
//
//    _static std::string Texture::VdebugRenderer =
//        "#version 330 core         \n\
//layout(location = 0) in vec2 aPos; \n\
//uniform vec4 Position;             \n\
//uniform mat4 ProjectionMatrix;     \n\
//uniform mat4 ViewMatrix;           \n\
//out vec2 TexCoords;                \n\
//void main()                        \n\
//{                                  \n\
//    TexCoords = aPos.xy;           \n\
//    mat4 ModelViewMatrix = (ViewMatrix * mat4(1.0));  \n\
//    mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);\n\
//    gl_Position = ModelViewProjectionMatrix * vec4( (aPos.x * Position.z) + Position.x, (aPos.y * Position.w) +  Position.y, -1.0, 1.0); \n\
//}";
//
//    _static std::string Texture::FdebugRenderer =
//        "#version 330 core \n\
//uniform sampler2D DebugText;   \n\
//in vec4 Col;                   \n\
//in vec2 TexCoords;             \n\
//out vec4 FragColor;            \n\
//void main()                    \n\
//{                              \n\
//    vec4 Samp = texture2D(DebugText, TexCoords); \n\
//    FragColor = Samp;   \n\
//}";
//
//  //texture2D(sampler2D(DiffuseTexture), TexCoords.xy); 
//Vec2 TexCoords[6] =
//{
//    Vec2(0.0f, 1.0f), Vec2(0.0f, 0.0f),        Vec2(1.0f, 0.0f),
//    Vec2(0.0f, 1.0f), Vec2(1.0f, 0.0f),        Vec2(1.0f, 1.0f)
//};
 //====================== DEBUG STUFF ==============================================================
 //================================================================================================
 //static std::string VdebugRenderer;
 //static std::string FdebugRenderer;
 //static uint32_t debugVAO;
 //static uint32_t debugVBO;
 //static Shader* debugShader;
 //static Camera2D debugCamera; 
 //
 //static Vec2 QuadData[6];
 //static Vec2 TexCoords[6];
 // public:
 //static void InitDebug();
     //  InternalFormat = GL_RGBA;// GL_RGBA;GL_RED;// 
       // Format = GL_RGBA;// _INTEGER;// GL_RGBA_INTEGER; GL_RED;//
    //  
    //  bool Texture::Load()
    //  {
    //  	Bind();
    //  
    //  	SetMinFiltering(GL_LINEAR_MIPMAP_LINEAR);  // Texture Layout when sampling past texture
    //  	SetMagFiltering(GL_LINEAR);
    //  
    //  	SetWrap(GL_REPEAT); // Texture Layout when sampling past texture
    //  
    //  
    //  	if (Picture->Channels == 4)
    //  	{
    //  		Format = GL_RGBA;
    //  		InternalFormat = GL_RGBA;
    //  	}
    //  	else if (Picture->Channels == 3)
    //  	{
    //  		Format = GL_RGB;
    //  		InternalFormat = GL_RGB;
    //  	}
    //  	_GL(glTexImage2D(Target, 0, InternalFormat, Picture->Size.x, Picture->Size.y, 0, Format, GL_UNSIGNED_BYTE, Picture->Data)); // 	_GL(glTexImage2D(Target, 0, GL_RGB, Picture.Size.x, Picture.Size.y, 0, GL_RGB, GL_UNSIGNED_BYTE, Picture.Data));
    //  	glGenerateMipmap(Target);
    //  	Handle = glGetTextureHandleARB(TextureID);
    //  	glMakeTextureHandleResidentARB(Handle);
    //  
    //  	Unbind();
    //  	return true;
    //  }
    //  
    //Target
///     Texture::Texture(Bitmap& image, int _x, int _y, int _width, int _height)
///     {// Generate a Texture from a Sub image 
///     	Picture = new Bitmap();
///     	///*Picture = Bitmap::FlippedImage(image);
///     
///     	glGenTextures(1, &GL_Handle);
///     	Bind();
///     
///     	SetMinFiltering(GL_LINEAR_MIPMAP_LINEAR);  // Texture Layout when sampling past texture
///     	SetMagFiltering(GL_LINEAR);
///     	SetWrap(GL_REPEAT); // Texture Layout when sampling past texture
///     
///     	size_t Stride = Picture->Channels();
///     	size_t SrcByteHeight = Picture->Height() * Stride;
///     	size_t SrcByteWidth = Picture->Width() * Stride;
///     
///     	size_t DestByteHeight = _height * Stride;
///     	size_t DestByteWidth = _width * Stride;
///     
///     	size_t RowSize = DestByteWidth;
///     
///     	size_t DestIndex = 0, SourceIndex = 0;// (_x * Stride);
///     
///     	unsigned char* TempImage = new unsigned char[DestByteHeight * DestByteWidth];
///     	size_t Buffered = 0;
///     	if (DestByteWidth + (_x * Stride) > SrcByteWidth)
///     	{
///     		RowSize -= (_x * Stride);
///     		DestByteWidth -= (_x * Stride);
///     		Buffered = (_x * Stride);
///     	}
///     
///     	int Counter = 0;
///     	for (int py = 0; py < _height; ++py)
///     	{
///     		unsigned char* Src = &Picture->Data[SourceIndex];
///     		unsigned char* Dest = &TempImage[DestIndex];
///     
///     		memcpy(Dest, Src, RowSize);
///     
///     		SourceIndex += SrcByteWidth;
///     		DestIndex += DestByteWidth;
///     
///     		Counter++;
///     	}
///     	Picture->Data = TempImage;
///     
///     
///     	*Picture = Bitmap::FlippedImage(*Picture);
///     
///     	if (Picture->Channels() == 4)
///     	{
///     		Format = GL_RGBA;
///     		InternalFormat = GL_RGBA;
///     	}
///     	else if (Picture->Channels() == 3)
///     	{
///     		Format = GL_RGB;
///     		InternalFormat = GL_RGB;
///     	}
///     
///     
///     	glTexImage2D(Target, 0, InternalFormat, (Picture->Width()), Picture->Height(), 0, Format, GL_UNSIGNED_BYTE, Picture->Data()); // 	_GL(glTexImage2D(Target, 0, GL_RGB, Picture.Size.x, Picture.Size.y, 0, GL_RGB, GL_UNSIGNED_BYTE, Picture.Data));
///     	glGenerateMipmap(Target);
///     
///     	Handle = glGetTextureHandleARB(GL_Handle);
///     	glMakeTextureHandleResidentARB(Handle);
///     	delete (TempImage);
///     	Unbind();
///     }

// ============================================================================================================================================================================
//                                 2/20/2020
//          Clean up  
// ============================================================================================================================================================================




        /* QuadRenderer->Bind();
        {
            Shader::get().SetUniform("ModelMatrix", Mat4(1.0f));
            mainCamera.Bind();
           // Renderer::drawArray(QuadVBO, QuadData.size());
            Renderer::drawArrayInstanced(QuadVBO, 6, 1000);

            DEBUG_CODE(CheckGLERROR());
        }
        QuadRenderer->Unbind();*/
//	void renderLine(Vec2 _start, Vec2 _end);
//void renderLineBatch(const std::vector<Vec2> _batch);
//vec4(1.0, 1.0, 1.0, 1.0); vec4(1.0, 1.0, 1.0, 1.0) + Col; 
// 		std::string VquadRenderer =
// 			"#version 330 core     \n\
// layout(location = 0) in vec2 aPos; \n\
// layout(location = 1) in vec4 Color;\n\
// uniform mat4 ProjectionMatrix;     \n\
// uniform mat4 ViewMatrix;           \n\
// uniform mat4 ModelMatrix;          \n\
// out vec4 Col;                      \n\
// void main()                        \n\
// {                                  \n\
//     Col = Color;                   \n\
//     mat4 ModelViewMatrix = (ViewMatrix * ModelMatrix);  \n\
//     mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);\n\
//     gl_Position = ModelViewProjectionMatrix * vec4(aPos.x, aPos.y, -1.0, 1.0); \n\
// }";
//
// 		std::string FquadRenderer =
// 			"#version 330 core \n\
// out vec4 FragColor;            \n\
// in vec4  Col;            \n\
// void main()                    \n\
// {                              \n\
//     FragColor = Col;\n\
// }";
//
////gl_Position = (ProjectionMatrix * (ViewMatrix * ModelMatrix)) * vec4(aPos.x, aPos.y, -1.0, 1.0); \n\
//
//        // QuadRenderer = new Shader(VquadRenderer, FquadRenderer);
//        // Shader* QuadRenderer;
//
//std::vector<FrameBufferObject> RenderTargets;
//std::vector<Shader> Programs;
////std::vector<VertexArrayObject> VAOs;
////std::vector<VertexBufferObject<Vec3>> VBOs;
//std::vector<Mesh> Meshes;
//
//VertexData.push_back(Vec2(Position.x - Offset.x, Position.y + Offset.y));
//VertexData.push_back(Vec2(Position.x - Offset.x, Position.y - Offset.y));
//VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
//VertexData.push_back(Vec2(Position.x - Offset.x, Position.y + Offset.y));
//VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
//VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
//
//Vec2 Position = Vec2(0);
//Vec4 Vertices[6] =
//{   // positions   // texCoords
//	Vec4(0 ,         Size.y   ,    0.0f,  1.0f),
//	Vec4(0 ,        -Size.y   ,    0.0f,  0.0f),
//	Vec4(Size.x ,  -Size.y   ,    1.0f,  0.0f),
//	Vec4(0 ,         Size.y   ,    0.0f,  1.0f),
//	Vec4(Size.x ,  -Size.y   ,    1.0f,  0.0f),
//	Vec4(Size.x ,   Size.y   ,    1.0f,  1.0f)
//};
//glGenBuffers(1, &VBO);
//glBindBuffer(GL_ARRAY_BUFFER, VBO);
//glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), &Vertices, GL_STATIC_DRAW);
//VAO->Attach(VERTEX, new VertexBufferObject<Vec2>(&newVertices[0], 6));
//VAO->Attach(UVCOORD, new VertexBufferObject<Vec2>(&TexCoords[0], 6));
////Program = new Shader("Resources\\DebugQuad.sfx");
//
//Vec2 Vertices[6];
//Vec2 TexCoords[6] =
//{
//    Vec2(0.0f, 1.0f),
//    Vec2(0.0f, 0.0f),
//    Vec2(1.0f, 0.0f),
//    Vec2(0.0f, 1.0f),
//    Vec2(1.0f, 0.0f),
//    Vec2(1.0f, 1.0f)
//};
//VA.Bind();
//for(auto& VB: VBOs)
//{ }
//for (auto& FB : RenderTargets)
//{
//    FB.Bind();
//    for (auto& S: Programs)
//    {
//        S.Enable();
//        for (auto& VA : VAOs)
//        {
//            VA.Bind();
//            /*
//            for(auto& VB: VA.Buffers)
//            {
//                VB->Bind();
//            }
//            for(auto& M: Meshes)
//            {
//                M.Bind();
//            }*/
//            Renderer::drawArray(QuadVBO, VertexData.size() * 0.5f);
//        }
//    }
//}
///     struct RenderPass
///     {
///     	void Submit(Mesh& _mesh, Graphics::Texture& _tex)
///     	{
///           //  SurfaceMap[_tex.g_Handle()].push_back( _mesh );
///     	}
///     	void Render()
///     	{
///             for (auto& Te : SurfaceMap)
///             {
///                 int Slot{ 0 };
///             	for (auto& S : Te.first)
///             	{// Cycle over and fill all the Slots for the Surface,  Diffuse, the Bump map, Shine, Displacement etc..
///             		glActiveTexture(GL_TEXTURE0 + (Slot++));
///             		glBindTexture(GL_TEXTURE_2D, S);
///             	}
///             
///             	for(auto& M : Te.second)
///             	{ 
///             		//M.
///             	}
///             }
///     	}
///     	//std::unordered_map<std::vector<uint32_t>, std::vector<Mesh>> SurfaceMap;
///     	std::vector<std::vector<int>> Pairs;
///     	std::vector<Graphics::Texture*> Texts;
///     	std::vector<Mesh*> Meshes;
///     	Shader* GPUrenderer;
///     	FrameBufferObject FBO;
///     	DEBUG_CODE(const char* Name{""};)
///     };
/// 	struct Surface_s
/// 	{
/// 		struct Material {
/// 			Graphics::Texture Tex;
/// 		};
/// 		Shader* MaterialShader;
/// 	};
/// 	void Submit(RenderPair _matMesh)
/// 	{
/// 
/// 	}
///		std::unordered_map<Material, uint32_t> Pairs;
/*=======================================================================================================================================================*/
//
//
//
//
//void QuadBatch::Render()
//{
//}
//
//void QuadBatch::renderQuad(Vec2 _topleft, Vec2 _size, Vec4 _color)
//{
//
//	QuadData.push_back(Vec2(_topleft.x, _topleft.y));
//	QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
//	QuadData.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
//	QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y + _size.y));
//	QuadData.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
//	QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
//
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//	ColorData.push_back(_color);
//}
//
//
//
//LineRenderer->Bind();
//{
//    Shader::get().SetUniform("ModelMatrix", Mat4(1.0f));
//    mainCamera.Bind();
//    Renderer::drawArray(LineVBO, QuadData.size());
//    DEBUG_CODE(CheckGLERROR());
//}
//LineRenderer->Unbind();
//LineData.clear();
// LineRenderer = new Shader(VlineRenderer, FlineRenderer);
// 
// LineVAO = OpenGL::new_VAO();
// LineVBO = OpenGL::new_VBO();
// LineRenderer->Bind();
// {// Sets up the VAO for the Lines
//     OpenGL::bind_VAO(LineVAO);
//     OpenGL::bind_VBO(LineVBO);
//     OpenGL::set_Attribute(LineRenderer->g_ID(), 2, "aPos");  
// }
// LineRenderer->Unbind();
//		std::string VlineRenderer =
//			"#version 330 core     \n\
//layout(location = 0) in vec2 aPos; \n\
//uniform mat4 ProjectionMatrix;     \n\
//uniform mat4 ViewMatrix;           \n\
//uniform mat4 ModelMatrix[100];          \n\
//void main()                        \n\
//{                                  \n\
//    mat4 ModelViewMatrix = (ViewMatrix * ModelMatrix[gl_InstanceID]);  \n\
//    mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);\n\
//    gl_Position = ModelViewProjectionMatrix * vec4(aPos.x, aPos.y, -1.0, 1.0); \n\
//}";
//
//		std::string FlineRenderer =
//			"#version 330 core \n\
//out vec4 FragColor;            \n\
//void main()                    \n\
//{                              \n\
//    FragColor = vec4(1.0, 1.0, 1.0, 1.0);  \n\
//}";
//void Renderer2D::renderLineBatch(const std::vector<Vec2> _batch)
//{
//    LineData.insert(LineData.end(), _batch.begin(), _batch.end());
//}
//
//
//ColorData.push_back(CurrentRenderColor);
//ColorData.push_back(CurrentRenderColor);
//ColorData.push_back(CurrentRenderColor);
//ColorData.push_back(CurrentRenderColor);
//ColorData.push_back(CurrentRenderColor);
//
// void Renderer2D::renderLine(Vec2 _start, Vec2 _end)
// {
//     LineData.push_back(_start);
//     LineData.push_back(_end);
// }
//		Shader* LineRenderer;
//       Vec2
//           _topleft = Vec2(30, 30),
//           _bottomright = Vec2(200.f, 200.f);
//
//       Vec2 Offset = Vec2
//       (// Later we may perform a check to ensure values are properly ordered
//           (_bottomright.x - _topleft.x) * 0.5f,
//           (_bottomright.y - _topleft.y) * 0.5f
//       );
//       Vec2 Position = { 100, 100 };
//
// VertexData.push_back({ 200.0, 200.0 });
// VertexData.push_back({ 400.0, 200.0 });
// VertexData.push_back({ 0.0, 400.0 });
// VertexData.push_back(Vec2(Position.x - Offset.x, Position.y + Offset.y));
// VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
// VertexData.push_back(Vec2(Position.x + Offset.x, Position.y - Offset.y));
 //       renderQuad(Vec2(100,100), Vec2(200,200));
        //==============================================================================
        //Vec2 Offset = Vec2
       //(// Later we may perform a check to ensure values are properly ordered
       //    (_size.x - _topleft.x) * 0.5f,
       //    (_size.y - _topleft.y) * 0.5f
       //);
       //
       //VertexData.push_back(Vec2(-Offset.x, +Offset.y));
       //VertexData.push_back(Vec2(-Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(+Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(-Offset.x, +Offset.y));
       //VertexData.push_back(Vec2(+Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(+Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(-Offset.x, +Offset.y));
       //VertexData.push_back(Vec2(-Offset.x, -Offset.y));
       //VertexData.push_back(Vec2(+Offset.x, -Offset.y));
// Currently Memcpy is far slower than Insert. Like 1/2 the speed
/// size_t Sz = QuadData.size() + _batch.size();
       /// size_t Start = QuadData.size();
       /// QuadData.reserve(Sz);
       /// memcpy(&QuadData[Start ], &_batch[0], _batch.size() * sizeof(Vec2));
//  for_loop(y, 10)
//  {
//      for_loop(x, 10)
//      {
//          Transform Tr = Transform({ x,y,0 }, { 0,0,0 }, "Tr");
//          Transforms.push_back(Tr.get());
//      }
//  }
/*
        Vec2 _topleft = { 0 ,0 };    _size = {1, 1};
        QuadData.push_back(Vec2(_topleft.x, _topleft.y));
        QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y));
        QuadData.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
        QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y + _size.y));
        QuadData.push_back(Vec2(_topleft.x, _topleft.y + _size.y));
        QuadData.push_back(Vec2(_topleft.x + _size.x, _topleft.y));


*/// Vec2 Sz
// {
//    ( Right * ZoomLevel)* AspectRatio ,
//     Bottom  * ZoomLevel,
// };

//  Sz.x,
//Sz.y,
//    Sz *= _amount;
//	float
//		Sx = Right * ZoomLevel * 0.5f,
//		Sy = Bottom * ZoomLevel * 0.5f;
//

///ProjectionMatrix =
///	glm::ortho
///	(
///		0.0f - Sx,
///		Right * ZoomLevel,
///		Bottom * ZoomLevel,
///		0.0f - Sy,
///		Near,
///		Far
///	);  //OrthographicMatrix(_size.x, _size.y);
///}
   // TODO("This is not currently setup correctly 2/18/2020: The Left and Right should zoom in on that current location of the Camera");

/*=======================================================================================================================================================
/*                                               NOTES
/*=======================================================================================================================================================

template <typename valType>
GLM_FUNC_QUALIFIER detail::tmat4x4<valType> ortho
(
    valType const & left,
    valType const & right,
    valType const & bottom,
    valType const & top,
    valType const & zNear,
    valType const & zFar
)
{
    detail::tmat4x4<valType> Result(1);
    Result[0][0] = valType(2) / (right - left);
    Result[1][1] = valType(2) / (top - bottom);
    Result[2][2] = - valType(2) / (zFar - zNear);
    Result[3][0] = - (right + left) / (right - left);
    Result[3][1] = - (top + bottom) / (top - bottom);
    Result[3][2] = - (zFar + zNear) / (zFar - zNear);
    return Result;
}
 /*   Vec2 Diff = Size - Vec2
    (
        Right* (1.0f / ZoomLevel),
        Bottom* (1.0f / ZoomLevel)
    );
    
       
    Print("Zoom Level: " << (1.0f / ZoomLevel));

    if (ZoomLevel > 0)
    {
        ProjectionMatrix =
            glm::ortho
            (
                Position.x   * (1.0f / ZoomLevel),
                Right  *  (1.0f / ZoomLevel),
                Bottom *  (1.0f / ZoomLevel),
                Position.y   *  (1.0f / ZoomLevel),
                Near,
                Far
            );
    }
    else
    {
        ProjectionMatrix =
            glm::ortho
            (
                Position.x   * -(1.0f / ZoomLevel),
                Right  *  -(1.0f / ZoomLevel),
                Bottom *  -(1.0f / ZoomLevel),
                Position.y   *  -(1.0f / ZoomLevel),
                Near,
                Far
            );

    }
    */
//    ZoomLevel += (1.0f /_amount);
	//	ProjectionMatrix = glm::ortho(0.0f, size.x, size.y, 0.0f, -1.0f, 1.0f);  //OrthographicMatrix(size.x, size.y);
	//	ViewMatrix = glm::translate(Mat4(1.0f), Vec3(-100, 0, 0));
//Top = _top;
//Left = _left;
//ProjectionMatrix = glm::ortho(0.0f, Right, Bottom, 0.0f, -1.0f, 100.0f);  //OrthographicMatrix(_size.x, _size.y);
//ViewMatrix = glm::translate(Mat4(1.0f), Vec3(0, 0, 0));//200, 200, 0))
//Size(size)



/*=======================================================================================================================================================*/
//ViewMatrix = glm::translate(ViewMatrix, Vec3(-_amount.x, -_amount.y, 0));
//ViewMatrix = glm::translate(ViewMatrix, Vec3(-_amount, 0, 0));
//ViewMatrix = glm::translate(ViewMatrix, Vec3(0, -_amount, 0));
//  ZoomLevel += _amount;
//  
//  float
//  Sx = Right * ZoomLevel * 0.5f,
//  Sy = Bottom * ZoomLevel * 0.5f;
//  
//  
//  
//  ProjectionMatrix =
//  glm::ortho
//  (
//  	0.0f - Sx,
//  	Right * ZoomLevel,
//  	Bottom * ZoomLevel,
//  	0.0f - Sy,
//  	Near,
//  	Far
//  );  //OrthographicMatrix(_size.x, _size.y);



//================= #APPLICATION


/*


    //Print("Callback:" << uMsg);
    ///switch (uMsg)
    ///{
    ///
    ///case WM_ACTIVATE:                       // Watch For Window Activate Message
    ///{
    ///	if (!HIWORD(wParam))                    // Check Minimization State
    ///	{
    ///		Print("Active");                    // Program Is Active
    ///	}
    ///	else
    ///	{
    ///		Print("Inactive");              // Program Is No Longer Active
    ///	}
    ///
    ///	break;                              // Return To The Message Loop
    ///}
    ///
    ///case WM_SYSCOMMAND:                     // Intercept System Commands
    ///{
    ///	switch (wParam)                     // Check System Calls
    ///	{
    ///	case SC_SCREENSAVE:                 // Screensaver Trying To Start?
    ///	case SC_MONITORPOWER:               // Monitor Trying To Enter Powersave?
    ///		return 0;                       // Prevent From Happening
    ///	}
    ///	break;                              // Exit
    ///}
    ///
    ///case WM_CLOSE:                          // Did We Receive A Close Message?
    ///{
    ///	Print("Close");
    ///	PostQuitMessage(0);                 // Send A Quit Message
    ///	break;    // Jump Back
    ///}
    ///
    ///case WM_KEYDOWN:                        // Is A Key Being Held Down?
    ///{
    ///	Application::getDevice().Keyboard.Keys[wParam] = true;                    // If So, Mark It As TRUE
    ///	break;                      // Jump Back
    ///}
    ///
    ///case WM_KEYUP:                        // Is A Key Being Held Down?
    ///{
    ///	Application::getDevice().Keyboard.Keys[wParam] = false;                    // If So, Mark It As TRUE
    ///	break;                      // Jump Back
    ///}
    ///
    ///case WM_MOUSEMOVE:
    ///{
    ///	 Application::getDevice().Mouse.Relative = Application::getDevice().Mouse.Position;
    ///	 Application::getDevice().Mouse.Position = { (float)GET_X_LPARAM(lParam),(float)GET_Y_LPARAM(lParam) };
    ///
    ///	 Application::getDevice().Mouse.Relative.x = Application::getDevice().Mouse.Position.x - Application::getDevice().Mouse.Relative.x;
    ///	 Application::getDevice().Mouse.Relative.y = Application::getDevice().Mouse.Position.y - Application::getDevice().Mouse.Relative.y;
    ///
    ///	Print("MouseMove:" <<  Application::getDevice().Mouse.Relative.x << " : " <<  Application::getDevice().Mouse.Relative.y);
    ///	Print("Position:" <<   Application::getDevice().Mouse.Position.x << " : " <<  Application::getDevice().Mouse.Position.y);
    ///
    ///}
    ///
    ///case WM_LBUTTONDOWN:
    ///{
    ///	Print("MouseDown");
    ///	break;
    ///}
    ///
    ///case WM_LBUTTONUP:
    ///{
    ///	Print("Left Button Up");
    ///	break;
    ///}
    ///
    ///case WM_LBUTTONDBLCLK:
    ///{
    ///	Print("L DClick ");
    ///	break;
    ///}
    ///
    ///case WM_RBUTTONDOWN:
    ///{
    ///	Print(" RButtonDown");
    ///	break;
    ///}
    ///
    ///case WM_RBUTTONUP:
    ///{
    ///	Print(" RButUP");
    ///	break;
    ///}
    ///
    ///case WM_RBUTTONDBLCLK:
    ///{
    ///	Print(" R Button DClick");
    ///	break;
    ///}
    ///
    ///case WM_MBUTTONDOWN:
    ///{
    ///	Print(" MButtonDown");
    ///	break;
    ///}
    ///
    ///case WM_MBUTTONUP:
    ///{
    ///	Print("M BUtton UP ");
    ///	break;
    ///}
    ///
    ///case WM_MBUTTONDBLCLK:
    ///{
    ///	Print(" MButton DClick");
    ///	break;
    ///}
    ///
    ///case WM_XBUTTONDOWN:
    ///{
    ///	Print(" XButtonDown");
    ///	break;
    ///}
    ///case WM_XBUTTONUP:
    ///{
    ///	Print(" X Up");
    ///	break;
    ///}
    ///
    ///case WM_XBUTTONDBLCLK:
    ///{
    ///	Print(" X DClick");
    ///	break;
    ///}
    ///
    ///case WM_SIZE:
    ///{
    ///	Application::getWindow().ResizeWindow(HIWORD(wParam), LOWORD(wParam));
    ///	break;
    ///}
    ///default:
    ///	return DefWindowProc(hwnd, uMsg, wParam, lParam);
    ///}



#if 0
while (true)
{
    MSG msg;
    BOOL bRet;
    while (PeekMessage(&msg, Application::getWindow().g_Handle(), 0, 0, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    Update();
    Render();
}
#else


Application::Window::Event::Event()
    :
    ID(0),
    ///WinID(0),
    Time(0)
{
    memset(&data, 0, 16);
}
Application::Window::Event::Event(MsgType msg)
    :
    ID(msg),
    ///WinID(0),
    Time(0)
{
    memset(&data, 0, 16);
}
*/
//struct Application
//{
//	struct Window
//	{
//		struct InputDevices
//		{
//			struct {}Mouse;
//			struct {}Keyboard;
//		}Input;
//		struct EventHandler
//		{}EventSystem;
//	}mainWindow;
//};
        /*
        struct Event
        {// Event Union Defining an Event the Engine can produce
            Event();
            Event(MsgType msg);

            MsgType ID;
            ///	WindowID WinID;
            unsigned long Time;
            Vec2 Location{ 0, 0 };
#pragma pack(push, 1)
            union msgUnion
            {// All messages are 128 bits
                msgUnion() = default;

                msgUnion& operator =(const msgUnion& other)
                {
                    memcpy(this, &other, sizeof(other)); // Should be 16 bytes, check this if any changes get made
                    return *this;
                }

                struct msgstruct
                {
                    uint32_t wordParam;
                    uint64_t longParam;
                    uint32_t Padding;
                }MSG; // 128 bits
                struct kbstruct
                {
                    uint32_t KeyCode;
                    uint32_t ScanCode;
                    uint32_t Action;
                    uint32_t Mods;
                }Keyboard; // 128
                struct mousestruct
                {
                    uint32_t Button;
                    uint32_t x;
                    uint32_t y;
                    int16_t relX;
                    int16_t relY;
                }Mouse; // 128
                struct buttonstruct
                {
                    struct buttons
                    {
                        uint8_t
                            Left,
                            Right,
                            Middle,
                            Wheel;
                    }Buttons; // 32
                    uint32_t Action;
                    uint32_t Modification;
                    uint32_t Padding;
                }MouseButton; // 128
                struct textstruct {}TextInput;
            }data;
#pragma pack(pop)
            Event(MSG _msg)
            {
                Location.x = _msg.pt.x;
                Location.y = _msg.pt.y;

                ID = _msg.message;
                this->data.MSG.longParam = _msg.lParam;
                this->data.MSG.wordParam = _msg.wParam;
                this->data.MSG.Padding = 0;
                this->Time = _msg.time;
            }
            bool Handled() { return (ID == 0); }
        };
*/

/*	{// OpenGL Rendering Context Scope
        //  wglCreateContext	    Creates a new rendering context.
        //  WglMakeCurrent	        Sets a thread's current rendering context.
        //  WglGetCurrentContext	Obtains a handle to a thread's current rendering context.
        //  WglGetCurrentDC      	Obtains a handle to the device context associated with a thread's current rendering context.
        //  WglDeleteContext	    Deletes a rendering context.

        GL_Context = wglCreateContext(DeviceContext);
        if (!wglMakeCurrent(DeviceContext, GL_Context))
        {
            std::cout << "Making Current Rendering Context Failed" << "\n";
        }
        if (!GL_Context)
        {
            MessageBox
            (/// Turn all this into a Macro for Clearity
                NULL,
                "GL Context Creation Failed  "
                "Cannot Create Renderer",
                "Error",
                MB_OK
            );
        }

        if (!gladLoadGL())
        {// If the Loading of OpenGL functions fails report it and exit
            int error_code = glad_glGetError();
            std::cout << "Failed to initialize GLAD" << error_code << std::endl;
            __debugbreak();
        };

        Title = std::string("OPENGL VERSION ") + std::string((char*) glGetString(GL_VERSION));
        SetWindowTextA
        (
            Handle,
            Title.c_str()
        );

        //  wglCreateContext	    Creates a new rendering context.
        //  WglMakeCurrent	        Sets a thread's current rendering context.
        //  WglGetCurrentContext	Obtains a handle to a thread's current rendering context.
        //  WglGetCurrentDC      	Obtains a handle to the device context associated with a thread's current rendering context.
        //  WglDeleteContext	    Deletes a rendering context.
    }*/


    ///std::ostream& operator <<(std::ostream& os, ErrorMessage& _msg)
///{
///	os << "Error: " << _msg.ErrorNumber << "\n At: " << _msg.Time << "\n ";
///	return os;
///}
///std::ostream& operator<<(std::ostream& stream, const Vec2& vector)
///{
///	stream << "X:[" << vector.x << "] - Y:[" << vector.y << "]";
///	return stream;
///std::string BasicVertexShader = "#version 330 \n\
///layout(location = 0) in vec3 VertexPosition;\n\
///out vec3 VertexColor;\n\
///out vec4 FragPosition;\n\
///void main()\n\
///{\n\
///FragPosition = vec4(VertexPosition.xyz, 1.0f);\n\
///VertexColor = vec3(1.0,1.0,1.0);\n\
///}";
///
///std::string BasicFragmentShader = "#version 330 \n\
///out vec4 color;         \n\
///in vec3 VertexColor;    \n\
///in vec4 FragPosition;   \n\
///void main(){            \n\
///color = vec3(1, 1, 0, 1);  \n\
///}";
///std::string VertexShader = " #version 330 core \n\
///layout(location = 0) in vec3 aPos; 			\n\
///uniform mat4 ProjectionMatrix;              \n\
///uniform mat4 ViewMatrix;                    \n\
///uniform mat4 ModelMatrix;                   \n\
///out vec4 vertexColor; 						\n\
///void main()									\n\
///{											\n\
///	gl_Position = vec4(aPos, 1.0);			\n\
///	vertexColor = vec4(0.5, 1.0, 0.0, 1.0); \n\
///}";
///vec4(texture(texture1,TexCoords.xy).xyzw); 
///std::string FragmentShader = "#version 330 core \n\
///out vec4 FragColor;                             \n\
///in vec4 vertexColor;                            \n\
///void main()                                     \n\
///{                                               \n\
///	FragColor = vertexColor;                    \n\
///}";
///
///    std::string vRenderer =
///    "#version 330 core \n\
///    layout(location = 0) in vec4 aPos;          \n\
///    uniform mat4 ProjectionMatrix;                    \n\
///    uniform mat4 ViewMatrix;                         \n\
///    uniform mat4 Model;                         \n\
///    out vec3 vertexColor;                       \n\
///    out vec2 TexCoords;                         \n\
///    void main()                                 \n\
///    {                                           \n\
///        mat4 ModelViewMatrix = (ViewMatrix * Model);  \n\
///        mat4 ModelViewProjectionMatrix = (ProjectionMatrix * ModelViewMatrix);\n\
///        TexCoords = aPos.zw;                          \n\
///        gl_Position = ModelViewProjectionMatrix * vec4(aPos.x, aPos.y, -1.0, 1.0); \n\
///    }";
///    std::string fRenderer =
///    "#version 330 core \n\
///    in vec3 vertexColor;                              \n\
///    uniform sampler2D texture1;                       \n\
///    out vec4 FragColor;                               \n\
///    in  vec2 TexCoords;                               \n\
///    void main()                                       \n\
///    {                                                 \n\
///        FragColor = vec4(texture(texture1,TexCoords.xy).xyzw);  \n\
///    }";
///    
===================== #APPLICATION_END
            
            

// ============================================================================================================================================================================
// ============================================================================================================================================================================
   











   
//DEBUGPrint(CON_DarkRed, "Created Queue: ");

//======================================================================================
//========================= DEBUG INFOMATION ======================================================
// #include<Windows.h>
// 
// extern HANDLE hConsole;
// #define SetColor(x) SetConsoleTextAttribute(hConsole, x);
// //
// //#define DEBUGPrint(col, x) {DEBUGMutex.lock();\
// //SetColor(col);\
// //std::thread::id CurrentThread = std::this_thread::get_id();\
// //std::cout <<  x << " : " << CurrentThread<< std::endl;\
// //SetColor(7);\
// DEBUGMutex.unlock();}
// #define DEBUGPrint(col,x)
// extern std::mutex DEBUGMutex;
// 
//======================================================================================
//======================================================================================
//	_function->ThreadID = std::this_thread::get_id();
//				std::thread::id ThreadID{ std::this_thread::get_id() };
//HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
// template<typename _FUNC, typename...ARGS >
// auto Launch_Now(_FUNC&& _func, ARGS&&... args)
// {
// 	return _func(args...);					DEBUGPrint(CON_DarkPurple, " Call from a Different Thread");
// 
// }

//std::printf(x );\
//DEBUGPrint(CON_DarkYellow, "Async Called: " << &_func);
//	Print(typeid(_func).
//int PushColor = 2;
//int PopColor = 3;
//std::mutex DEBUGMutex;

//DEBUGPrint(CON_Green, "Function Called from " << _func->ThreadID << "- Pop CurrentThread: \n");
//DEBUGPrint(PopColor,"%d \n", _func->ThreadID);
//DEBUGPrint(PopColor, "- Pop CurrentThread: \n");

//DEBUGPrint(CON_Blue, "Func Address: 0x" << &_func);
//DEBUGPrint(CON_Red, "Try Push CurrentThread: ");

//DEBUGPrint(CON_DarkBlue, "Func Address: 0x" << &_func);
//DEBUGPrint(CON_DarkRed, "Push CurrentThread: ");

//DEBUGPrint(PopColor, "Function Called from "); DEBUGPrint(PopColor,"%d \n", _func->ThreadID); DEBUGPrint(PopColor, "- Pop CurrentThread: \n");
//DEBUGPrint(CON_DarkGreen, "Function Called from " << _func->ThreadID << "- Pop CurrentThread:");

				//Print(Main_ThreadID << std::thread::this_thread.get_id());
				//DEBUGPrint(CON_Yellow, "Running Function: " << Function->ThreadID);


   
   
   
   if (_func->LaunchThread == QueueID) Print("Job Pushed to Thread it was Launched from. Possible Error if Recursive Call made ");

                if (_func->LaunchThread == QueueID) Print("Job Pushed to Thread it was Launched from. Possible Error if Recursive Call made ");


//template<typename _R>
//bool is_ready(Future<_R> & _fut)
//{
//	return _fut.valid();
//}

#include<csetjmp>
#define PRINT_Thread(x)   Print(x);\
                          std::thread::id CurrentThread = std::this_thread::get_id();\
                          Print("Current Thread " << CurrentThread << "Launched Thread: " << LaunchThread)


#if 1
			/* Executor for our Threadpool Allocating our Asyncronous objects, returning their Futures an handles work sharing throughout all the available Queues*/
			///<Possibly to avoid Code bloat Make Async create the asynTask and Future and cast the task to Executionwer before sending it to the rest of the function to process>
			///<This way it will only duplicate the Async code and not the rest when not needed>
			template<typename _FUNC, typename...ARGS >
			auto Async(_FUNC&& _func, ARGS&&... args)->std::future<typename asyncTask<_FUNC, ARGS... >::type>
			{// Accept arbitrary Function signature, Bind its arguments and add to a Work pool for Asynchronous execution


				auto _function = new asyncTask<_FUNC, ARGS... >(std::move(_func), std::forward<ARGS>(args)...);  // Create our task which binds the functions parameters
				auto result = _function->get_future();                                                           // Get the future of our async task for later use
				Submit(static_cast<Executor*>(_function));
                return result;
            }

			void Submit(Executor *_task)
			{
				auto i = Index++;  
				auto ThreadID = std::this_thread::get_id();

							
			/*     SUSPEND: Attempt at making a Fork point so the current location of the program is pushed to the 
			    Threadpool to allow the child function to return first

			*********INCOMPLETE*********/
			template<typename _Func, typename ...ARGS>
            struct Suspend final
				: public Executor
            {	
				NO_COPY_OR_ASSIGNMENT(Suspend);

				using child_type = std::invoke_result_t<_Func, ARGS...>;
            	virtual ~Suspend() noexcept = default; // Virtual destructor to ensure proper Deallocation of object
				std::jmp_buf* Context{}; // This thing gets in the way with Cryptic Error message if not properly initialize so I am using pointer
				int Return{ -1 };
            	/* Pushes current Threads execution to our Queue */
				Suspend(std::jmp_buf* _context, _Func&& _function, ARGS&&... _args) noexcept
					:
					Context( _context ),
					Function(std::forward<_Func>(_function)),
					Arguments(std::forward<ARGS>(_args)...)
            	{ 
					Status = Valid;
					PRINT_Thread("Suspend Thread: ");
				}

            	/* Returns Execution to where previously suspend */
            	virtual void Invoke() noexcept override
            	{
					PRINT_Thread("Suspend Thread Invoke: ");
 				    Status = Waiting;
				    auto result = std::apply(Function, Arguments); // Can not continue on until function returns which goes into result
					ReturnValue.set_value(result);// Result sets the return value of the future. Our main thread is allowed to Run now...

            	}
            
				auto get_future() noexcept
				{ 
					PRINT_Thread("Getting the Future of the Suspended Task ");
					Status = Submitted;

					return ReturnValue.get_future();
				}

				void set_return(child_type& _value)
				{
					PRINT_Thread("Setting Value of the Suspended Task. ");
					ReturnValue.set_value(_value);
				}

            private:
				using Fptr = child_type(*)(ARGS...);    // Function pointer type for our function
				const Fptr Function;                    // Pointer to our Child Function
				const std::tuple<ARGS...> Arguments;    // Tuple which Binds the Parameters to the Child Function call
				std::promise<child_type> ReturnValue;   // Return Value of our function stored as a Promise
            };




///<Possibly to avoid Code bloat Make Async create the asynTask and Future and cast the task to Executionwer before sending it to the rest of the function to process>
///<This way it will only duplicate the Async code and not the rest when not needed>

				
				auto ThreadID = std::this_thread::get_id();
				//===================================== IF TASK WAS LANCHED FROM ANOTHER RUNNING TASK ==================================================
				//if (Main_ThreadID != ThreadID)                // If this is being call from one of the Threadpool Threads.
				//{// If not our main thread run now
				//	_function->Invoke();                                                                         // Invoke Immediately as our Thread is alreadylocked up
				//	delete& (*_function);                                                                       // Destroy the Object which our Async Class Allocated
				//	return result;
				//}
				//======================================================================================================================================




				//===================================== IF TASK WAS LANCHED FROM ANOTHER RUNNING TASK ==================================================
				//if (Main_ThreadID != ThreadID)                // If this is being call from one of the Threadpool Threads.
				//{// If not our main thread run now
				//	_function->Invoke();                                                                         // Invoke Immediately as our Thread is alreadylocked up
				//	delete& (*_function);                                                                       // Destroy the Object which our Async Class Allocated
				//	return result;
				//}
				//======================================================================================================================================
																												 // Ensure fair work distribution
				int Attempts = 5;
				for (unsigned int n{ 0 }; n != ThreadCount * Attempts; ++n)                                      // Attempts is Tunable for better work distribution
				{// Cycle over all Queues K times and attempt to push our function to one of them

					if (ThreadQueue[static_cast<size_t>((i + n) % ThreadCount)].try_push(_task))
					{// If succeeded return our functions Future
						return;
					}
				}

				// In the rare instance that all attempts at adding work fail just push it to the Owned Queue for this thread
				ThreadQueue[i % ThreadCount].push(_task);
				return;
			}
#else








// Mat4 Rotate_Translate(Vec3 _pos, Vec3 _rot)
// {
//     return glm::rotate
//     ( // ensure unneeded copying as the results from the last transform are immediately used in the next step
//         glm::rotate
//         (
//             glm::rotate
//             (
//                 glm::translate
//                 ( // Starts with the Translation here
//                     glm::mat4(1.0f),
//                     _pos
//                 ),
//                 glm::radians(_rot.x),
//                 Vec3(1.0f, 0.0f, 0.0f)),
//             glm::radians(_rot.y),
//             Vec3(0.0f, 1.0f, 0.0f)),
//         glm::radians(_rot.z),
//         Vec3(0.0f, 0.0f, 1.0f)
//     );
// }
		
/*
Co-Routine implementation
https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
In the context of the C programming language, function arguments are pushed on the stack in the right-to-left order,
i.e. the last argument is pushed first. In Linux, GCC sets the de facto standard for calling conventions. Since GCC version 4.5,
the stack must be aligned to a 16-byte boundary when calling a function (previous versions only required a 4-byte alignment.)

C++ Calling Conventions in ASM

_CDECL

caller:
	; make new call frame
	; (some compilers may produce an 'enter' instruction instead)
	push    ebp       ; save old call frame
	mov     ebp, esp  ; initialize new call frame
	; push call arguments, in reverse
	; (some compilers may subtract the required space from the stack pointer,
	; then write each argument directly, see below.
	; The 'enter' instruction can also do something similar)
	; sub esp, 12      : 'enter' instruction could do this for us
	; mov [ebp-4], 3   : or mov [esp+8], 3
	; mov [ebp-8], 2   : or mov [esp+4], 2
	; mov [ebp-12], 1  : or mov [esp], 1
	push    3
	push    2
	push    1
	call    callee    ; call subroutine 'callee'
	add     eax, 5    ; modify subroutine result
					  ; (eax is the return value of our callee,
					  ; so we don't have to move it into a local variable)
	; restore old call frame
	; (some compilers may produce a 'leave' instruction instead)
	; add   esp, 12   ; remove arguments from frame, ebp - esp = 12.
					  ; compilers will usually produce the following instead,
					  ; which is just as fast, and, unlike the add instruction,
					  ; also works for variable length arguments
					  ; and variable length arrays allocated on the stack.
	mov     esp, ebp  ; most calling conventions dictate ebp be callee-saved,
					  ; i.e. it's preserved after calling the callee.
					  ; it therefore still points to the start of our stack frame.
					  ; we do need to make sure
					  ; callee doesn't modify (or restores) ebp, though,
					  ; so we need to make sure
					  ; it uses a calling convention which does this
	pop     ebp       ; restore old call frame
	ret               ; return

*/







/* 
_DATA SEGMENT
hello_msg db "Hello world", 0
info_msg  db "Info", 0
_DATA ENDS
To define read-only and executable data, do that inside the text segment:

_TEXT    SEGMENT
hello_msg db "Hello world", 0
info_msg  db "Info", 0
_TEXT    ENDS

EXTERN c_ext_byte: byte
EXTERN c_ext_word: word
EXTERN c_ext_dword: dword
EXTERN c_ext_qword: qword
EXTERN c_ext_ptr: qword
EXTERN c_ext_my_function: PROC
EXTERN MessageBoxA: PROC
EXTERN GetForegroundWindow: PROC

PUBLIC access_extern_data
access_extern_data PROC
; Dereference all the data according to each data's sizes
mov    al, byte ptr [c_ext_byte]
mov ax, word ptr [c_ext_word]
mov eax, dword ptr [c_ext_dword]
mov rax, qword ptr [c_ext_qword]
; Remember, a pointer is just a QWORD
mov rax, qword ptr [c_ext_ptr]
; Similarily, a function pointer is also a QWORD
mov rax, offset c_ext_my_function
sub rsp, 4 * 8 ; Register shadow stack
call rax ; call the C function
add rsp, 4 * 8 ; Restore the stack
ret
access_extern_data ENDP

EXTERN MessageBoxA: PROC
EXTERN GetForegroundWindow: PROC
PUBLIC hello_world_asm
hello_world_asm PROC
push rbp ; save frame pointer
mov rbp, rsp ; fix stack pointer
sub rsp, 8 * (4 + 2) ; allocate shadow register area + 2 QWORDs for stack alignment
; Get a window handle
call GetForegroundWindow
mov rcx, rax
; WINUSERAPI int WINAPI MessageBoxA(
;  RCX =>  _In_opt_ HWND hWnd,
;  RDX =>  _In_opt_ LPCSTR lpText,
;  R8  =>  _In_opt_ LPCSTR lpCaption,
;  R9  =>  _In_ UINT uType);
mov rdx, offset hello_msg
mov r8, offset info_msg
mov r9, 0 ; MB_OK
and rsp, not 8 ; align stack to 16 bytes prior to API call
call MessageBoxA
; epilog. restore stack pointer
mov rsp, rbp
pop rbp
ret
hello_world_asm ENDP

*/ 
/*==================================================================================================================
/*                                                TRASH   #RenderUtilities 1/22/2020
/*==================================================================================================================*/

                   //glBindBuffer(GL_ARRAY_BUFFER, VBO);
                   //{
                   //    glDrawArrays(GL_TRIANGLES, 0, 6);
                   //}
                   //glBindBuffer(GL_ARRAY_BUFFER, 0);

/*

//Vec4 Vertices[4] =
//{
//	{ -1.0, -1.0,             0.0, 0.0 },
//	{  0.0, -1.0,             1.0, 0.0 },
//	{  0.0,  0.0,             1.0, 1.0 },
//	{ -1.0,  0.0,             0.0, 1.0 }
//};
		//float S = 1.2;
		float S = 200.2;
		Vec2 UVcoords[4] =
		{
			{  },
			{  },
			{  },
			{  }
		};

			Vec4 Vertices[6] =
			{   // positions   // texCoords
				Vec4(-S,  S,    0.0f,  1.0f),
				Vec4(-S, -S,    0.0f,  0.0f),
				Vec4( S, -S,    1.0f,  0.0f),
				Vec4(-S,  S,    0.0f,  1.0f),
				Vec4( S, -S,    1.0f,  0.0f),
				Vec4( S,  S,    1.0f,  1.0f)
			}; */

//ReadBuffer[x + (int)Size.x * y].r = R;
//ReadBuffer[x + (int)Size.x * y].g = G;
//ReadBuffer[x + (int)Size.x * y].b = B;
   //ReadBuffer[x + (int)Size.x * y] = Pixel(R, G, B, 255);
   //if (x % 2 == 0)
   //{
//	WriteBuffer[x + (int)Size.x * y].g = 0;
//	WriteBuffer[x + (int)Size.x * y].b = 0;
//	WriteBuffer[x + (int)Size.x * y].a = 0;
	//ReadBuffer[x + (int)Size.x * y].r = R;
	//ReadBuffer[x + (int)Size.x * y].g = G;
	//ReadBuffer[x + (int)Size.x * y].b = B;
	//ReadBuffer[x + (int)Size.x * y].g = 255;
	//setPixel(x, y, Pixel(255, 255, 255, 255));//rabg

//	setPixel(x, y, Pixel(0, 255,  0, 0));//rabg
	//setPixel(x, y, Pixel(0, 0, 255, 0));//rabg
//	setPixel(x, y, Pixel(0, 0, 0, 255));//rabg
//}

//vec4(vertexColor.xyz, 1.0); 

/*	vertexColor = texture(texture1, aPos.zw).xyz; \n\

"#version 330\
uniform mat4 ProjectionMatrix;\
uniform mat4 ViewMatrix;\
uniform mat4 ModelMatrix;\
layout(location = 0) in vec3 VertexPosition;\
layout(location = 1) in vec2 TextureCoord;\
out vec2 FPosition;\
out vec2 TCoord;\
void main(){\
	mat4 ModelViewMatrix = (ViewMatrix * ModelMatrix);\
	mat4 ModelViewProjectionMatrix = (Matrix.projection * ModelViewMatrix);\
	vec4 WorldPosition = vec4(VertexPosition, 1.0f);\
	FPosition = (ModelMatrix * vec4(VertexPosition, 1.0f)).xyz;\
	TCoord = TextureCoord;\
	gl_Position = ModelViewProjectionMatrix * vec4(VertexPosition.xyz, 1.0f);\
}\

"#version 330\
in vec3 FPosition;\
in vec2 TCoord;\
out vec4 FragColor;\
void main()\
{\
	vec4 color = texture(sampler2D(DiffuseTexture), TCoord.xy);\
	FragColor = color;\
}

*/

//	setPixel(20, 0, 100);
	/*
		W --- > R --- W ---
		//memcpy((char*)ReadBuffer + (LineSize - sizeof(Pixel)), (char*)WriteBuffer, size() - (LineSize - sizeof(Pixel)));

	*/













#TRASHEDSHADER
//VertID = glCreateShader(GL_VERTEX_SHADER);
//FragID = glCreateShader(GL_FRAGMENT_SHADER);
//
//std::string vertSourceString = vert;
//std::string fragSourceString = frag;
//
//const char* vertSource = vertSourceString.c_str();
//const char* fragSource = fragSourceString.c_str();
//
//glShaderSource(VertID, 1, &vertSource, NULL);
//glCompileShader(VertID);
//GetShaderError(Vert);
//
//glShaderSource(FragID, 1, &fragSource, NULL);
//glCompileShader(FragID);
//GetShaderError(Frag);
//
//glAttachShader(GL_Handle, VertID);
//glAttachShader(GL_Handle, FragID);
//glLinkProgram(GL_Handle);
//GetShaderError(Program);
//
//glValidateProgram(GL_Handle);
//glDetachShader(GL_Handle, VertID);
//glDetachShader(GL_Handle, FragID);
//glDeleteShader(VertID);
//glDeleteShader(FragID);
//
//glUseProgram(GL_Handle);

#if 0
	// Create the shaders
	uint32_t ERR = 0;
	if ((ERR = glGetError()))
	{
		Print("Error" << ERR);
		__debugbreak();
	}

	uint32_t VertexShaderID   = glCreateShader(GL_VERTEX_SHADER);
	uint32_t FragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);

	// Read the Vertex Shader code from the file
	std::string VertexShaderCode = VertexShader;
	std::string FragmentShaderCode = FragmentShader;


	GLint Result = false;
	int InfoLogLength{ 0 };

	// Compile Vertex Shader
	//printf("Compiling shader : %s\n", vertex_file_path);
	char const* VertexSourcePointer = VertexShaderCode.c_str();
	glShaderSource(VertexShaderID, 1, &VertexSourcePointer, NULL);
	glCompileShader(VertexShaderID);

	// Check Vertex Shader
	glGetShaderiv(VertexShaderID, GL_COMPILE_STATUS, &Result);
	glGetShaderiv(VertexShaderID, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> VertexShaderErrorMessage;
		VertexShaderErrorMessage.resize(InfoLogLength + 1);

		glGetShaderInfoLog(VertexShaderID, InfoLogLength, NULL, &VertexShaderErrorMessage[0]);
		printf("%s\n", &VertexShaderErrorMessage[0]);
	}

	// Compile Fragment Shader
	char const* FragmentSourcePointer = FragmentShaderCode.c_str();
	glShaderSource(FragmentShaderID, 1, &FragmentSourcePointer, NULL);
	glCompileShader(FragmentShaderID);

	// Check Fragment Shader
	glGetShaderiv(FragmentShaderID, GL_COMPILE_STATUS, &Result);
	glGetShaderiv(FragmentShaderID, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> FragmentShaderErrorMessage;
		FragmentShaderErrorMessage.resize(InfoLogLength + 1);
		glGetShaderInfoLog(FragmentShaderID, InfoLogLength, NULL, &FragmentShaderErrorMessage[0]);
		printf("%s\n", &FragmentShaderErrorMessage[0]);
	}

	// Link the program
	printf("Linking program\n");
	 BasicShader = glCreateProgram();
	 glAttachShader(BasicShader, VertexShaderID);
	 glAttachShader(BasicShader, FragmentShaderID);
	 glLinkProgram(BasicShader);
	 
	// Check the program
	 glGetProgramiv(BasicShader, GL_LINK_STATUS, &Result);
	 glGetProgramiv(BasicShader, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> ProgramErrorMessage;
		ProgramErrorMessage.resize(InfoLogLength + 1);
	 	glGetProgramInfoLog(BasicShader, InfoLogLength, NULL, &ProgramErrorMessage[0]);
		printf("%s\n", &ProgramErrorMessage[0]);
	}

	 glDetachShader(BasicShader, VertexShaderID);
	 glDetachShader(BasicShader, FragmentShaderID);
	 
	 glDeleteShader(VertexShaderID);
	 glDeleteShader(FragmentShaderID);

	ERR = 0;
	 if ((ERR = glGetError()))
	 {
	 	Print("Error" << ERR);
	 	__debugbreak();
	 }
#else
	// Create the shaders
#if 0
	CheckGLERROR();

	VertID = glCreateShader(GL_VERTEX_SHADER);
	FragID = glCreateShader(GL_FRAGMENT_SHADER);

	// Read the Vertex Shader code from the file
	std::string VertexShaderCode = _vertstring;
	std::string FragmentShaderCode = _fragstring;


	GLint Result = false;
	int InfoLogLength{ 0 };

	// Compile Vertex Shader
	//printf("Compiling shader : %s\n", vertex_file_path);
	const char * VertexSourcePointer = VertexShaderCode.c_str();
	glShaderSource(VertID, 1, &VertexSourcePointer, NULL);
	glCompileShader(VertID);

	// Check Vertex Shader
	glGetShaderiv(VertID, GL_COMPILE_STATUS, &Result);
	glGetShaderiv(VertID, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> VertexShaderErrorMessage;
		VertexShaderErrorMessage.resize(InfoLogLength + 1);

		glGetShaderInfoLog(VertID, InfoLogLength, NULL, &VertexShaderErrorMessage[0]);
		printf("%s\n", &VertexShaderErrorMessage[0]);
	}

	// Compile Fragment Shader
	char const* FragmentSourcePointer = FragmentShaderCode.c_str();
	glShaderSource(FragID, 1, &FragmentSourcePointer, NULL);
	glCompileShader(FragID);

	// Check Fragment Shader
	glGetShaderiv(FragID, GL_COMPILE_STATUS, &Result);
	glGetShaderiv(FragID, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> FragmentShaderErrorMessage;
		FragmentShaderErrorMessage.resize(InfoLogLength + 1);
		glGetShaderInfoLog(FragID, InfoLogLength, NULL, &FragmentShaderErrorMessage[0]);
		printf("%s\n", &FragmentShaderErrorMessage[0]);
	}

	// Link the program
	printf("Linking program\n");
	GL_Handle = glCreateProgram();
	glAttachShader(GL_Handle, VertID);
	glAttachShader(GL_Handle, FragID);
	glLinkProgram(GL_Handle);

	// Check the program
	glGetProgramiv(GL_Handle, GL_LINK_STATUS, &Result);
	glGetProgramiv(GL_Handle, GL_INFO_LOG_LENGTH, &InfoLogLength);
	if (InfoLogLength > 0) {
		std::vector<char> ProgramErrorMessage;
		ProgramErrorMessage.resize(InfoLogLength + 1);
		glGetProgramInfoLog(GL_Handle, InfoLogLength, NULL, &ProgramErrorMessage[0]);
		printf("%s\n", &ProgramErrorMessage[0]);
	}

	glDetachShader(GL_Handle, VertID);
	glDetachShader(GL_Handle, FragID);

	glDeleteShader(VertID);
	glDeleteShader(FragID);

	CheckGLERROR();

#else

/*
	enum ShaderType { VERTEX, FRAGMENT, PROGRAM };
  
	VertID = glCreateShader(GL_VERTEX_SHADER);
	FragID = glCreateShader(GL_FRAGMENT_SHADER);

 	const char* vertSource = _vertstring.c_str();
	const char* fragSource = _fragstring.c_str();
 
	

	glShaderSource(VertID, 1, &vertSource, NULL);
	glCompileShader(VertID);
	GetShaderError(Vert);
 
	CheckGLERROR();

	glShaderSource(FragID, 1, &fragSource, NULL);
	glCompileShader(FragID);
	GetShaderError(Frag);
	uint32_t ERR = 0;
	
	CheckGLERROR();

	glAttachShader(GL_Handle, VertID);
	glAttachShader(GL_Handle, FragID);
	glLinkProgram(GL_Handle);
	GetShaderError(Program);

	CheckGLERROR();

	glValidateProgram(GL_Handle);
	glDetachShader(GL_Handle, VertID);
	glDetachShader(GL_Handle, FragID);
	glDeleteShader(VertID);
	glDeleteShader(FragID);

	glUseProgram(GL_Handle);

	CheckGLERROR();

	return;
 */
#endif

 ==================================================================================================================================================================================
            #12/19															  															  
            #Threadpool.h		
            #Reason: Move constructor and Move Assign were never called so they are unneeded
====================================================================================================================================================================================
Perhaps I will want them later because I considered moving the object around but currently managing its Pointer to base has been relatively effective

/*      Possibly not needed but created Move and Assignment Operators just in case.
	NOTE: May remove in the future as neither of these are ever calls and the user is incapable of */
asyncTask(asyncTask&& _other) noexcept
	:
	Function(std::move(_other.Function)),
	Arguments(std::forward<ARGS>(_other.Arguments)),
	ReturnValue(std::move(_other.ReturnValue))
{// This test has shown it never gets called throughout the objects lifetime
	std::cout << "Called the Forward Function" << "\n";
}
asyncTask& operator=(asyncTask&& _other) noexcept
{// Nor does this
	Function = std::move(_other.Function);
	Arguments = std::forward<ARGS>(_other.Arguments);
	ReturnValue = std::move(_other.ReturnValue);
	std::cout << "Called Assignment Operator " << "\n";
}

 ==================================================================================================================================================================================
                                                               #11/28															  															  
															  #Threadpool.cpp/h		
															  #Reason: Unable to access these due to Threadpool managing and owning asyncTask Objects
====================================================================================================================================================================================

This was removed as it appears to not be needed. Try to keep this in mind because it may have been more proper than now current method
// typename std::decay_t<_Func>, typename std::decay_t<ARGS>... > ; //std::invoke_result_t<_Func&, ARGS&...>;




//template<typename _F, typename ...ARGS>
//uint16_t Wrapper<_F, ARGS...>::Offset{ 0 };




				type get()
				{
					Status = Aquired;
					ReturnValue.get();
				}
				bool is_ready()
				{
					return ReturnValue.valid() ? (ReturnValue.wait_for(std::chrono::seconds(0)) == std::future_status::ready) : false;
				}


 ==================================================================================================================================================================================
                                                               #11/28															  															  
															  #Threadpool.cpp/h		
															  #IMPORTANT
															  #Reason: Cleanup of experimental Threadpool and Worker class
====================================================================================================================================================================================


include<iostream>
#include<Windows.h>
#pragma optimize( "", off )

#define MY_WRAPPER
#define _PROFILE_MEMORY

#include"Profiling\SystemInfo.h"
#include"Profiling\MemoryPerf\MemTracker.h"
#include"Core\Threading\Threadpool.h"
#include"Profiling\Timing\Benchmark.h"

#include"Core\Common.h"

using namespace Core;
using namespace Threading;
//#define LOOP_COUNT 100
int LOOP_COUNT = 10000;
#include<string>
/*
Physics Solver:    https://www.gdcvault.com/play/1013359/High-Performance-Physics-Solver-Design
*/

/*
template <class F, class Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& t);
*/


void  P0R0()
{
	std::cout << "P0R0" << "\n";
}
float P1R1(int _param)
{
	std::cout << "P1R1: " << _param << "\n";
	return static_cast<float>(_param * _param);
}
void  P1R0(int _param)
{
	std::cout << "P1R0:" << _param << "\n";
}
void  P2R0(int _param, int _param2)
{
	std::cout << "P1R0:" << _param << ":" << _param2 << "\n";
}
int   P0R1()
{
	std::cout << "P0R1" << "\n";
	return 42;
}

//void operator()(_Func&& _function, _Args&&..._args)
//{
//	return _function(_args...);
//}



/*
struct A { int x; int y; int z; };
A a{.y = 2, .x = 1}; // error; designator order does not match declaration order
A b{.x = 1, .z = 2}; // ok, b.y initialized to 0


		_Ret operator()(_Args&&..._args)
		{
			return FuncStorage(_args...);
		}
*/

/// aggregate in C++17/*
/*
			auto A = new(alloca(sizeof(Wrapper<decltype(TestFunctionE), int>))) Wrapper(TestFunctionE, std::move(LOOP_COUNT));
			auto B = alloca(Wrapper(TestFunctionB, 1431);
			auto C = alloca(Wrapper(TestFunctionD, 123.321f, 10);
			auto D = alloca(Wrapper(TestFunctionA);
			auto E = alloca(Wrapper(TestFunctionC, 3.14159f, 123);
			auto F = alloca(Wrapper(TestFunctionF, std::move(LOOP_COUNT));
			auto G = alloca(Wrapper(TestFunctionG, std::move(LOOP_COUNT));
			auto H = alloca(Wrapper(TestFunctionH, std::move(LOOP_COUNT));
			auto I = alloca(Wrapper(TestFunctionI, std::move(LOOP_COUNT));
			auto J = alloca(Wrapper(TestFunctionJ, std::move(LOOP_COUNT));
			auto K = alloca(Wrapper([](int)->int { Print("Lambda Function Threadpool call"); return 11; }, 10000);


*/

OPTIMIZATION_OFF()
/*

(alloca(sizeof(Wrapper<decltype(TestFunctionE), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionB), int >)))
(alloca(sizeof(Wrapper<decltype(TestFunctionD),float,int >)))
(alloca(sizeof(Wrapper<decltype(TestFunctionA)  >)))
(alloca(sizeof(Wrapper<decltype(TestFunctionC),float,int >)))
(alloca(sizeof(Wrapper<decltype(TestFunctionF), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionG), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionH), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionI), int>)))
(alloca(sizeof(Wrapper<decltype(TestFunctionJ), int>)))

*/
#define NUMBER_OF_THREADS 2000
int main()
{/* Open STD http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3857.pdf */
	ThreadPool::get();

#ifdef MY_WRAPPER
	while (true)
	{
		//alloca()
		Function_Counter = 0;
		LOOP_COUNT += 1000;// 22100 is when Threadpool and Linear start to become one.
		Print("\n\n\n\n Loop Counter:" << LOOP_COUNT << " iterations in the Worker Functions\n");

		Profiling::Timing::Profile_Timer<100> Bench;
		{
			std::vector<std::vector<uint32_t>> Test;

			///      auto L = new auto A = new asyncTask(TestFunctionE, std::move(LOOP_COUNT));
			auto Af = Core::Threading::ThreadPool::get().Async([] {int ret = 10; return ret; });

			auto A = ThreadPool::get().Async(TestFunctionE, std::move(LOOP_COUNT));
			auto B = ThreadPool::get().Async(TestFunctionE, std::move(LOOP_COUNT));
			auto C = ThreadPool::get().Async(TestFunctionB, 1431);
			auto D = ThreadPool::get().Async(TestFunctionD, 123.321f, 10);
			auto E = ThreadPool::get().Async(TestFunctionA);
			auto F = ThreadPool::get().Async(TestFunctionC, 3.14159f, 123);
			auto G = ThreadPool::get().Async(TestFunctionF, std::move(LOOP_COUNT));
			auto H = ThreadPool::get().Async(TestFunctionG, std::move(LOOP_COUNT));
			auto I = ThreadPool::get().Async(TestFunctionH, std::move(LOOP_COUNT));
			auto J = ThreadPool::get().Async(TestFunctionI, std::move(LOOP_COUNT));
			auto K = ThreadPool::get().Async(TestFunctionJ, std::move(LOOP_COUNT));

//new asyncTask(TestFunctionB, 1431);
//new asyncTask(TestFunctionD, 123.321f, 10);
//new asyncTask(TestFunctionA);
//new asyncTask(TestFunctionC, 3.14159f, 123);
//new asyncTask(TestFunctionF, std::move(LOOP_COUNT));
//new asyncTask(TestFunctionG, std::move(LOOP_COUNT));
//new asyncTask(TestFunctionH, std::move(LOOP_COUNT));
//new asyncTask(TestFunctionI, std::move(LOOP_COUNT));     auto  TPTest5 = ThreadPool::get().Async(A);
//new asyncTask(TestFunctionJ, std::move(LOOP_COUNT));     auto  TPTest1 = ThreadPool::get().Async(B);
//new asyncTask([](int)->int { Print("Lambda Function Threadpool call"); return 11; }, 10000);     auto  TPTest4 = ThreadPool::get().Async(C);
//new asyncTask(TestFunctionLarge, (uint64_t)(rand() % 1000), (uint64_t)(rand() % 1000), (uint64_t)(rand() % 1000), (uint64_t)(rand() % 1000), (uint64_t)(rand() % 1000));     auto  TPTest3 = ThreadPool::get().Async(D);
  
// auto  TPTest2 = ThreadPool::get().Async(E);
// auto  TPTest6 = ThreadPool::get().Async(F);
// auto  TPTest7 = ThreadPool::get().Async(G);
// auto  TPTest8 = ThreadPool::get().Async(H);
// auto  TPTest9 = ThreadPool::get().Async(I);
// auto TPTest10 = ThreadPool::get().Async(J);
// auto TPTest11 = ThreadPool::get().Async(K);
     
		//	ThreadPool::get().Async(TestFunctionE, std::move(LOOP_COUNT));
			//Sleep(5);
			Print("Thread Pool Cluster");

			std::vector<std::future<float>> Fut;
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				auto F = ThreadPool::get().Async(TestFunctionC, 123.321f, std::move(i));
				Fut.push_back(std::forward<std::future<float>>(F));
			}	

			uint64_t result{ 0 };
			int counter = Fut.size();
			int C2{ 0 }, C3{ 0 };
//for (auto& G : Fut)
//{
//	result += G.get();
//	GotFuture--;
//}
			while (counter)
			{
				for (auto& F : Fut)
				{
					if (!is_ready(F))
					{/* if not ready yet, check the next */
						++C2;
						continue;
					}
					result += F.get(); /* it is ready */
					//Print("Result: " << result);
					++C3;
					--counter;
				}
			}

			Print("End Thread Pool Cluster: " << result);

//   Test.push_back(TPTest6.get());
//   Test.push_back(TPTest7.get());
//   Test.push_back(TPTest8.get());
//   Test.push_back(TPTest9.get());
//   Test.push_back(TPTest10.get());

			while (Function_Counter < 10) {/* SpinLock until every single function called returns as measured via the atomic int Function_Counter. */ }

		 	Print("Threadpool: " << result);
		 	//Print("ThreadPool: " << TPTest4.get() << " : " << TestCompile(Test));
///
///		//	delete A; delete B; delete C; delete D; delete E; delete F; delete G; delete H; delete I; delete J;
///		//	delete K;
///
 			Bench.Stop();
		}
 
		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> ThreadBM;
		{
			auto  TPTest5T = std::async(std::launch::async | std::launch::deferred, TestFunctionE, LOOP_COUNT);
			auto  TPTest1T = std::async(std::launch::async | std::launch::deferred, TestFunctionB, 1431);
			auto  TPTest4T = std::async(std::launch::async | std::launch::deferred, TestFunctionD, 123.321f, 10);
			auto  TPTest3T = std::async(std::launch::async | std::launch::deferred, TestFunctionA);
			auto  TPTest2T = std::async(std::launch::async | std::launch::deferred, TestFunctionC, 3.14159f, 123);
			auto  TPTest6T = std::async(std::launch::async | std::launch::deferred, TestFunctionF, LOOP_COUNT);
			auto  TPTest7T = std::async(std::launch::async | std::launch::deferred, TestFunctionG, LOOP_COUNT);
			auto  TPTest8T = std::async(std::launch::async | std::launch::deferred, TestFunctionH, LOOP_COUNT);
			auto  TPTest9T = std::async(std::launch::async | std::launch::deferred, TestFunctionI, LOOP_COUNT);
			auto TPTest10T = std::async(std::launch::async | std::launch::deferred, TestFunctionJ, LOOP_COUNT);
			auto TPTest11T = new  asyncTask([](int)->int { Print("Lambda Function Call std::Async"); return 11; }, 10000);

			Print("Async Cluster");
			std::vector<std::future<float>> Fut;
	        for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
	        {
	        	auto TPTest4loop = std::async(std::launch::async, TestFunctionC, 123.321f, i);
				Fut.push_back(std::move(TPTest4loop));
	        }	
			Print("End Async Cluster");


			uint64_t result{ 0 };
			int counter = Fut.size();
			while (counter)
			{
				for (auto& F : Fut)
				{
					if (!is_ready(F))
					{// if not ready yet, check the next  
						continue;
					}
					result += F.get(); // it is ready 
					--counter;
				}
			}
			Print("Async :" << result);
			while (Function_Counter < 10) {// SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
 }
			std::vector<std::vector<uint32_t>> Test;

			Test.push_back(TPTest5T.get());
			Test.push_back(TPTest6T.get());
			Test.push_back(TPTest7T.get());
			Test.push_back(TPTest8T.get());
			Test.push_back(TPTest9T.get());
			Test.push_back(TPTest10T.get());
			Print("Async: " << TPTest4T.get() << " : " << TestCompile(Test));

			ThreadBM.Stop();
		}


		uint64_t  results;
		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> LBench;
		{
			auto Test5 = TestFunctionE(std::move(LOOP_COUNT));// .5ms
			auto Test4 = TestFunctionD(123.321f, 10);
			auto Test1 = TestFunctionB(1431);
			auto Test3 = TestFunctionA();
			auto Test2 = TestFunctionC(3.14159f, 123);
			auto Test6 = TestFunctionF(std::move(LOOP_COUNT));//.3
			auto Test7 = TestFunctionG(std::move(LOOP_COUNT));//3.21
			auto Test8 = TestFunctionH(std::move(LOOP_COUNT));// .32
			auto Test9 = TestFunctionI(std::move(LOOP_COUNT));//2.8
			auto Test10 = TestFunctionJ(std::move(LOOP_COUNT));//2.6
			auto Test11 = [](int)->int { Print("Lambda Function Linear call"); return 11; };


			while (Function_Counter > 10) {// SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
			}

			uint64_t result{ 0 };
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				result += TestFunctionC( 123.321f, rand()% NUMBER_OF_THREADS);
			}
			Print("Linear :" << result);
			

			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(Test5);
			Test.push_back(Test6);
			Test.push_back(Test7);
			Test.push_back(Test8);
			Test.push_back(Test9);
			Test.push_back(Test10);
			Print("Linear: " << Test4 << " : " << TestCompile(Test));

			LBench.Stop();
		}

		std::cout << " Straight Linear = " << LBench.Results / 1000.0f << " ms" << "\n";//0.020034
		std::cout << "     Thread Pool = " << Bench.Results / 1000.0f << " ms" << "\n";
		std::cout << "      std::async = " << ThreadBM.Results / 1000.0f << " ms" << "\n";//0.020034
		Sleep(1500);
	}
#else

	while (true)
	{
		//LOOP_COUNT += 1000; // 23000 is where Linear = using Thread pool or Async
		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> Bench;
		{
			auto  TPTest5 = ThreadPool::get().Async(TestFunctionE, LOOP_COUNT);
			auto  TPTest1 = ThreadPool::get().Async(TestFunctionB, 1431);
			auto  TPTest4 = ThreadPool::get().Async(TestFunctionD, 123.321f, 10);
			auto  TPTest3 = ThreadPool::get().Async(TestFunctionA);
			auto  TPTest2 = ThreadPool::get().Async(TestFunctionC, 3.14159f, 123);
			auto  TPTest6 = ThreadPool::get().Async(TestFunctionF, LOOP_COUNT);
			auto  TPTest7 = ThreadPool::get().Async(TestFunctionG, LOOP_COUNT);
			auto  TPTest8 = ThreadPool::get().Async(TestFunctionH, LOOP_COUNT);
			auto  TPTest9 = ThreadPool::get().Async(TestFunctionI, LOOP_COUNT);
			auto TPTest10 = ThreadPool::get().Async(TestFunctionJ, LOOP_COUNT);

			std::vector<std::future<float>> Fut;
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				auto  TPTest4loop = ThreadPool::get().Async(TestFunctionC, 123.321f, std::move(i));// (alloca(sizeof(Wrapper<decltype(TestFunctionC), float, int >))) 
				Fut.push_back(std::forward<std::future<float>>(TPTest4loop));
			}

			uint64_t result{ 0 };
			int counter = Fut.size();
			int C2{ 0 }, C3{ 0 };
			while (counter)
			{
				for (auto& F : Fut)
				{
					if (!is_ready(F))
					{//* if not ready yet, check the next 
						++C2;
						continue;
					}
					result += F.get(); //* it is ready 
					++C3;
					--counter;
				}
			}
			while (Function_Counter < 10) {//* SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
 }
		
			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(TPTest5.get());
			Test.push_back(TPTest6.get());
			Test.push_back(TPTest7.get());
			Test.push_back(TPTest8.get());
			Test.push_back(TPTest9.get());
			Test.push_back(TPTest10.get());

			Print("ThreadPool: " << TPTest4.get() << " : " << TestCompile(Test));
			Bench.Stop();
		}


		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> ThreadBM;
		{
			auto  TPTest5T = std::async(TestFunctionE, LOOP_COUNT);
			auto  TPTest1T = std::async(TestFunctionB, 1431);
			auto  TPTest4T = std::async(TestFunctionD, 123.321f, 10);
			auto  TPTest3T = std::async(TestFunctionA);
			auto  TPTest2T = std::async(TestFunctionC, 3.14159f, 123);
			auto  TPTest6T = std::async(TestFunctionF, LOOP_COUNT);
			auto  TPTest7T = std::async(TestFunctionG, LOOP_COUNT);
			auto  TPTest8T = std::async(TestFunctionH, LOOP_COUNT);
			auto  TPTest9T = std::async(TestFunctionI, LOOP_COUNT);
			auto TPTest10T = std::async(TestFunctionJ, LOOP_COUNT);


			Print("Async Cluster");
			std::vector<std::future<float>> Fut;
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				auto  TPTest4loop = std::async(std::launch::async, TestFunctionC, 123.321f, i);
				Fut.push_back(std::move(TPTest4loop));
			}
			uint64_t result{ 0 };
			int counter = Fut.size();
			while (counter)
			{
				for (auto& F : Fut)
				{
					if (!is_ready(F))
					{// if not ready yet, check the next 
						continue;
					}
					result += F.get(); // it is ready 
					--counter;
				}
			}
			Print("Async :" << result);
			Print("End Async Cluster");


			while (Function_Counter < 10) {// SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
			}

			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(TPTest5T.get());
			Test.push_back(TPTest6T.get());
			Test.push_back(TPTest7T.get());
			Test.push_back(TPTest8T.get());
			Test.push_back(TPTest9T.get());
			Test.push_back(TPTest10T.get());
			Print("Async: " << TPTest4T.get() << " : " << TestCompile(Test));


			ThreadBM.Stop();
		}

		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> LBench;
		{
			auto Test5 = TestFunctionE(LOOP_COUNT);
			auto Test1 = TestFunctionB(1431);
			auto Test4 = TestFunctionD(123.321f, 10);
			auto Test3 = TestFunctionA();
			auto Test2 = TestFunctionC(3.14159f, 123);
			auto Test6 = TestFunctionF(LOOP_COUNT);
			auto Test7 = TestFunctionG(LOOP_COUNT);
			auto Test8 = TestFunctionH(LOOP_COUNT);
			auto Test9 = TestFunctionI(LOOP_COUNT);
			auto Test10 = TestFunctionJ(LOOP_COUNT);

			std::vector<float> Fut;
			for (int i{ 0 }; i < NUMBER_OF_THREADS; ++i)
			{
				auto  TPTest4loop = TestFunctionC(123.321f, i);
				Fut.push_back(std::move(TPTest4loop));
			}
			uint64_t result{ 0 };
			int counter = Fut.size();
			while (counter)
			{
				for (auto& F : Fut)
				{
					result += F; // it is ready 
					--counter;
				}
			}
			Print("Linear Result: " << result);
			while (Function_Counter < 10) {//* SpinLock until every single function called returns as measured via the atomic int Function_Counter. 
			}


			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(Test5);
			Test.push_back(Test6);
			Test.push_back(Test7);
			Test.push_back(Test8);
			Test.push_back(Test9);
			Test.push_back(Test10);
			Print("Linear: " << Test4 << " : " << TestCompile(Test));
			LBench.Stop();
		}
		//std::vector<Wrapper_Base*> FunctionList;

		Function_Counter = 0;

		Profiling::Timing::Profile_Timer<100> WrapperBenchmark;
		{

			//  FunctionList.emplace_back(new Wrapper(TestFunctionE, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionB, 1431));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionD, 123.321f, 10));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionA));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionC, 3.14159f, 123));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionF, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionG, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionH, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionI, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper(TestFunctionJ, LOOP_COUNT));
			//  FunctionList.emplace_back(new Wrapper([](int)->int { Print("Lambda Function Function List calls"); return 11; }, 10000));

			//for (auto& F : FunctionList)
			//{
			//	F->Invoke();
			//}
			WrapperBenchmark.Stop();
		}
 
	//	std::cout << "  Wrapper Linear = " << WrapperBenchmark.Results / 1000.f << " ms" << "\n"; // 0.020808  Difference of .000774
	//	std::cout << " Straight Linear = " << LBench.Results / 1000.f << " ms" << "\n";//0.020034
		std::cout << "     Thread Pool = " << Bench.Results / 1000.f << " ms" << "\n";
	//	std::cout << "      std::async = " << ThreadBM.Results / 1000.f << " ms" << "\n";//0.020034
		Sleep(1500);
	}
#endif

	//	Profiling::Memory::TrackDumpBlocks();
	//	Profiling::Memory::TrackListMemoryUsage();
	return 0;
}
OPTIMIZATION_ON()



#THREADPOOL.CPP


#include"Threadpool.h"

#pragma warning( push )
#pragma warning( disable : 4244 )
#pragma warning( disable : 4018 ) // Optimization off warning of mine

///template<typename _F,typename ...ARGS>
///void* Wrapper<_F,ARGS...>::MemoryBlock;
///

std::atomic<uint32_t> Create{ 0 };
std::atomic<uint32_t> Delete{ 0 };
std::atomic<uint32_t> GotFuture{ 0 };
//template<typename _F, typename ...ARGS>
//uint16_t Wrapper<_F, ARGS...>::Offset{ 0 };

/*

https://www.youtube.com/watch?v=zULU6Hhp42w&list=PLl8Qc2oUMko_FMAaK7WY4ly0ikLFrYCE3&index=4

*/
#define SLEEP_TIME 0
std::atomic<int> Function_Counter{ 0 };

#ifdef MY_WRAPPER

namespace Core
{
	namespace Threading
	{
		bool JobQueue::Try_Pop(Worker_Function*& func)
		{/* Try to aquire a function off the Queue to run */
			std::unique_lock<std::mutex> Lock{ QueueMutex, std::try_to_lock };
			if (!Lock || TaskQueue.empty())
			{
				return false;
			}
			func = TaskQueue.front();//std::forward(TaskQueue.front());// std::move(
		 	TaskQueue.pop_front();
			return true;
		}

		bool JobQueue::pop(Worker_Function*& func)
		{
			std::unique_lock<std::mutex> Lock{ QueueMutex };
			while (TaskQueue.empty() && !is_Done)
			{
				is_Ready.wait(Lock);
			}
			if (TaskQueue.empty())
			{
				return false;
			}
			func = std::move(TaskQueue.front());
			TaskQueue.pop_front();
			return true;
		}

		void JobQueue::Done()
		{
			{
				std::unique_lock<std::mutex> Lock{ QueueMutex };
				is_Done = true;
			}
			is_Ready.notify_all();
		}

		ThreadPool::ThreadPool()
		{
			for (int N{ 0 }; N < ThreadCount; ++N)
			{
				Worker_Threads.emplace_back([&, N] {Run(N); });
			}
		}
		ThreadPool::~ThreadPool()
		{
			for (auto& Q : ThreadQueue)
			{
				Q.Done();
			}
			for (auto& WT : Worker_Threads)
			{
				WT.join();
			}
		}

		void ThreadPool::Run(unsigned int _i)
		{
			while (true)
			{
				Worker_Function* Func{ nullptr }; 
				for (unsigned int N{ 0 }; N != ThreadCount; ++N)
				{
					if (ThreadQueue[static_cast<size_t>((_i + N) % ThreadCount)].Try_Pop(Func))
					{
						break;
					}
				}
				if (!Func && !ThreadQueue[_i].pop(Func)) 
				{
					break; // Possibly need this to be a continue
				}
				//Print("Before: " << Func);
				Func->Invoke();

				/// If this is deleted before the future is gotten an error is thrown stating the Future has been aquired multiple times.
			 	delete &(*Func);
				++Delete;
				//Func = nullptr;
				
				//Print("After: " << Func);

			}
		}
	}// End NS Threading
}// End NS Core

#else
namespace Core
{
	namespace Threading
	{

		bool JobQueue::Try_Pop(Worker_Function& func)
		{/* Try to aquire a function off the Queue to run */
			std::unique_lock<std::mutex> Lock{ QueueMutex, std::try_to_lock };
			if (!Lock || TaskQueue.empty())
			{
				return false;
			}
			/// Something is wrong here. Will lock if the pop is performed here
			func = std::move(TaskQueue.front());
			TaskQueue.pop_front();
			return true;
		}
		bool JobQueue::pop(Worker_Function& func)
		{
			std::unique_lock<std::mutex> Lock{ QueueMutex };
			while (TaskQueue.empty() && !is_Done)
			{
				is_Ready.wait(Lock);
			}
			if (TaskQueue.empty())
			{
				return false;
			}
			func = std::move(TaskQueue.front());//std::forward(TaskQueue.front());// std::move(
			TaskQueue.pop_front();
			return true;
		}

		void JobQueue::Done()
		{
			{
				std::unique_lock<std::mutex> Lock{ QueueMutex };
				is_Done = true;
			}
			is_Ready.notify_all();
		}

		ThreadPool::ThreadPool()
		{
			for (int N{ 0 }; N < ThreadCount; ++N)
			{
				Worker_Threads.emplace_back([&, N] {Run(N); });
			}
		}
		ThreadPool::~ThreadPool()
		{
			for (auto& Q : ThreadQueue)
			{
				Q.Done();
			}
			for (auto& WT : Worker_Threads)
			{
				WT.join();
			}
		}
		// { nullptr };// = new Wrapper_Base();
		void ThreadPool::Run(unsigned int _i)
		{
			while (true)
			{
				Worker_Function Func;
				bool Popped{ false };
				for (unsigned int N{ 0 }; N != ThreadCount; ++N)
				{
					if (ThreadQueue[static_cast<size_t>((_i + N) % ThreadCount)].Try_Pop(Func))
					{
						Popped = true; // This finally fixes the bad function call because if Try_Pop removes item from queue it still gets ran.
						break;
					}
				}
				if (!Popped && !ThreadQueue[_i].pop(Func))//!Func && 
				{
					break; // Possibly need this to be a continue
				}
				Func();
			}
		}
	}// End NS Threading
}// End NS Core
#endif









#include<iostream>
#include<string>

#pragma optimize( "", off )
/* unoptimized code section */
#define Worker_Print(x) //std::cout << x << " : "


OPTIMIZATION_OFF()
void TestFunction(int _count, int _output)
{
	int result{ 0 };
	for (int i{ 0 }; i < _count; ++i)
	{
		result++;
		result += std::pow(result, _output);
	}
	std::cout << "PARAM:" << _output << "Finished Work: " << result << "\n";
}
OPTIMIZATION_ON()


OPTIMIZATION_OFF()
int TestFunctionA()
{
	Worker_Print( "FunctionA");
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return 11;
}
OPTIMIZATION_ON()


OPTIMIZATION_OFF()
int TestFunctionB(int _param)
{
	int result;
	Worker_Print("FunctionB: " << _param) ;
	//result.set_value(10);
	result = _param * 2;
	Sleep(SLEEP_TIME);
++Function_Counter;
	return result;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
float TestFunctionC(float _paramA, int _paramB)
{
	Worker_Print("FunctionC: " << _paramA << " : " << _paramB );
	//Print("FuncC Param is " << _paramB << " : ");

	Sleep(SLEEP_TIME);
	++Function_Counter;
	return _paramA * _paramB * (rand() % 1000);
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::string TestFunctionD(float _paramA, int _paramB)
{
	Worker_Print("FunctionD " << _paramA << " : " << _paramB );
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return "String: " + std::to_string(_paramA) + " : " + std::to_string(_paramB);
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionE(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;

	uint64_t result{ 0 };
	for (int i{ 0 }; i < _paramA; ++i)
	{
		//	std::cout << "E: " << i*i ;
		result += i * i;
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionF(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	uint64_t result{ 0 };
	for (int i{ 0 }; i < _paramA; ++i)
	{
		double A = sqrt(i*i);
		//		std::cout << "F: " << A ;
		result += _paramA * i + A;
		SomethingAllocated.push_back(result);
	}	
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()


OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionG(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	uint64_t result{ 0 };
	int B = rand() % _paramA;
	int C{ 0 };

	for (int i{ 0 }; i < _paramA; ++i)
	{
		double A = sqrt(i*i);
		//		std::cout << "G: " << A ;
		result += (_paramA * i) / pow(A, i);
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionH(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	double A{ 0 };
	uint64_t result{ 0 };
	int B = rand() % _paramA;
	int C{ 0 };

	for (int i{ 0 }; i < _paramA; ++i)
	{
		A = sqrt(i*i);
	    Worker_Print( "H: " << A );
		result += i * A;
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionI(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	uint64_t A{ 0 };

	int B = rand() % _paramA;
	int C{ 0 };

	for (int i{ 0 }; i < _paramA; ++i)
	{
		A = pow(_paramA, i);
		if (!((i+1) % (B+1)))C += A;
		Worker_Print( "I: " << A );	
		uint32_t result = A * C;
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
std::vector<uint32_t> TestFunctionJ(int _paramA)
{
	std::vector<uint32_t> SomethingAllocated;
	float A = 0;
	int B = rand() % _paramA;
	int C{ 0 };
	for (int i{ 0 }; i < _paramA; ++i)
	{
		A = pow(i, _paramA) / i;
		if (A == B)C = i;
		Worker_Print("J: " << A << ":");
		uint32_t result = A * C;
		SomethingAllocated.push_back(result);
	}
	Sleep(SLEEP_TIME);
	++Function_Counter;
	return SomethingAllocated;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
uint64_t Worker_TestFunction(size_t _count)
{
	int B = rand() % _count;
	int C{ 0 };
	for(uint32_t i{0}; i< _count; ++i)
	{
		std::cout << i << ":";
		if (!((i+1) % (B+1)))C++;
	}
	return _count * C;
}
OPTIMIZATION_ON()

OPTIMIZATION_OFF()
uint64_t TestCompile(std::vector<std::vector<uint32_t>> _input)
{
	uint64_t result{ 0 };
	for (auto& Y : _input)
	{
		for (auto& X : Y)
		{
			result += X;
		}
	}
	return result;
}
OPTIMIZATION_ON()
OPTIMIZATION_OFF()

uint64_t TestFunctionLarge(uint64_t _p1, uint64_t _p2, uint64_t _p3, uint64_t _p4, uint64_t _p5)
{
	uint64_t result = _p1 + _p2 +_p3 +_p4 + _p5;
	Print(result);
	return result;
}

OPTIMIZATION_ON()

#pragma warning( pop )

/*NOTES:

Intel Game Engine Design:
https://software.intel.com/en-us/articles/designing-the-framework-of-a-parallel-game-engine

Faster STD::FUNCTION Implementation
https://github.com/skarupke/std_function/blob/master/function.h


Lock Free Ring Buffer
https://github.com/tempesta-tech/blog/blob/master/lockfree_rb_q.cc

Lock-Free Programming
https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf

A Fast Lock-Free Queue for C++
http://moodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++

Introduction to Multithreaded Algorithms
http://ccom.uprrp.edu/~ikoutis/classes/algorithms_12/Lectures/MultithreadedAlgorithmsApril23-2012.pdf

A Thread Pool with C++11
http://progsch.net/wordpress/?p=81

Parallelizing the Naughty Dog Engine
https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine

C++11 threads, affinity and hyperthreading
https://eli.thegreenplace.net/2016/c11-threads-affinity-and-hyperthreading/

Thread pool worker implementation
https://codereview.stackexchange.com/questions/60363/thread-pool-worker-implementation

Thread pool implementation using c++11 threads
https://github.com/mtrebi/thread-pool

C++11 Multithreading  Part 8: std::future , std::promise and Returning values from Thread
https://thispointer.com/c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/


CppCon 2015: Fedor Pikus PART 2 Live Lock-Free or Deadlock (Practical Lock-free Programming) 
Queue
https://www.youtube.com/watch?v=1obZeHnAwz4&t=3055s


Thread Pool Implementation on Github:
https://github.com/mtrebi/thread-pool/blob/master/README.md#queue

Threadpool with documentation:
https://www.reddit.com/r/cpp/comments/9lvji0/c_threadpool_with_documentation/

Original White paper on Work stealing Queues:
http://supertech.csail.mit.edu/papers/steal.pdf

Code overview - Thread Pool & Job System
https://www.youtube.com/watch?v=Df-6ws_EZno

while(running)
{
    Try to Lock and return True or False
	True:
	False: Push it to 
}
*/


##HEADER


#pragma once
#include <thread>
#include <functional>
#include <future>
#include <deque>
#include <queue>
#include <array>
#include <tuple>

#include<Windows.h>
#include"Core\Common.h"
#include<iostream>

#pragma warning( push )
#pragma warning( disable : 4244 )
#pragma warning( disable : 4018 ) // Optimization off warning of mine

#define BLOCK_SIZE    1024 * 100
#define MY_WRAPPER

static void* Wrap_MemoryBlock = malloc(BLOCK_SIZE * sizeof(char)); // nullptr;
static uint16_t  Wrap_Offset{ 0 };


extern std::atomic<uint32_t> Create;
extern std::atomic<uint32_t> Delete;
extern std::atomic<uint32_t> GotFuture;


/* Non-blocking test of std::future to see if value is avalible yet */
template<typename R>
bool is_ready(std::future<R> const& f)
{
	return f.valid() ? f.wait_for(std::chrono::seconds(0)) == std::future_status::ready : false;
}

/// template<typename Function, typename ...Args>
/// result_type = std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>;

extern std::atomic<int> Function_Counter;
//https://code.woboq.org/llvm/libcxx/include/type_traits.html

/// Use this switch with Compiler Explorer inorder to allow it to compile: -std=c++17 -O3
// MSVC Threadpool implementation for Concurrency
// https://docs.microsoft.com/en-us/cpp/parallel/concrt/task-scheduler-concurrency-runtime?view=vs-2019
#ifdef MY_WRAPPER

struct Wrapper_Base
{/// __declspec(novtable) USE THIS
	virtual ~Wrapper_Base() {
	}//Print("Base");

	virtual void Invoke() = 0;
	void operator()() 
	{
		Invoke();
	}
	/* Implement a Then, When_all and Deferred Function handling */


	enum asyncStatus
	{
		Valid, Waiting, Busy, Submitted, Ready, Aquired
	};

	asyncStatus Status;
};

template<typename _Func, typename ...ARGS>
struct asyncTask
	: public Wrapper_Base
{
	using type = std::invoke_result_t<std::decay_t<_Func&>, std::decay_t<ARGS>...>;
	using reference_type = type&;
	using Fptr = type(*)(ARGS...);

	Fptr Function;
	std::tuple<ARGS...> Arguments;
	std::promise<type> ReturnValue;

	int RefCount{ 0 };
	asyncTask(_Func&& _function, ARGS&&... _args) noexcept
		:
		Function(std::move(_function)),
		Arguments(std::forward<ARGS>(_args)...)
	{
		Status = Valid;
	}
	virtual ~asyncTask() {  }//Print("Derived Destruct");

	asyncTask(asyncTask&& _other) noexcept
		:
		Function(std::move(_other.Function)),
		Arguments(std::forward<ARGS>(_other.Arguments)),
		ReturnValue(std::move(_other.ReturnValue))
	{
		std::cout << "Called the Forward Function" << "\n";
	}
	asyncTask& operator=(asyncTask&& _other) noexcept
	{
		Function = std::move(_other.Function);
		Arguments = std::forward<ARGS>(_other.Arguments);
		ReturnValue = std::move(_other.ReturnValue);
		std::cout << "Called Assignment Operator " << "\n";
	}

	virtual void Invoke()  override
	{
		 Status = Busy;
		 auto result = std::apply(Function, Arguments);
  		 ReturnValue.set_value(result);
		 Status = Waiting;
	}

	std::future<type> get_future()
	{
		Status = Submitted;
		++Create;
		GotFuture++;
		RefCount++;
		return ReturnValue.get_future();
	}

	type get()
	{
		Status = Aquired;
		ReturnValue.get();
	}

	bool is_ready()
	{
		return ReturnValue.valid() ? (ReturnValue.wait_for(std::chrono::seconds(0)) == std::future_status::ready) : false;
	}
	asyncTask(const asyncTask&) = delete;
	asyncTask& operator=(const asyncTask& _other) = delete;
};


  typedef Wrapper_Base Worker_Function;


// NOTE: https://riptutorial.com/cplusplus/example/15806/create-a-simple-thread-pool
namespace Core
{
	namespace Threading
	{

		struct JobQueue
		{
		public:
			JobQueue() = default;

			std::condition_variable is_Ready;
			std::mutex QueueMutex;
			bool is_Done{ false };
			void Done();

			std::deque<Worker_Function*> TaskQueue;

			bool Try_Pop(Worker_Function*& func);
			bool pop(Worker_Function*& func);

			bool try_push(Worker_Function *func)
			{
				{
					std::unique_lock<std::mutex> Lock{ QueueMutex, std::try_to_lock };
					if (!Lock)
					{/* If our mutex is already locked simply return */
						return false;
					}
					/* Else place on the back of our Queue*/
					TaskQueue.push_back(std::move(func));//(func));std::move<_FUNC>
				}/* Unlock the Mutex */
				is_Ready.notify_one(); /* Tell the world about it */
				return true;/* Lets Async know u*/
			}
			void push(Worker_Function* func)
			{/* Adds a Function to our Queue */
				{
					std::unique_lock<std::mutex> Lock{ QueueMutex };
					TaskQueue.emplace_back(std::move(func));//std::move<_FUNC> std::forward<_FUNC&>(&((Worker_Function *)
				}
			}
		};

		class ThreadPool
		{
			const unsigned int ThreadCount{  std::thread::hardware_concurrency() * 3};
			std::vector<std::thread> Worker_Threads;
			std::vector<JobQueue> ThreadQueue{ ThreadCount };
			std::atomic<unsigned int> Index{ 0 };

			ThreadPool();
			~ThreadPool();

			void Run(unsigned int _i);

		public:

			static ThreadPool &get()
			{
				static ThreadPool instance;
				return instance;
			}

			template<typename _FUNC, typename...ARGS >
			auto Async(_FUNC&& _func, ARGS&&... args)->std::future<typename asyncTask<_FUNC, ARGS... >::type> //Wrapper_Base::future<typename  Wrapper<_FUNC, ARGS... >::type>
			{// Accept arbitrary Function signature and arguments
				auto _function = new asyncTask<_FUNC, ARGS... >(std::move(_func), std::forward<ARGS>( args)...);
				auto result = _function->get_future();
				
				auto i = Index++;
				int K = 1;
				for (unsigned int n{ 0 }; n != ThreadCount * K; ++n) // K is Tunable 
				{
					if (ThreadQueue[static_cast<size_t>((i + n) % ThreadCount)].try_push(static_cast<Worker_Function*>(_function)))
					{
						
						return result;
					}
				}

				ThreadQueue[i % ThreadCount].push(static_cast<Worker_Function*>(_function));
				return result;
			}
			///===================================================================================================================================================================

		};
	}// End NS Threading
}// End NS Core 

			///===================================================================================================================================================================
			///     template<typename _FUNC, typename...ARGS >
			///     auto Async(asyncTask<_FUNC, ARGS... >  *_function)->std::future<typename asyncTask<_FUNC, ARGS... >::type> //Wrapper_Base::future<typename  Wrapper<_FUNC, ARGS... >::type>
			///     {// Accept arbitrary Function signature and arguments
			///     	auto i = Index++;
			///     	int K = 1;
			///     	for (unsigned int n{ 0 }; n != ThreadCount * K; ++n) // K is Tunable 
			///     	{
			///     		if (ThreadQueue[static_cast<size_t>((i + n) % ThreadCount)].try_push(static_cast<Worker_Function*>(_function)))
			///     		{
			///     			return _function->get_future();
			///     		}
			///     	}
			///     
			///     	ThreadQueue[i % ThreadCount].push(static_cast<Worker_Function*>(_function));
			///     
			///     	return _function->get_future();
			///     }
			///================================= EXPERIMENTAL ====================================================================================================================



#else


/// template<typename Function, typename ...Args>
/// result_type = std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>;
			// class _RET = std::result_of_t<_FUNC>,class _RET =std::result_of_t<_FUNC()>, 

 //_FUNC&& _func, ARGS&&...args)->std::future<decltype(_func(args...))>//  //

extern std::atomic<int> Function_Counter;
//https://code.woboq.org/llvm/libcxx/include/type_traits.html


typedef std::function<void()> Worker_Function;



// NOTE: https://riptutorial.com/cplusplus/example/15806/create-a-simple-thread-pool
namespace Core
{
	namespace Threading
	{

		struct JobQueue
		{
		public:
			JobQueue() = default;

			std::condition_variable is_Ready;
			std::mutex QueueMutex;
			bool is_Done{ false };
			void Done();


			std::deque<Worker_Function> TaskQueue;

			bool Try_Pop(Worker_Function& func);
			bool pop(Worker_Function& func);
			template<typename _FUNC> bool try_push(_FUNC&& func)
			{
				{
					std::unique_lock<std::mutex> Lock{ QueueMutex, std::try_to_lock };
					if (!Lock)
					{/* If our mutex is already locked simply return */
						return false;
					}
					/* Else place on the back of our Queue*/
					TaskQueue.emplace_back(std::forward<_FUNC>(func));
				}
				is_Ready.notify_one();
				return true;
			}
			template<typename _FUNC> void push(_FUNC&& func)
			{/* Adds a Function to our Queue */
				{
					std::unique_lock<std::mutex> Lock{ QueueMutex };
					TaskQueue.emplace_back(std::forward<_FUNC>(func));//std::move<_FUNC> std::forward<_FUNC&>(&((Worker_Function *)
				}
			}
	};
		class ThreadPool
		{
			const unsigned int ThreadCount{ std::thread::hardware_concurrency() - 1 };
			std::vector<std::thread> Worker_Threads;
			std::vector<JobQueue> ThreadQueue{ ThreadCount };
			std::atomic<unsigned int> Index{ 0 };

			ThreadPool();
			~ThreadPool();

			void Run(unsigned int _i);
		public:

			static ThreadPool& get()
			{
				static ThreadPool instance;
				return instance;
			}
			// class _RET = std::result_of_t<_FUNC>,class _RET =std::result_of_t<_FUNC()>, 

 //_FUNC&& _func, ARGS&&...args)->std::future<decltype(_func(args...))>//  //

			template<typename _FUNC, typename...ARGS >
			auto Async(_FUNC&& _func, ARGS&&...args)->std::future<decltype(_func(args...))>//  //
			{// Accept arbitrary Function signature and arguments
				auto i = Index++;

				auto task_PTR =
					std::make_shared<std::packaged_task<decltype(_func(args...))()>>
					(// Bind the argument and make a new packaged task to retrieve a future from on completion. 
						std::bind
						(
							std::forward<_FUNC>(_func),
							std::forward<ARGS>(args)...
						)
						);
				//	if(_q[(i + n) % _count]
				std::function<void()> wrapper_func = [task_PTR]()
				{// Utilize std::functions type erasure to wrap the Task pointer
					(*task_PTR)();
				};


				int K = 8;
				for (unsigned int n{ 0 }; n != ThreadCount * K; ++n) // K is Tunable 
				{
					if (ThreadQueue[static_cast<size_t>((i + n) % ThreadCount)].try_push(wrapper_func))
					{
						return task_PTR->get_future();
					}
				}

				ThreadQueue[i % ThreadCount].push(wrapper_func);
				return  task_PTR->get_future();
			}
		};
}// End NS Threading
}// End NS Core 

#endif






int TestFunctionA();
int TestFunctionB(int _param);
uint64_t TestFunctionLarge(uint64_t _p1, uint64_t _p2, uint64_t _p3, uint64_t _p4, uint64_t _p5);
 
float TestFunctionC(float _paramA, int _paramB);

std::string TestFunctionD(float _paramA, int _paramB);
std::vector<uint32_t> TestFunctionE(int _paramA);
std::vector<uint32_t> TestFunctionF(int _paramA);
std::vector<uint32_t> TestFunctionG(int _paramA);
std::vector<uint32_t> TestFunctionH(int _paramA);
std::vector<uint32_t> TestFunctionI(int _paramA);
std::vector<uint32_t> TestFunctionJ(int _paramA);

uint64_t TestCompile(std::vector<std::vector<uint32_t>> _input);
uint64_t Worker_TestFunction(size_t _count);




template<typename _Ty, size_t _SZ>
class ring_buffer
{
public:
	using value_type = _Ty;
	using reference = _Ty & ;
	using pointer = const _Ty*;

	ring_buffer() = default;

	bool push_back(reference _element)
	{/// Just deferring this function to make it compatible with older Queue system for Threadpool
		return push(_element);
	}
	bool push(reference _element)
	{// Adds new Element to Queue
		std::atomic<size_t> OldWritePosition;/// = WritePosition.load();
		std::atomic<size_t> NewWritePosition = NextElement(OldWritePosition);
		if (NewWritePosition)/// == ReadPosition.load())
		{/* If Read position and Write position are the same Buffer is Full */
			return false;
		}
///		Data[OldWritePosition] = _element;
		WritePosition = NewWritePosition;
	}

	/// WE MIGHT BE ABLE TO PACK THE READER AND WRITER INTO THE SAME ATOMIC INTEGER WHICH WILL REDUCE THE OVERHEAD
	bool pop(reference _returnElement)
	{/* Returns True if more elements in Queue*/
		while (true)
		{/* READER Multiple in Existance */
			std::atomic<size_t> OldReadPosition = ReadPosition.load();

			if (WritePosition.load() == OldReadPosition.load())
			{// If attempting to read the same position again or buffer is full return false;
				return false;
			}

			_returnElement = Data[OldReadPosition];// Perhaps std::move() would be better for performance
			if (ReadPosition.compare_exchange_strong(OldReadPosition, NextElement(OldReadPosition)))
			{
				return true;
			}
		}
	}

	auto front()
	{/// Possibly wrong currently a place holder to make the experimental ringbuffer compatible with older style of queue
		return &Data[ReadPosition];
	}
	void pop_front() 
	{/// Possibly wrong currently a place holder to make the experimental ringbuffer compatible with older style of queue
		WritePosition = NextElement(WritePosition);
	}
	bool empty()
	{/// Possibly wrong currently a place holder to make the experimental ringbuffer compatible with older style of queue
		return (ReadPosition == WritePosition);
	}

	reference operator[](const int _offset)
	{
		return Data[_offset]; //[ReadPosition % BufferSize];
	}

	bool destroy()
	{
		delete[](Data);
	}

	size_t size()
	{
		return BufferSize;
	}

private:

	std::array<std::atomic<_Ty*>, _SZ + 1> Data;

	size_t NextElement(size_t _pos)
	{
		return ++_pos == BufferSize ? 0 : _pos;
	}

	size_t
		ReadPosition{ 0 },
		WritePosition{ 0 };
	size_t Length, Size, Start, End, Elements;
	size_t BufferSize = _SZ + 1;
};

#pragma warning( pop )

//
//pointer begin()
//{
//	return &Data[ReadPosition.location()];
//}
//pointer end()
//{
//	return &Data[WritePosition.location()];
//}
//
//	using iterator = rbIterator<_Ty>;
//iterator MyFirst() { return Data; }
//iterator MyLast() { return Data; }
//iterator MyEnd() { return MyLast(); }
// _NODISCARD iterator begin() noexcept
	// {	// return iterator for beginning of mutable sequence
	// 	return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
	// }



/*
		void make_Ready()//std::unique_lock<std::mutex>* _Lock)///, bool _At_thread_exit) Create a Defered signal so value is set when thread ends
		{
			//	_Has_stored_result = true;
		///if (_At_thread_exit) { // notify at thread exit
		///	_Cond._Register(*_Lock, &_Ready);
		///}
		///else { // notify immediately
			isReady = true;
			MutxCV.notify_all();
		///}
		}
		*/




		//type get()
		//{ // block until ready then return the stored result or
		//		// throw the stored exception
		//	//future _Local{ std::move(*this) };
		//	return type();// 0;//_STD move(_Local._Get_value());
		//}
		//std::future<std::invoke_result_t<_Func&, ARGS...>>& get_future()
		//{
		//	std::promise<std::invoke_result_t<_Func&, ARGS...>> result
		//}

		/*


			_State_manager& operator=(const _State_manager& _Other) { // assign from _Other
			_Copy_from(_Other);
			return *this;
		}

		_State_manager& operator=(_State_manager&& _Other) { // assign from rvalue _Other
			_Move_from(_Other);
			return *this;
		}

		_NODISCARD bool valid() const noexcept { // return status
			return _Assoc_state && !(_Get_only_once && _Assoc_state->_Already_retrieved());
		}

		void wait() const { // wait for signal
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Wait();
		}
			template <class _Clock, class _Dur>
		future_status wait_until(const chrono::time_point<_Clock, _Dur>& _Abs_time) const { // wait until time point
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			return _Assoc_state->_Wait_until(_Abs_time);
		}

		_Ty& _Get_value() const { // return the stored result or throw stored exception
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			return _Assoc_state->_Get_value(_Get_only_once);
		}

		void _Set_value(const _Ty& _Val, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_value(_Val, _Defer);
		}

		void _Set_value(_Ty&& _Val, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_value(_STD forward<_Ty>(_Val), _Defer);
		}
		   void _Abandon() { // abandon shared state
			if (_Assoc_state) {
				_Assoc_state->_Abandon();
			}
		}

		void _Set_exception(exception_ptr _Exc, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_exception(_Exc, _Defer);
		}

		void _Swap(_State_manager& _Other) { // exchange with _Other
			_STD swap(_Assoc_state, _Other._Assoc_state);
		}
		*/

		//		        unique_lock<mutex> _Lock(_Mtx);
		//    _Maybe_run_deferred_function(_Lock);
		//    while (!_Ready) {
		//        _Cond.wait(_Lock);
		//    }
		/* Likely will need this later down the line */
	//template <>
	//class future<void>
	//{
	//	using type = std::void_t<>;//_Ty;
	//	//using reference_type = type&;
	//	//using pointer_type = _Ty*;
	//
	//	future() noexcept = default;
	//
	//	/* construct from rvalue future object noexcept*/
	//	future(future && _Other) : std::move(_Other) { }
	//
	//	/* assign from rvalue future object noexcept(put this back when everything is good to go)*/
	//	future& operator=(future && _Right) { memmove(this, _Right, sizeof(future));	return *this; }
	//	~future() noexcept = default;
	//
	//	/**/
	//	reference_type& get()
	//	{
	//		while (!isReady) {}
	//		return std::move(*Value);
	//	}
	//	/**/
	//	inline void set(reference_type _value)
	//	{/// maybe pass by value....
	//	//	Value = _value;
	//	//	isReady = true;
	//	}
	//
	//	void wait()
	//	{
	//		/*
	//		        unique_lock<mutex> _Lock(_Mtx);
	//    _Maybe_run_deferred_function(_Lock);
	//    while (!_Ready) {
	//        _Cond.wait(_Lock);
	//    }
	//		*/
	//		while (!isReady) {}
	//	}
	//	pointer_type Value = nullptr;
	//
	//	future(const future&) = delete;
	//	future& operator=(const future&) = delete;
	//};
		//virtual future<void>& get_future() = 0;

		//virtual void get_future() = 0;







	/*
	template<class _Ty>
	struct future
	{
		using type = _Ty;
		using pointer_type = _Ty*;

		/// using reference_type = type&; Removed because of possible void call to this function. That would result in invalid type so either overload
		/// This future Template with a <void> version or perhaps branch in our wrapper to never deal with the future if there is no return value anyway

		future() noexcept = default;
		~future() noexcept = default;

		/* construct from rvalue future object noexcept*/
		//future(future&& _Other)  {this = std::forward(_Other); } //std::move(_Other)

		/* assign from rvalue future object noexcept(put this back when everything is good to go)*/
		///future& operator=(future&& _Right) 
		///{ ERROR
		///	//memmove(*this, _Right, sizeof(future));	return *this; 
		///	*this = std::forward(_Right);
		///	return *this;
		///}

		/*reference_type
		type get()
		{
			//std::unique_lock<std::mutex> value_Lock(Mutx);
			while (!isReady) {}
			return std::move(*Value);
		}
		/*
		inline void set(type* _value)
		{/// maybe pass by value....reference_type
			Value = _value;
			make_Ready();
		}

		/* Wait until the stored function returns and we are able to aquire its return value
		void wait()
		{
		//	std::unique_lock<std::mutex> value_Lock(Mutx);
			while (!isReady)
			{
				//Mutx_CV.wait(value_Lock);
			}
			make_Ready();
		}
		/* Signal to our threads that our Value is ready to be retrieved
		void make_Ready()
		{
			TODO("Make This class non movable or assignable again currently commented out");
			isReady = true;
		///	Mutx_CV.notify_all();
		}

		bool isReady{ false };/// Just make this the CV but my hands are cold so lets get this shit done
		pointer_type Value = nullptr;
		///std::mutex Mutx;
		///std::condition_variable Mutx_CV;
		bool Retrieved{false};


		///RETURN THESE AND MAKE THIS NON COPYABLE AGAIN!!!
		///==================
		//future(const future&) = delete;
		//future& operator=(const future&) = delete;
	};






//future<type> ReturnValue;
//future<type>& get_future()
//{
//	return ReturnValue;// std::move(ReturnValue);
//}
//	future<type> ReturnValue;
//virtual void operator()() override
//{
//	Invoke();
//}//	std::atomic<bool> isReady{ false };


*/
//    Wrapper() = default;
//  static void* operator new(size_t _size)
//  {
//  	//std::cout << "Overloading new operator with size: " << _size << "\n";
//  	//void* p = ::new Wrapper();// sizeof(
//  	void* p = Allocate(_size);//alloca(size);//&Wrapper<_Func, ARGS...>)();
////	Print("Place: " << p << "Memblock: " << Wrap_MemoryBlock << "Offset: " << Wrap_Offset);
//  	return p;
//  }
//  
//  static void operator delete(void* p)
//  {
//  //	std::cout << "Overloading delete operator " << "\n";
//  //	free(p);
//  }
    



====================================================================================================================================================================================
                                                               #11/28															  															  
															  #Threadpool.h															  															  
====================================================================================================================================================================================

private:
JUST GARBAGE i WAS PLAYING WITH
	static void Init()
	{
		if (!Wrap_MemoryBlock)
		{
			Wrap_MemoryBlock = malloc(BLOCK_SIZE * sizeof(char));
		}
	}
	static void *Allocate(uint16_t _sz) 
	{
		if (Wrap_Offset + _sz > BLOCK_SIZE)
		{
			Wrap_Offset = _sz;
			Print("==================Wrapped around=========================================");
		}
		else
		{
			Wrap_Offset += _sz;
		}
		return (void*)((char*)Wrap_MemoryBlock + (Wrap_Offset - _sz));
	}
	//		TODO("Overload new and delete to use a pool to Allocate on the stack if possible but unlikely. Create pool allocator with occassional defrag Event on the TP ");

//pointer begin()
//{
//	return &Data[ReadPosition.location()];
//}
//pointer end()
//{
//	return &Data[WritePosition.location()];
//}
//
//	using iterator = rbIterator<_Ty>;
//iterator MyFirst() { return Data; }
//iterator MyLast() { return Data; }
//iterator MyEnd() { return MyLast(); }
// _NODISCARD iterator begin() noexcept
	// {	// return iterator for beginning of mutable sequence
	// 	return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
	// }



/*
		void make_Ready()//std::unique_lock<std::mutex>* _Lock)///, bool _At_thread_exit) Create a Defered signal so value is set when thread ends
		{
			//	_Has_stored_result = true;
		///if (_At_thread_exit) { // notify at thread exit
		///	_Cond._Register(*_Lock, &_Ready);
		///}
		///else { // notify immediately
			isReady = true;
			MutxCV.notify_all();
		///}
		}
		*/




		//type get()
		//{ // block until ready then return the stored result or
		//		// throw the stored exception
		//	//future _Local{ std::move(*this) };
		//	return type();// 0;//_STD move(_Local._Get_value());
		//}
		//std::future<std::invoke_result_t<_Func&, ARGS...>>& get_future()
		//{
		//	std::promise<std::invoke_result_t<_Func&, ARGS...>> result
		//}

		/*


			_State_manager& operator=(const _State_manager& _Other) { // assign from _Other
			_Copy_from(_Other);
			return *this;
		}

		_State_manager& operator=(_State_manager&& _Other) { // assign from rvalue _Other
			_Move_from(_Other);
			return *this;
		}

		_NODISCARD bool valid() const noexcept { // return status
			return _Assoc_state && !(_Get_only_once && _Assoc_state->_Already_retrieved());
		}

		void wait() const { // wait for signal
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Wait();
		}
			template <class _Clock, class _Dur>
		future_status wait_until(const chrono::time_point<_Clock, _Dur>& _Abs_time) const { // wait until time point
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			return _Assoc_state->_Wait_until(_Abs_time);
		}

		_Ty& _Get_value() const { // return the stored result or throw stored exception
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			return _Assoc_state->_Get_value(_Get_only_once);
		}

		void _Set_value(const _Ty& _Val, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_value(_Val, _Defer);
		}

		void _Set_value(_Ty&& _Val, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_value(_STD forward<_Ty>(_Val), _Defer);
		}
		   void _Abandon() { // abandon shared state
			if (_Assoc_state) {
				_Assoc_state->_Abandon();
			}
		}

		void _Set_exception(exception_ptr _Exc, bool _Defer) { // store a result
			if (!valid()) {
				_Throw_future_error(make_error_code(future_errc::no_state));
			}

			_Assoc_state->_Set_exception(_Exc, _Defer);
		}

		void _Swap(_State_manager& _Other) { // exchange with _Other
			_STD swap(_Assoc_state, _Other._Assoc_state);
		}
		*/

		//		        unique_lock<mutex> _Lock(_Mtx);
		//    _Maybe_run_deferred_function(_Lock);
		//    while (!_Ready) {
		//        _Cond.wait(_Lock);
		//    }
		/* Likely will need this later down the line */
	//template <>
	//class future<void>
	//{
	//	using type = std::void_t<>;//_Ty;
	//	//using reference_type = type&;
	//	//using pointer_type = _Ty*;
	//
	//	future() noexcept = default;
	//
	//	/* construct from rvalue future object noexcept*/
	//	future(future && _Other) : std::move(_Other) { }
	//
	//	/* assign from rvalue future object noexcept(put this back when everything is good to go)*/
	//	future& operator=(future && _Right) { memmove(this, _Right, sizeof(future));	return *this; }
	//	~future() noexcept = default;
	//
	//	/**/
	//	reference_type& get()
	//	{
	//		while (!isReady) {}
	//		return std::move(*Value);
	//	}
	//	/**/
	//	inline void set(reference_type _value)
	//	{/// maybe pass by value....
	//	//	Value = _value;
	//	//	isReady = true;
	//	}
	//
	//	void wait()
	//	{
	//		/*
	//		        unique_lock<mutex> _Lock(_Mtx);
	//    _Maybe_run_deferred_function(_Lock);
	//    while (!_Ready) {
	//        _Cond.wait(_Lock);
	//    }
	//		*/
	//		while (!isReady) {}
	//	}
	//	pointer_type Value = nullptr;
	//
	//	future(const future&) = delete;
	//	future& operator=(const future&) = delete;
	//};
		//virtual future<void>& get_future() = 0;

		//virtual void get_future() = 0;







	/*
	template<class _Ty>
	struct future
	{
		using type = _Ty;
		using pointer_type = _Ty*;

		/// using reference_type = type&; Removed because of possible void call to this function. That would result in invalid type so either overload
		/// This future Template with a <void> version or perhaps branch in our wrapper to never deal with the future if there is no return value anyway

		future() noexcept = default;
		~future() noexcept = default;

		/* construct from rvalue future object noexcept*/
		//future(future&& _Other)  {this = std::forward(_Other); } //std::move(_Other)

		/* assign from rvalue future object noexcept(put this back when everything is good to go)*/
		///future& operator=(future&& _Right) 
		///{ ERROR
		///	//memmove(*this, _Right, sizeof(future));	return *this; 
		///	*this = std::forward(_Right);
		///	return *this;
		///}

		/*reference_type
		type get()
		{
			//std::unique_lock<std::mutex> value_Lock(Mutx);
			while (!isReady) {}
			return std::move(*Value);
		}
		/*
		inline void set(type* _value)
		{/// maybe pass by value....reference_type
			Value = _value;
			make_Ready();
		}

		/* Wait until the stored function returns and we are able to aquire its return value
		void wait()
		{
		//	std::unique_lock<std::mutex> value_Lock(Mutx);
			while (!isReady)
			{
				//Mutx_CV.wait(value_Lock);
			}
			make_Ready();
		}
		/* Signal to our threads that our Value is ready to be retrieved
		void make_Ready()
		{
			TODO("Make This class non movable or assignable again currently commented out");
			isReady = true;
		///	Mutx_CV.notify_all();
		}

		bool isReady{ false };/// Just make this the CV but my hands are cold so lets get this shit done
		pointer_type Value = nullptr;
		///std::mutex Mutx;
		///std::condition_variable Mutx_CV;
		bool Retrieved{false};


		///RETURN THESE AND MAKE THIS NON COPYABLE AGAIN!!!
		///==================
		//future(const future&) = delete;
		//future& operator=(const future&) = delete;
	};






//future<type> ReturnValue;
//future<type>& get_future()
//{
//	return ReturnValue;// std::move(ReturnValue);
//}
//	future<type> ReturnValue;
//virtual void operator()() override
//{
//	Invoke();
//}//	std::atomic<bool> isReady{ false };


*/
====================================================================================================================================================================================
                                                               #11/28															  															  
															  #Main.cpp															  															  
====================================================================================================================================================================================

/*
		Function_Counter = 0;
		Profiling::Timing::Profile_Timer<100> WrapperBenchmark;
		{
	    	std::vector<Wrapper_Base*> FunctionList;

//auto A =  new Wrapper(TestFunctionE, std::move(LOOP_COUNT));
//auto B =  new Wrapper(TestFunctionB, 1431);
//auto C =  new Wrapper(TestFunctionD, 123.321f, 10);
//auto D =  new Wrapper(TestFunctionA);
//auto E =  new Wrapper(TestFunctionC, 3.14159f, 123);
//auto F =  new Wrapper(TestFunctionF, std::move(LOOP_COUNT));
//auto G =  new Wrapper(TestFunctionG, std::move(LOOP_COUNT));
//auto H =  new Wrapper(TestFunctionH, std::move(LOOP_COUNT));
//auto I =  new Wrapper(TestFunctionI, std::move(LOOP_COUNT));
//auto J =  new Wrapper(TestFunctionJ, std::move(LOOP_COUNT));
//auto K =  new Wrapper([](int)->int { Print("Lambda Function Function List calls"); return 11; }, 10000);

			auto A = new(alloca(sizeof(Wrapper<decltype(TestFunctionE), int>)))       Wrapper(TestFunctionE, std::move(LOOP_COUNT));
			auto B = new(alloca(sizeof(Wrapper<decltype(TestFunctionB), int >)))      Wrapper(TestFunctionB, 1431);
			auto C = new(alloca(sizeof(Wrapper<decltype(TestFunctionD), float, int >))) Wrapper(TestFunctionD, 123.321f, 10);
			auto D = new(alloca(sizeof(Wrapper<decltype(TestFunctionA)  >)))          Wrapper(TestFunctionA);
			auto E = new(alloca(sizeof(Wrapper<decltype(TestFunctionC), float, int >))) Wrapper(TestFunctionC, 3.14159f, 123);
			auto F = new(alloca(sizeof(Wrapper<decltype(TestFunctionF), int>)))       Wrapper(TestFunctionF, std::move(LOOP_COUNT));
			auto G = new(alloca(sizeof(Wrapper<decltype(TestFunctionG), int>)))       Wrapper(TestFunctionG, std::move(LOOP_COUNT));
			auto H = new(alloca(sizeof(Wrapper<decltype(TestFunctionH), int>)))       Wrapper(TestFunctionH, std::move(LOOP_COUNT));
			auto I = new(alloca(sizeof(Wrapper<decltype(TestFunctionI), int>)))       Wrapper(TestFunctionI, std::move(LOOP_COUNT));
			auto J = new(alloca(sizeof(Wrapper<decltype(TestFunctionJ), int>)))       Wrapper(TestFunctionJ, std::move(LOOP_COUNT));
			auto K = new Wrapper([](int)->int { Print("Lambda Function Function List calls"); return 11; }, 10000);

			FunctionList.emplace_back(A);
			FunctionList.emplace_back(B);
			FunctionList.emplace_back(C);
			FunctionList.emplace_back(D);
			FunctionList.emplace_back(E);
			FunctionList.emplace_back(F);
			FunctionList.emplace_back(G);
			FunctionList.emplace_back(H);
			FunctionList.emplace_back(I);
			FunctionList.emplace_back(J);
			FunctionList.emplace_back(K);


			for (auto& F : FunctionList)
			{
				F->Invoke();
			}
			while (Function_Counter != 10) {/* Surely has passed but for completeness we will add  }
			auto R1 = A->ReturnValue.get_future().get();
			auto R2 = B->ReturnValue.get_future().get();
			auto R3 = C->ReturnValue.get_future().get();
			auto R4 = D->ReturnValue.get_future().get();
			auto R5 = E->ReturnValue.get_future().get();
			auto R6 = F->ReturnValue.get_future().get();
			auto R7 = G->ReturnValue.get_future().get();
			auto R8 = H->ReturnValue.get_future().get();
			auto R9 = I->ReturnValue.get_future().get();
			auto R10 = J->ReturnValue.get_future().get();
			auto R11 = K->ReturnValue.get_future().get();

			std::vector<std::vector<uint32_t>> Test;
			Test.push_back(R1);
			Test.push_back(R6);
			Test.push_back(R7);
			Test.push_back(R8);
			Test.push_back(R9);
			Test.push_back(R10);
			Print("Wrapped: "<< R4 << " : " << TestCompile(Test));
			//delete A; delete B; delete C; delete D; delete E; delete F; delete G; delete H; delete I; delete J;
			delete K;
			WrapperBenchmark.Stop();
		}

		std::cout << "  Wrapper Linear = " << WrapperBenchmark.Results / 1000.0f << " ms" << "\n"; // 0.020808  Difference of .000774
		*/
====================================================================================================================================================================================
                                                               															  															  
															  															  															  
====================================================================================================================================================================================
